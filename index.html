<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<HTML xmlns="http://www.w3.org/1999/xhtml">
<!--

URL: "https://gist.github.com/triplu-zero/34ab48b1565a9b7cc33308b688160e4b"
URL: "https://twitter.com/myriatablet1/status/1408994610005917705"
EMBED: "<script src="https://gist.github.com/triplu-zero/34ab48b1565a9b7cc33308b688160e4b.js"></script>"

Title: "JavaScript - 000 - #baseline"

Copyright (C) 2021 https://github.com/triplu-zero/

License: Unlicense

TODO:
 - NAND, NOR

NOTE: It's time to start a new version in HTML5 with WASM!
-->
<!--

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

-->
<HEAD>
<TITLE>JavaScript - 000 - #baseline</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<STYLE>
.layer_background{position:absolute;top:0px;left:0px;width:100%;height:100%;overflow:hidden;}
button{position:absolute; background:rgb(112,160,104);font-family:'Verdana';}
.txtEditor1{position:absolute;top:0px;left:0px;width:100%;height:95%;font-family:'Courier New';font-size:10pt;font-weight:normal;font-style:normal;visibility:visible;}
.txtCALC1{position:relative;top:0px;left:0px;width:100%;height:22px;font-family:'Courier New';font-size:10pt;font-weight:normal;font-style:normal;visibility:visible;}
.txtCON1{position:absolute;top:0px;left:0px;width:100%;height:95%;font-family:'Courier New';font-size:10pt;font-weight:bold;font-style:normal;visibility:hidden;background:black;color:rgba(200, 200, 200, 255);}
.btn1Class{top:95%; left:0; width:15%; height:5%;font-family:'Verdana';font-size:13px}
.btn2Class{top:95%; left:15%; width:15%; height:5%;font-family:'Verdana';font-size:13px}
.btn3Class{top:95%; left:30%; width:15%; height:5%;font-family:'Verdana';font-size:13px}
.btn4Class{top:95%; left:45%; width:15%; height:5%;font-family:'Verdana';font-size:13px}
.btn5Class{top:95%; left:60%; width:10%; height:5%;font-family:'Verdana';font-size:13px}
.btn6Class{top:95%; left:70%; width:10%; height:5%;font-family:'Verdana';font-size:13px}
.BtnTab1{
   position:absolute; top:95%; left:80%; width:20%; height:5%; font-family:'Verdana';
   font-size: 13px;
   background:#70A068;
}
.B1Class{top:0;left:0;width:10%;height:100%;}
.B2Class{top:0;left:10%;width:10%;height:100%;}
.B3Class{top:0;left:20%;width:10%;height:100%;}
.B4Class{top:0;left:30%;width:10%;height:100%;}
.B5Class{top:0;left:40%;width:10%;height:100%;}
.B6Class{top:0%;left:50%;width:10%;height:100%;}
.B7Class{top:0%;left:60%;width:10%;height:100%;}
.B8Class{top:0%;left:70%;width:10%;height:100%;}
.B9Class{top:0%;left:80%;width:10%;height:100%;}
.B0Class{top:0%;left:90%;width:10%;height:100%;}
.BT1Class{position:absolute;top:0;left:0;width:100%;height:7px;visibility:visible}
pre{color:black;background:#70A068;font-family:'Verdana';}
body{border:none; margin:0; color:white; background:#70A068;font-family:'sans-serif';font-size:x-small}
div{border:none;margin:0;font-family:'Verdana';font-size:13px}
</STYLE>
</HEAD>
<BODY onload="OnLoad()" SCROLL=NO>
<DIV ID="layer_background" CLASS="layer_background">
<DIV ID=layer_options>
<BR><INPUT TYPE=TEXT ID="CALC1" CLASS="txtCALC1" ACCESSKEY="Q" onclick="Compute(event);" onkeyup="Calc_OnKeyUp(event)" onkeydown="Calc_OnKeyDown(event)">
<FONT SIZE=3><PRE ID="calc1_output" STYLE="background:rgb(112,160,104);color:blue;"><PRE id='eval_lines'></PRE></PRE></FONT>
</DIV>
<DIV ID=layer_editor STYLE="position:absolute;left:0px;top:0px;width:100%;height:100%">
<TEXTAREA ID="textarea" CLASS="txtEditor1" ACCESSKEY="W" COLS=80 ROWS=25 WRAP=OFF></TEXTAREA>
<TEXTAREA ID="CON1" CLASS="txtCON1" ACCESSKEY="P" COLS=80 ROWS=25 WRAP=VIRTUAL></TEXTAREA>
<BUTTON ID="but1" CLASS="btn1Class" onclick="but1_onclick(event)" name= 'HTML'><CENTER><B>   H<U STYLE="color:blue">T</U>ML   </CENTER></B></BUTTON>
<BUTTON ID="but2" CLASS="btn2Class" onclick="but2_onclick(event)" name= 'SCRIPT'><DIV><B> <U STYLE="color:blue">S</U>CRIPT </B></DIV></BUTTON>
<BUTTON ID="but3" CLASS="btn3Class" onclick="but3_onclick(event)" name= 'Help'><PRE><B>  <U STYLE="color:blue">H</U>elp  </B></PRE></BUTTON>
<BUTTON ID="but4" CLASS="btn4Class" onclick="but4_onclick(event)" name= 'Compute'><DIV><B>  <U STYLE="color:blue">C</U>ompute  </B></DIV></BUTTON>
<BUTTON ID="but5" CLASS="btn5Class" onclick="but5_onclick(event)" ACCESSKEY="L" name= 'Load'><DIV><B>  <U STYLE="color:blue">L</U>oad  </B></DIV></BUTTON>
<BUTTON ID="but6" CLASS="btn6Class" onclick="but6_onclick(event)" ACCESSKEY="V" name= 'Save'><DIV><B>  Sa<U STYLE="color:blue">v</U>e  </B></DIV></BUTTON>
<DIV CLASS="BtnTab1">
<BUTTON ID="B1" CLASS="B1Class">1</BUTTON><BUTTON ID="B2" CLASS="B2Class">2</BUTTON>
<BUTTON ID="B3" CLASS="B3Class">3</BUTTON><BUTTON ID="B4" CLASS="B4Class">4</BUTTON>
<BUTTON ID="B5" CLASS="B5Class">5</BUTTON><BUTTON ID="B6" CLASS="B6Class">6</BUTTON>
<BUTTON ID="B7" CLASS="B7Class">7</BUTTON><BUTTON ID="B8" CLASS="B8Class">8</BUTTON>
<BUTTON ID="B9" CLASS="B9Class">9</BUTTON><BUTTON ID="B0" CLASS="B0Class">0</BUTTON>
<BUTTON ID="BT1" CLASS="BT1Class" onclick="JavaScript:terminal('toggle');" name= 'OUTPUT'>OUTPUT</BUTTON>
</DIV>
</DIV>
</DIV><!--layer_background-->
</BODY>
<SCRIPT>
String.prototype.CRLF= "\r\n";

function isFirefox() {
  var n= navigator;
  if(strstr(n.userAgent, 'Firefox')) return true;
  if(strstr(n.userAgent, 'Gecko')) return true;
  if(strstr(n.appName, 'Netscape')) return true;
  return false;
}

function isGoogleChrome() {
  var n= navigator;
  if(
    strstr(n.userAgent, "AppleWebKit")&&
    strstr(n.userAgent, "Chrome")&&
    strstr(n.userAgent, "Safari")
  ) return true;
  return false;
}//~isGoogleChrome()

// DOM: HELPER FUNCTIONS

function _() {
  return 'underscore';
}
function $() {
  return 'dollar';
}
window._= _;
window.$= $;

function isFunction(foo) {return (typeof(foo)== 'function');}

function DOM_get_function_header(foo) {
  if(typeof(foo)== 'function') {
    foo= foo.toString().split('{')[0];
    foo= foo.split('function'); //foo= foo.split('function').reverse();
    foo= foo.remove(0);         //foo.length--;
    foo= foo.join('function');  //foo= trim(foo.reverse().join('function'));
    return foo;
  }else return undefined;
}

function get_call_stack(f, depth, bStrip) { // DOM: DEBUGGER HELPER FUNCTION
   var s= [];
   if(!arguments.length) f= arguments.callee.caller.arguments.callee;
   s[s.length]= ((bStrip== true)? DOM_get_function_header(f): f);
   if(!depth) depth= -1;
   while((f.caller!= null)&& depth--) {
      s[s.length]= ((bStrip== true)? DOM_get_function_header(f.caller): f.caller);
      f= f.caller.arguments.callee;
   }
   return s; // var st= get_call_stack(arguments.callee);
}

function SetLastError(e) {
   var he= syscall('errors');
   if(!isHandle(he)) alert(e); //
   else he.set(e);
}

function GetLastError(bClear) {
  if(bClear) {
        var syse, e;
    syse= syscall('errors');
    e= syse.get();
    syse.set();
    return e;
  }
  return syscall('errors').get(); //
}

//document.body.onclick="alert('click');";
//bugfix_event_handlers(document.body);

function bugfix_event_handlers(obj) {// [IE6] bug-fix
   var ev= 'onactivate.onafterprint.onafterupdate.onbeforeactivate.onbeforecopy.onbeforecut'+
     '.onbeforedeactivate.onbeforeeditfocus.onbeforepaste.onbeforeprint.onbeforeunload.onbeforeupdate'+
     '.onblur.oncellchange.onclick.oncontextmenu.oncontrolselect.oncopy.oncut.ondataavailable'+
     '.ondatasetchanged.ondatasetcomplete.ondblclick.ondeactivate.ondrag.ondragend.ondragenter'+
     '.ondragleave.ondragover.ondragstart.ondrop.onerrorupdate.onfilterchange.onfocus.onfocusin'+
     '.onfocusout.onhelp.onkeydown.onkeypress.onkeyup.onlayoutcomplete.onload.onlosecapture.onmousedown'+
     '.onmouseenter.onmouseleave.onmousemove.onmouseout.onmouseover.onmouseup.onmousewheel.onmove'+
     '.onmoveend.onmovestart.onpage.onpaste.onpropertychange.onreadystatechange.onresize.onresizeend'+
     '.onresizestart.onrowenter.onrowexit.onrowsdelete.onrowsinserted.onscroll.onselect.onselectstart.onunload';
   ev= ev.split('.');//"69 events"
   if(obj=== undefined) return ev;//"return event handlers that we are aware of"
   var i, n, fns;
   fns= [];
   n= ev.length;
   //alert(DOM_getAttributeNames(obj, true));//dbg
   //alert(typeof(obj)+ ":\t\t"+ obj.tagName+ "\nid:\t\t"+ obj.id+ "\nattributes.length:\t"+ obj.attributes.length);//dbg
   for(i= 0; i< n; i++) {
      var e;
      try {
        if((eval("obj."+ ev[i])!= null)&&
           (typeof(eval("obj."+ ev[i]))!= 'function')&&
           (obj.attributes[ev[i]]!= 'null')&&
           (typeof(obj.attributes[ev[i]].value)== 'string')) {
          obj.setAttribute(ev[i], new Function(obj.getAttribute(ev[i])));//eval("obj."+ ev[i]+ "= new Function(obj.getAttribute(ev[i]));");
          fns.push(ev[i]);
        }
      }catch(e) {
        //alert(i+ ": "+ ev[i]);//dbg
      }
   }
   return fns;//"return event handlers that received patches"
}//~bugfix_event_handlers()

function DOM_getAttributeNames(obj, bPropertiesOnly) {//BUG:[FF3]: only currently used attributes are listed (some attributes used with default values are not listed)
  var i, n, attr;
  if(obj=== undefined) return [];
  if(!isObject(obj)) return [];
  if(obj.attributes=== undefined) return [];
  attr= [];
  n= obj.attributes.length;
  for(i= 0; i< n; i++) attr.push(obj.attributes.item(i).name);
  if(bPropertiesOnly) {
    attr= [];
    for(i in obj) attr.push(i);
    return attr;
  }
  return attr;
}//~DOM_getAttributeNames()

function DOM_hierarchy2string(obj, _depth) { //DOM: DEBUGGER HELPER FUNCTION
   var e;
   var msg= '';
   function _DOM(DOM) {
      if(obj.hasChildNodes()) {
         for (var i= 0; i< obj.childNodes.length; i++) {
            msg+= DOM(obj.childNodes[i], _depth+ 1)
         }
      }
   }
   if(typeof(_depth)== 'undefined') _depth= 0;
   if(typeof(obj)== 'undefined') {
      obj= document;
      _DOM(arguments.callee);
      return msg;
   }else {
      for(var j= 0; j<= _depth; j++) msg+= "  ";
      try {
        var id= (obj.getAttribute)? ' ['+ obj.getAttribute('id')+ ']': '';
        msg+= obj.tagName+ id;
     }catch(e) {
        alert('['+ _depth+ ']DOM:error');
     };
     msg+= "\n";
     _DOM(arguments.callee);
     return msg;
   }
}//~DOM_hierarchy2string()

/*
function DOM_children(obj) {
  var children, v, i, n;
  children= []
  v= [obj];
  while(v.length){
    obj= v.first();
    children.push(obj);
    n= obj.childNodes.length;
    for (i= 0; i< n; i++) {v.push(obj.childNodes[i]);}//bug: disorder!
  }
  //children.first();
  return children;
}//~DOM_children()
*/

function DOM_children(obj) {
  var children, i, n;
  if(!obj) obj= window.document.childNodes[0];//HTML
  children= []
  n= obj.childNodes.length;
  if(!n) children.push(obj);
  for(i= 0; i< n; i++) {children= children.concat(arguments.callee(obj.childNodes[i]));}//bug: recursive!
  return children;
}//~DOM_children()

function DOM_all(obj) {
  var v;
  if(!obj) obj= window.document.childNodes[0];//HTML
  v= DOM_children(obj);
  v.first(obj);
  return v;
}//~DOM_all()

function DOM_innerText(obj) {
  var txt, children, i, n;
  txt= [];
  children= DOM_children(obj);
  n= children.length;
  for(i= 0; i< n; i++) {
    if(children[i].nodeType== 3) {
      txt.push(children[i].nodeValue);
    }else {
      if(children[i].nodeName.toUpperCase()== 'BR') {
        txt.push('\n');
      }
    }
  }
  return txt.join('');
}//~DOM_innerText()

function DOM_element_attributes(obj) {
   var i, n, a, attr;
   n= obj.attributes.length;
   a= obj.attributes;
   attr= new Array(n);
   for(i= 0; i< n; i++) {
      var tag= a[i].name;
      attr[i]= [a[i].name, a[tag].nodeValue];
      //echo(a[tag].nodeType+ '\t'+ a[i].name+ '= '+ a[tag].nodeValue);
   }
   return attr; //DOM_element_attributes(document.firstChild);
}

function DOM_getStyle(elem, attr, prop) {
  if(typeof elem == 'string') elem= document.getElementById(elem);
  if(!elem) return "";
  if(!prop) prop= attr;
  if(elem.currentStyle) {
    return elem.currentStyle[prop];
  }else if(window.getComputedStyle) {
    return window.getComputedStyle(elem, "").getPropertyValue(attr);
  }else if (document.defaultView&& document.defaultView.getComputedStyle) {
    return document.defaultView.getComputedStyle(elem, "").getPropertyValue(attr);
  }else if (elem.style[prop]) {
    return elem.style[prop];
  }
  return "";
}//~DOM_getStyle()

function DOM_setStyle(obj, attr) {
  var i, n;
  if(typeof attr== 'string') attr= DOM_split_attributes(attr);
  n= attr.length;
  for(i= 0; i< n; i++) {
    if(attr[i].length== 2) obj.style[attr[i][0]]= attr[i][1];//obj.setAttribute(attr[i][0], attr[i][1]);
  }
}

function DOM_getRect(obj) { // UNDER CONSTRUCTION
  if(typeof obj== 'string') obj= document.getElementById(obj);
  var left, top, right, bottom;
  left= DOM_getStyle(obj, 'left');
  top= DOM_getStyle(obj, 'top');
  right= DOM_getStyle(obj, 'width');
  bottom= DOM_getStyle(obj, 'height');
  if(left== 'auto') { //
    left= 0;
  }
  else left= parseInt(left.split('px')[0]);
  if(top== 'auto') { //
    top= 0;
  }
  else top= parseInt(top.split('px')[0]);
  right= parseInt(right.split('px')[0])+ left;
  bottom= parseInt(bottom.split('px')[0])+ top;
  return new Rect(left, top, right- 1, bottom- 1);
}//~DOM_getRect()

function DOM_opacity(obj, alpha) {//todo:get rid of round-off errors
  var prev_alpha, bSet;
  bSet= true;
  alpha= parseFloat(alpha);
  if(isNaN(alpha)) {
    bSet= false;
  }else {
	//"interval:[(0.0: transparent) -> (0.999: opaque)]"
    if(0.0<= alpha<= 1.0) alpha= ((alpha* 256)<< 0);
	//"interval:[0: transparent -> 255: opaque]"
    alpha<<= 0;
  }
  if(typeof(obj.filters)== 'object') {//[IE6]
    if(obj.filters.alpha) {
      prev_alpha= (parseFloat(obj.filters.alpha.opacity)/ 100)* 255;
    }else {
      prev_alpha= 255;
    }
    if(bSet) {
      obj.style.filter= 'alpha';
      obj.filters.alpha.opacity= ((alpha/ 255)* 100);
    }
  }else {//[FF3]
    if(obj.style.opacity.length) {
      prev_alpha= parseFloat(obj.style.opacity)* 255;
    }else {
      prev_alpha= 255;
    }
    if(bSet) obj.style.opacity= (alpha/ 255);
  }
  return prev_alpha;
}//~DOM_opacity()

function DOM_split_attributes(a) {
  var v= a.split(';');
  v.foreach('v[i]= v[i].split(":");v[i][0]= trim(v[i][0]); v[i][1]= trim(v[i][1])');
  return v;
}

function DOM_new(tag_name, attr) {
  var obj, i, n;
  obj= document.createElement(tag_name);
  if(typeof attr== 'string') attr= DOM_split_attributes(attr);
  n= attr.length;
  for(i= 0; i< n; i++) {
    if(attr[i].length== 2) obj.setAttribute(attr[i][0], attr[i][1]);
  }
  return obj;
}

function DOM_add(parent, obj) {
  if(arguments.length== 3) obj= DOM_new(arguments[1], arguments[2]);
  if( isObject(parent)&& (
      (typeof(parent.appendChild)== 'function')|| //[FF2]
      (typeof(parent.appendChild)== 'object')     //[IE6]
      )
     )
    return parent.appendChild(obj);
  else return null;
}//~DOM_add()

function DOM_remove(obj) {
  if(typeof obj== 'string') obj= document.getElementById(obj);
  if(obj&& obj.parentNode)
    return obj.parentNode.removeChild(obj);
  else return null;
}//~DOM_remove()

function DOM_element2window(obj) {//BUG:TODO:get client/window rect.
   function GetActiveWindow() {return window.GetActiveWindow();}
   function SetActiveWindow(hwnd) {window.SetActiveWindow(hwnd)}
   function GetClientRect() { return new Rect(0, 0, this.style.width, this.style.height); }
   function GetWindowRect() {
      var w= this.style;
      return new Rect(w.left, w.top, parseInt(w.left)+ parseInt(w.width), parseInt(w.top)+ parseInt(w.height));
   }
   function MoveWindow(x, y, width, height) {
      this.MoveTo(x, y);
      this.ResizeTo(width, height);
   }
   function CloseWindow() {
      for (var i in this.hwnd_child) {
         try { this.hwnd_child[i].CloseWindow(); } catch(e) {};
      }
//      if(typeof(this.event_handler["OnClose"]== "function")) {
//         this.event_handler["OnClose"]();
//      }
      this.DestroyWindow();
   }
   function MoveTo(x,y) {//BUG:TODO:['%', 'px', 'pt', 'em']
      if(x.constructor== Number) x= x+ 'px';//[FF5] bug-fix
      if(y.constructor== Number) y= y+ 'px';
      this.style.top= y; this.style.left= x;
   }
   function ResizeTo(width, height) {//BUG:TODO:['%', 'px', 'pt', 'em']
      if(width.constructor== Number) width= width+ 'px';//[FF5] bug-fix
      if(height.constructor== Number) height= height+ 'px';
      this.style.width= width; this.style.height= height;
   }
   function DestroyWindow() {
//      alert("Closing: \n"+ this.GetWindowText());
      this.parentNode.removeChild(this); //this.outerHTML= "";//[FF2] BUG
   }
   function ShowWindow(show) {
     if(!arguments.length) show= true;
     var mode= (show)? "block": "none"; this.style.display= mode;
     mode= (show)? "visible": "hidden"; this.style.visibility= mode; 
   } //"inline"
   function HideWindow() {
     this.ShowWindow(false);
   }
   function GetWindowText() {
	 if(this.tagName== 'TEXTAREA') return this.value;
     if(this.innerText) {
       return this.innerText;
     }else {
       return DOM_innerText(this);
     }
   }//~CreateWindow.GetWindowText()
   //function SetWindowText(txt) {var old_txt= this.innerText; this.innerText= txt; return old_txt;}
   function SetWindowText(txt) {
     var old_txt, obj, range;
     old_txt= this.GetWindowText();
     if(this.tagName== 'TEXTAREA') {
	     this.value= txt;
     }else {
       if(document.createRange) {
         range= document.createRange();
         range.setStartAfter(this);
         obj= range.createContextualFragment(txt);
        while (this.hasChildNodes()) {this.removeChild(this.lastChild);}
         this.appendChild(obj);
       }else {this.innerHTML= txt;}
     }
     return old_txt;
   }
   function FontSize(size) {
      s= this.style.fontSize;
      if(arguments.length== 1)  this.style.fontSize= size+ "px"; // set size (in pixels)
      return s;
   }
   function TextColor(color) {
      if(arguments.length== 1)   this.style.color= color;
      return this.style.color;
   }
   function TextBackground(background) {
      if(arguments.length== 1) this.style.background= background;
      return this.style.background;
   }
   function OnClick(event) {
          event= bugfix_event(event);
      var msg= event;
      var hwnd= msg.srcElement;
      window.hwnd= hwnd;
      if(msg.ctrlKey) {
         hwnd.Close();
      };
      if(msg.altKey) {
         hwnd.MoveTo(msg.x, msg.y);
      };
      if(msg.shiftKey) {
         event.cancelBubble = true;
         event.returnValue= false;
         alert("OnProperties");
      }
   }
   function opacity(alpha) {return DOM_opacity(this, alpha);}
   var hwnd= obj;

   hwnd.user= new Object; // storage for arbitrary user data
   hwnd.hwnd_child= new Array();
   hwnd.GetActiveWindow= GetActiveWindow;
   hwnd.SetActiveWindow= SetActiveWindow;
   hwnd.GetClientRect= GetClientRect;
   hwnd.GetWindowRect= GetWindowRect;
   hwnd.MoveWindow= MoveWindow;
   hwnd.MoveTo= MoveTo;
   hwnd.ResizeTo= ResizeTo;
   hwnd.DestroyWindow= DestroyWindow;
   hwnd.CloseWindow= CloseWindow;
   hwnd.Close= CloseWindow;
   hwnd.ShowWindow= ShowWindow;
   hwnd.Show= ShowWindow;
   hwnd.HideWindow= HideWindow;
   hwnd.Hide= HideWindow;
   hwnd.GetWindowText= GetWindowText;
   hwnd.SetWindowText= SetWindowText;
   hwnd.FontSize= FontSize;
   hwnd.TextColor= TextColor;
   hwnd.TextBackground= TextBackground;
   hwnd.onclick= OnClick;
   hwnd.opacity= opacity;
   hwnd.alpha= opacity;

   return hwnd;
}//~DOM_element2window()

//var x= DOM_element2window(textarea); schedule('x.SetWindowText("Hello world!\\n"+ (new Date()));');toggle();

window.get_call_stack= get_call_stack;
window.GetLastError= GetLastError;
window.SetLastError= SetLastError;
window.bugfix_event_handlers= bugfix_event_handlers;
window.DOM_hierarchy2string= DOM_hierarchy2string;
window.DOM_element_attributes= DOM_element_attributes;
window.DOM_getStyle= DOM_getStyle;
window.DOM_getRect= DOM_getRect;
window.DOM_split_attributes= DOM_split_attributes;
window.DOM_new= DOM_new;
window.DOM_add= DOM_add;
window.DOM_remove= DOM_remove;
window.DOM_element2window= DOM_element2window;
</SCRIPT>
<SCRIPT>
 function new_ID() { // [DEPRECATED] ("syscall('ID')")
    if(typeof(arguments.callee._id_)!= 'number') arguments.callee._id_= 0;
    return 'ID'+ (arguments.callee._id_++);
 }
 function Null() { // BUGFIX (a null object creation)
   if(this.constructor!= arguments.callee) return new arguments.callee();//always
   this.valueOf= new Function('return null');
   this.toString= new Function('return "null";');
   return this;
 }
 function isObject(item) {return (typeof(item)== 'object');}
 function isNull(item) {
         return ((item== null)|| (isObject(item)&& item.constructor== Null));
 }
 function isString(item) {return (typeof(item)== 'string');}
 function isArray(item) {
  if(isNull(item)) return false;
  return (item.constructor=== Array)
 }
 function isEmpty(item) {
  switch(typeof(item)) {
    case 'string': return (item.length== 0)? true: false;
    case 'undefined': return true;
    case 'number': return isNaN(item); // (item=== NaN)
    case 'unknown':   return true;
 //    case 'boolean': return (item)? false: true; //
    case 'object': {
       if(item== null) return true;
       switch(item.constructor) {
         case Array: return (item.length== 0)? true: false;
         case Object: { // test for 'arguments.length'
           var e; try{
            if(typeof(x.length)== 'number')
              return (x.length== 0)? true: false;
           }catch(e) {return false;}
         }
         default: return false;
       }
    }break;
    case 'function':
    default: return false;
  }
  return true;
 }//~isEmpty()

 // transcendental object
 function TObject(szClass) {
    var e;
    if(typeof(ActiveXObject)== 'undefined') {
            SetLastError(['TObject: "'+ szClass+ '" not implemented!',
                Errors.NotImplemented, get_call_stack(arguments.callee)]);
            return (new Null());
    }
    try {
       return new ActiveXObject(szClass);
    }catch(e) {
       return (new Null());
    }
 }

// Automation object
function AObject(szPath, szClass) { //var x_doc= AObject("a:\\x.doc"); alert(x_doc); x_doc.Close();
   var e;
   try {
      switch(arguments.length) {
         case 0: return null;
         case 1: return GetObject(szPath);
         case 2:
         default:return GetObject(szPath, szClass);
      }
   }catch(e) {
       return (new Null());
   }
}

/* Platform-dependent object BUG BUG [incomplete] BUG BUG */
function PObject(szClass) {
   if(arguments.length== 0) return null;
   var e;
   try {
   switch(arguments[0]) {
      case "Enumerator": {
         if(arguments.length== 2) {
            var collection= arguments[1]; // must be a collection object (otherwise will fail)
            return new Enumerator(collection);
         }
      }break;
      case "Global": return window;
      case "Function": {
         switch(arguments.length) {
            case 1: return Function;
            default: {
               var _script= "new Function(arguments[1]";
               for(var i= 2; i< arguments.length; i++) {
                  _script+= ",arguments["+ i+"]";
               }
               _script+= ')';
               return eval(_script);
            }
         }
      }break;
      case "Regular Expression":
      case "RegExp": {

      }break;
      case "VBArray": {

      }break;
      case "Date": {
         //NOT IMPLEMENTED
      }break;
      case "Transcendental":
      case "ActiveXObject": {
         if(arguments.length== 2) {
            var szClass= arguments[1];
            return TObject(szClass);
         }
      }break;
      case "Automation":
      case "GetObject": {
         switch(arguments.length) {
            case 2: {
               var szPath= arguments[1];
               return AObject(szPath);
            }
            case 3: {
               var szPath= arguments[1];
               var szClass= arguments[2];
               return AObject(szPath, szClass);
            }
         }
      }break;
      default: return (new Null());
   }
   }catch(e){return (new Null());}
   return (new Null());
}//~PObject()

function isTObject(obj) {
  if((typeof(obj)== 'object')&& (obj!= null)&& (!obj.constructor)) return true;
  return false;
}

function Enum(fields, first, skip) {
  if(this.constructor!= arguments.callee) return new arguments.callee(fields, first, skip);//create a new object, always
  if(isArray(first)&& (fields.length<= first.length)&& isNull(skip)) {
    for(var i= 0; i< fields.length; i++) {
       eval("this."+ fields[i]+ "="+  first[i]);
     }
  }else {
   first= parseInt(first);
   first= isNaN(first)?0:first;
   if(isNull(skip)) {
      for(var i= 0; i< fields.length; i++) {
         eval("this."+ fields[i]+ "= first+ i;");
      }
   }else {
      var bUnique= true;
      function sort_func(a, b) {
         if(a== b) {
            bUnique= false;
            return 0;
         }else {
            if(a< b) {
               return -1;
            }else {
               return 1;
            }
         }
      }
      skip.sort(sort_func);
      if(!bUnique) return null; // ..??.. can skip an item only once
      var j= 0;
      var n= fields.length+ skip.length;
      for(var i= 0; i< n; i++) {
         if((first+ i)== skip[j]) {
            j++;
         }else
            eval("this."+ fields[i- j]+ "= first+ i;");
      }
   }
  }
  return this;
}//~Enum()

function Handle() { // a bare object might be difficult to grasp; hence the need for a handle
   function set(_function) {
      var e; try {
         delete e;
         switch(typeof(arguments[0])) {
         case 'function': {
            this.entity= _function();
         } break;
         case 'string': {
            this.entity= eval(arguments[0]);
         } break;
//         case 'unknown': { this.entity= undefined;} break; // ??
         default: this.entity= arguments[0];
         }
      } catch(e){};
      return this.entity;
   }
   function get() {return this.entity;}
   function valueOf() {return this.entity.valueOf();}
   function toString() {return this.entity.toString();}
   this.toString= toString;
   this.valueOf= valueOf;
   this.get= get;
   this.set= set;
   return this;
}

function Entity(name, value, type) {
   if(arguments.length< 1) name= '[anonymous]';
   if(arguments.length< 2) {
      value= '[empty]';
      if(arguments.length< 3) type= '[void]';
   } else {
      if(arguments.length< 3) type= typeof(value);
   };
   this.name= name;
   this.value= value;
   this.type= type;
   function valueOf() {return [this.name, this.value, this.type];}
   function toString() {return this.valueOf().toString();}
   function destroy() {
      this.name= '[anonymous]';
      this.value= '[empty]';
      this.type= '[void]';
   }
   function get() {return this.value;}
   function set(value, type) {
      this.value= value;
      if(arguments.length== 2) {
         this.type= type;
      }else {
          this.type= typeof(value);
      }
   }
   function rename(name) {this.name= name;}
   this.valueOf= valueOf;
   this.toString= toString;
   this.destroy= destroy;
   this.get= get;
   this.set= set;
   this.rename= rename;
//   return this;
}//~Entity()

function Stack() {
   function valueOf() {return this.stack;}
   function toString() {return this.stack.toString();}
   function clear() {this.stack.length= 0;}
   function count() {return this.stack.length;}
   function top() {
      if(top.arguments.length== 0) {
         return this.stack[this.stack.length- 1];
      }else {
         var item_count= parseInt(top.arguments[0]);
         if(item_count<= 0) {
            return this.stack[this.stack.length- 1];
         }else {
            var items= new Array(item_count);
            for(var i= 0; i< item_count; i++) {
               items[i]= this.stack[this.stack.length- (i+ 1)];
            }
            return items;
         }
      }
   }
   function pop() {
      if(pop.arguments.length== 0) {
         var item= this.top();
         this.stack.length--;
         return item;
      }else {
         var item_count= parseInt(pop.arguments[0]);
         if(item_count<= 0) {
            return this.top();
         }else {
            var items= new Array(item_count);
            for(var i= 0; i< item_count; i++) {
               items[i]= this.top();
               this.stack.length--;
            }
            return items;
         }
      }
   }
   function push(item) {
      this.stack[this.stack.length]= item;
      for(var i= 1; i< push.arguments.length; i++)
         this.stack[this.stack.length]= push.arguments[i];
      return this.count();
   }
   this.clear= clear;
   this.count= count;
   this.top= top;
   this.pop= pop;
   this.push= push;
   this.toString= toString;
   this.valueOf= valueOf;
   this.stack= new Array;
   for(var i= 0; i< Stack.arguments.length; i++)
      this.push(Stack.arguments[i]);
}//~Stack()

function Point(x, y) {
   if(x=== null) x= undefined;
   if(typeof(x)== "object" && arguments.length== 1 && x.constructor=== Point) {
      y= x.y;
      x= x.x;
   }else {
      //x= parseInt(x);      y= parseInt(y);
      x= parseFloat(x);
      y= parseFloat(y);
      if(isNaN(x)) x= 0;
      if(isNaN(y)) y= 0;
   }
   function move(x, y) {
      this.x= x; // abscisa
      this.y= y; // ordinate
   }
   function translate(x, y) {
      this.x+= x;
      this.y+= y;
   }
   function rotate(c, alpha) {
      var p= rotplan(c, this, alpha);
      this.move(p.x, p.y);
   }
   function equals(p) {
      if(arguments.length== 1 && typeof(p)== "object" && p.constructor=== Point) {
         return (this.x== p.x)&& (this.y== p.y);
      }else return false;
   }
   function copy(p) {
      if(arguments.length== 1 && typeof(p)== "object" && p.constructor=== Point) {
         this.x= p.x;
         this.y= p.y;
      }
   }
   function valueOf() {
      return [this.x, this.y];
   }
   function toString() {
      return [this.x, this.y].toString();
   }
   this.move= move;
   this.translate= translate;
   this.equals= equals;
   this.copy= copy;
   this.valueOf= valueOf;
   this.toString= toString;
   this.x= x;
   this.y= y;
}//~Point()

function Rect(left, top, right, bottom) {//UNDER CONSTRUCTION
   if(left=== null) left= undefined;
   if(arguments.length== 1 && typeof(left)== "object" && left.constructor=== Rect) {
      bottom= left.bottom;
      right= left.right;
      top= left.top;
      left= left.left;
   }else {
      if(arguments.length== 2) {
         right= parseFloat(left.valueOf());
         bottom= parseFloat(top.valueOf());
         left= 0;
         top= 0;
      }else {
         //this.reshape(left, top, right, bottom);
      };
   };
   function center(rt) { // move to the center of rect rt
      var tcx= parseInt(this.left+ Math.abs(this.right- this.left)/ 2);
      var tcy= parseInt(this.top+ Math.abs(this.bottom- this.top)/ 2);
      if(arguments.length== 1 && typeof(rt)== "object" && rt.constructor=== Rect) {
         var rcx= parseInt(rt.left+ Math.abs(rt.right- rt.left)/ 2);
         var rcy= parseInt(rt.top+ Math.abs(rt.bottom- rt.top)/ 2);
         var dx= (tcx>= rcx)? (tcx- rcx): (rcx- tcx);
         var dy= (tcy>= rcy)? (tcy- rcy): (rcy- tcy);
         this.translate(dx, dy);
      };
      var p= new Point(tcx, tcy);
      p.translate(dx, dy);
      return p;
   }
   function translate(dx, dy) {
      dx= parseFloat(dx); if(isNaN(dx)) dx= 0;
      dy= parseFloat(dy); if(isNaN(dy)) dy= 0;
      this.left+= dx;
      this.top+= dy;
      this.right+= dx;
      this.bottom+= dy;
   }
   function scale(sx, sy) {
      sx= parseFloat(sx); if(isNaN(sx)) sx= 1;
      sy= parseFloat(sy); if(isNaN(sy)) sy= sx;
      this.left*= sx;
      this.top*= sy;
      this.right*= sx;
      this.bottom*= sy;
   }
   function move(x, y) { // move left_top corner to point at coord (x,y)
      x= parseFloat(x); if(isNaN(x)) x= 0;
      y= parseFloat(y); if(isNaN(y)) y= 0;
      var w= this.right- this.left;
      var h= this.bottom- this.top;
      this.left= x;
      this.top= y;
      this.right= x+ w;
      this.bottom= y+ h;
   }
   function resize(w, h) {
      w= parseFloat(w); if(isNaN(w)) w= 0;
      h= parseFloat(h); if(isNaN(h)) h= 0;
      this.right= this.left+ w;
      this.bottom= this.top+ h;
   }
   function expand(dh, dv) { // by delta amount in both directions horizontally & vertically
      dh= parseFloat(dh);  if(isNaN(dh)) dh= 0;
      dv= parseFloat(dv);    if(isNaN(dv)) dv= 0;
      this.left-= dh;
      this.top-= dv;
      this.right+= dh* 2;
      this.bottom+= dv* 2;
   }
   function reshape(left, top, right, bottom) {
      left= parseFloat(left);  if(isNaN(left)) left= 0;
      top= parseFloat(top);    if(isNaN(top)) top= 0;
      right= parseFloat(right);  if(isNaN(right)) right= 0;
      bottom= parseFloat(bottom); if(isNaN(bottom)) bottom= 0;
      this.left= left;
      this.top= top;
      this.right= right;
      this.bottom= bottom;
   }
   function copy(rt) { // copy data from rt rect
      if(arguments.length== 1 && typeof(rt)== "object" && rt.constructor=== Rect) {
         this.left= rt.left;
         this.top= rt.top;
         this.right= rt.right;
         this.bottom= rt.bottom;
      }
   }
   function inside(x, y) { // is point inside rect?
      x= parseFloat(x);  if(isNaN(x)) return false;
      y= parseFloat(y);    if(isNaN(y)) return false;
      var w= this.right- this.left;
      var h= this.bottom- this.top;
      return (x >= this.left) && ((x- this.left) < w) && (y >= this.top) && ((y- this.top) < h);
   }
   function intersects(rt) { // check if the two rects, this & rt, intersect
      if(arguments.length== 1 && typeof(rt)== "object" && rt.constructor=== Rect) {
         return !((rt.right <= this.left)|| (rt.bottom <= this.top)||
          (rt.left >= this.right)|| (rt.top >= this.bottom));
       }else return false;
    }
   function equals(rt) { // are two rects equal ?
      if(arguments.length== 1 && typeof(rt)== "object" && rt.constructor=== Rect) {
          return (rt.left == this.left) && (rt.top == this.top) &&
                (rt.right == this.right) && (rt.bottom == this.bottom);
      }else return false;
   }
   function isEmpty() {
      var w= this.right- this.left;
      var h= this.bottom- this.top;
      return (w <= 0) || (h <= 0);
   }
   function valueOf() {
      return [this.left, this.top, this.right, this.bottom];
   }
   function toString() {
      return [this.left, this.top, this.right, this.bottom].toString();
   }
   this.center= center;
   this.translate= translate;
   this.scale= scale;
   this.move= move;
   this.resize= resize;
   this.expand= expand;
   this.reshape= reshape;
   this.copy= copy;
   this.inside= inside;
   this.intersects= intersects;
   this.equals= equals;
   this.isEmpty= isEmpty;
   this.valueOf= valueOf;
   this.toString= toString;
   this.reshape(left, top, right, bottom);
   return this;
}//~Rect()

function delay(ms) {
   var t= new Date();
   var t1= t.getTime();
   do {
      t= new Date();
      var t2= t.getTime();
   }while((t2- t1)< ms);
   return (t2- t1);
}
window.delay= delay;

function Timer(OnTimer, period, time_frame, commence, OnStart, OnStop) {
   if( // [IE-bug fix]
      (typeof(this.toString)== 'unknown')||
      (typeof(this.toString)== 'object')||
      (typeof(this.constructor)== 'undefined')
     ) {
      var args= '';
      if(arguments.length> 0) args= 'arguments[0]';
      for(var i= 1; i< arguments.length; i++) {
         args+= ', arguments['+ i+ ']';
      }
      return eval('new arguments.callee('+ args+ ')');
   }//~[IE-bug fix]

        if(typeof(OnTimer)!= 'function') {
                this.OnTimer= new Function(OnTimer);
        }else {
                this.OnTimer= OnTimer;
        }
        this.period= parseInt(period);
        this.time_frame= parseInt(time_frame);
        this.OnStart= new Function(OnStart);
        this.OnStop= new Function (OnStop);
        if(isNaN(this.period)) this.period= 1;
        function valueOf() {return this.ID};
        function toString() {return this.thread.toString()};
        function start(period, time_frame) {
                if(this.ID) this.stop();
                if(typeof(period)== "number") this.period= period;
                if(typeof(time_frame)== "number") this.time_frame= time_frame;
                var e;
                try { this.OnStart()} catch(e) {};
                this.ID= setInterval(this.OnTimer, this.period);
                syscall('timers')[this.ID]= this;
                if(this.time_frame) schedule("syscall('timers')["+ this.ID+ "].stop()", this.time_frame);
        }
        function stop() {
                if(this.ID) {
                        var e;
                        try{ clearInterval(this.ID);} catch(e) {};
                        delete syscall('timers')[this.ID];
                        this.ID= undefined;
                        try { this.OnStop()} catch(e) {};
                };
        };
        this.valueOf= valueOf;
        this.toString= toString;
        this.start= start;
        this.stop= stop;
        if(commence=== true) this.start();
}//~Timer()

function schedule(thread, delay) {
  if(arguments.length== 1) delay= 0;
  var hThread= new Handle;
  if(typeof(thread)== 'string') thread= new Function(thread);
  hThread.entity= setTimeout(thread, delay);
  return hThread;
}

function unschedule(hThread) {clearTimeout(hThread);}

function isHandle(h) {
  if(h!= null)
    return ((typeof(h)== 'object')&& (h.constructor== Handle))? true: false;
  return false;
}

function MessageBox(msg, title, type) {
  var s= syscall('shell');
  if(isNull(s)) alert(msg);
  return s.MessageBox(msg, title, type);
}

function WinExec(strCmd, bWait, mode) {
   /*
      hProcess= WinExec("notepad.exe");
      if(confirm("Close notepad?")) hProcess.Terminate();
   */
  var s= syscall('shell');
  if(isNull(s)) return null;
  return s.WinExec(strCmd, bWait, mode);
}

function system(strCmd) {
  var s= new Shell;
  if(isNull(s)) return null;
  return s.WinExec(strCmd, true);
}

function shutdown(seconds) { // System Shutdown (Abort: "shutdown(false)")
  var s= syscall('shell');
  if(isNull(s)) return null;
  return s.shutdown(seconds);
}

var Errors= new Enum(['Unspecified', 'UnsupportedAction', 'PermissionDenied', 'AccessDenied', 'InvalidSource', 'InvalidTarget', 'InvalidArgument',
       'InvalidReturnValue', 'FileNotFound', 'NotEnougMinerals', 'SpawnMoreOverlords', 'SysInvalidArgument', 'ThreadsNotInitialized', 'ThreadNotFound',
       'NotImplemented', 'UnderConstruction'
       ]);
var ThreadEvents= new Enum(['OnInitialize', 'OnDestroy', 'OnRun', 'OnStop']);
var TaskState= new Enum(["running", "finished", "failed"]);
var TaskMode= new Enum(['Default', 'Normal', 'Minimized', 'Maximized', 'NoFocus', 'Hide'], 0, [5]);
var PopupType= new Enum(["OK","OKCancel", "AbortRetryIgnore", "YesNoCancel", "YesNo", "RetryCancel", "CancelTryagainContinue"]);
var PopupButton= new Enum(["OK", "Cancel", "Abort", "Retry", "Ignore", "Yes", "No", "Tryagain", "Continue"], 1, [8, 9]);
var DriveTypes= new Enum(["Unknown", "Removable", "Fixed", "Network", "CDROM", "RAMDisk"]);
var TListBoxVerb= new Enum(["init", "focus", "insert", "remove", "cancel", "process"]);
var IOmode= Enum(["ForReading", "ForWriting", "ForAppending"], 1, [3, 4, 5, 6, 7]);
var IOformat= Enum(["Default", "Unicode", "Ascii"], -2);
var SplineType= new Enum(['Bezier', 'Cardinal', 'CubicBSpline', 'Hermite']);
var ErrorPrimeFactorization= new Enum(['NotAnInteger', 'LessThanTwo', 'TooLarge']);
var ErrorMath= Enum(['DivisionByZero']);

window.Handle= Handle;
window.Entity= Entity;
window.Stack= Stack;
window.Point= Point;
window.Rect= Rect;
window.delay= delay;
window.Timer= Timer;
window.schedule= schedule;
window.unschedule= unschedule;
window.isHandle= isHandle;
window.MessageBox= MessageBox;
window.WinExec= WinExec;

/*
function TestEntities() {
   var a= new Entity("entity001", "something");
   var b= new Entity("entity002", 13);
   var c= new Entity;
   var d= new Entity;
   d.set(13); d.rename("variable001");
   echo("entities (name, value, type):\n---------\n"+ a+ '\n'+ b+ '\n'+ c, '\n', d);
   echo('\n', d.name, ' (', d.type,')= ', d.value);
}
TestEntities();
*/

/*
function timer_test() {
   window.t= new Timer("print('.')");
   t.start(13);
   new Timer("print('+')", 2500, 15000, true, "alert('timer: OnStart')", "alert('timer: OnStop')");
   schedule("t.stop()", 5000);
   echo(syscall('timers'));
}
//timer_test();
*/
</SCRIPT>
<SCRIPT>
function InitCON1() {
   var CON1= document.getElementById('CON1');
   window.stderr= CON1;
   window.stdout= window.stderr;
   function _terminal_onclick(event) {
           event= bugfix_event(event);
           terminal('blur');
           buffer_visible(undefined, true, true);
           terminal('hide', true);
   }
   function _terminal_onkeypress(event){
                var event= bugfix_event(event);
                if(event.keyCode== VK_ESC) terminal('hide', true);
   }
   CON1.onclick= _terminal_onclick;
   CON1.onkeypress= _terminal_onkeypress;
}
</SCRIPT>
<SCRIPT>
function Memo(bShow) {
   var r= new Registry();
   var memo= r.get('memo');
   if(!isNull(memo)) {
      arguments.callee.memo= memo;
      if(bShow) alert(memo);
      //r.set('memo', memo);
   }
   return memo;
}
</SCRIPT>
<SCRIPT>
var VK_PAGEUP= 0x21;
var VK_PAGEDOWN= 0x22;
var VK_INSERT= 0x2D;
var VK_DELETE= 0x2E;
var VK_HOME= 0x24;
var VK_END= 0x23;

var VK_TILDE= 192;
var VK_ENTER= 13;
var VK_DOWN= 40;
var VK_UP= 38;
var VK_LEFT= 37;
var VK_RIGHT= 39;
var VK_ESC= 27;
var VK_SPACE= 32;
var VK_TAB= 9; // KeyboardBind(VK_TAB,test_VK_TAB_key);
var VK_F1= 112;
var VK_F2= 113;
var VK_F3= 114;
var VK_F4= 115;
var VK_F5= 116;
var VK_F6= 117;
var VK_F7= 118;
var VK_F8= 119;
var VK_F9= 120;
var VK_F10= 121;// KeyboardBind(VK_F10, VK_F10_OnEvent);
var VK_F11= 122;
var VK_F12= 123;

var VK_SHIFT= 16;
var VK_CTRL= 17;
var VK_ALT= 18;

var VK_0= 48;
var VK_1= 49;
var VK_2= 50;
var VK_3= 51;
var VK_4= 52;
var VK_5= 53;
var VK_6= 54;
var VK_7= 55;
var VK_8= 56;
var VK_9= 57;

var VK_A= 65;
var VK_B= 66;
var VK_C= 67;
var VK_D= 68;
var VK_E= 69;
var VK_F= 70;
var VK_G= 71;
var VK_H= 72;
var VK_I= 73;
var VK_J= 74;
var VK_K= 75;
var VK_L= 76;
var VK_M= 77;
var VK_N= 78;
var VK_O= 79;// KeyboardBind(VK_O, VK_O_OnEvent);
var VK_P= 80;
var VK_Q= 81;
var VK_R= 82;
var VK_S= 83;
var VK_T= 84;
var VK_U= 85;
var VK_V= 86;
var VK_W= 87;
var VK_X= 88;
var VK_Y= 89;
var VK_Z= 90;

function InitCALC1() {
   var CALC1= document.getElementById('CALC1');
   var calc1_output= document.getElementById('calc1_output');
   CALC1.h_index= new Number(0);
   CALC1.h_max= new Number(4096); //big enough(?)
   CALC1.history= new Array(CALC1.h_max);
   CALC1.history[CALC1.h_index]= new String("");
   calc1_output.background= '#EEFFEE';
   calc1_output.color= 'blue';
}

function lineout(background, color, text) { // UNDER CONSTRUCTION
  var calc1_output= document.getElementById('calc1_output');
  function IE6_lineout(background, color, text) {
    calc1_output.insertAdjacentHTML("AfterBegin", "<pre id=eval_lines style=\"background:'"+background+"';color:'"+color+"';\">"+/*text*/+"</pre>");
    eval_lines[0].innerText= text;
    eval_lines[0].style.cssText= 'font-family: courier; font-size: 13px; background-color: '+ background+ '; color: '+ color;//[GC28] bug-fix
  }
  function FF2_lineout(background, color, text) {// [UNDER CONSTRUCTION]
    var calc1_output= document.getElementById('calc1_output');
    var obj= document.createElement('DIV');
    obj.setAttribute('id', 'eval_lines');
    //obj.style.cssText= 'font-family:courier; font-size: 13px; background-color: '+ background+ '; color: '+ color;
    obj.style.cssText= 'font-family:LiberationMono; font-size: 13px; background-color: '+ background+ '; color: '+ color;//[FF]bug-fix
    //obj.style.fontSize= '13px'; obj.style.backgroundColor= background;  obj.style.color= color;
    if(isGoogleChrome()) {
      obj.style.fontFamily="courier";// [GC28] bug-fix
    }

    //background= 'yellow';    color='red';//dbg
    //obj.setAttribute('style', 'background-color:"'+ background+ '";color:"'+ color+ '";'); // expected color but found #007777 ? (hmm...)

    obj.innerHTML= 'BUG'; // [FF2] bug-fix (create a text node)
    obj.firstChild.nodeValue= text;

    if(calc1_output.hasChildNodes()) {
      calc1_output.insertBefore(obj, calc1_output.firstChild);
      //calc1_output.insertBefore(obj.cloneNode(obj), calc1_output.firstChild); //dbg
    }else {
          panic('lineout: appendChild');//dbg
      calc1_output.appendChild(obj);
    }
  }//~FF2_lineout()
  /*//BUG:[FF9]
  if(typeof(calc1_output.insertAdjacentHTML)!= 'undefined') {
    return IE6_lineout(background, color, text);
  }else
    return FF2_lineout(background, color, text);
  */
  var e;
  try {
    if(isGoogleChrome) return FF2_lineout(background, color, text);
    return IE6_lineout(background, color, text);
  }catch(e) {//BUGFIX:[FF9] :)
	var new_element= document.getElementById("eval_lines");
	DOM_remove(new_element);
    return FF2_lineout(background, color, text);
  }
}//~lineout()


function output(str) {
  var calc1_output= document.getElementById('calc1_output');
  if(calc1_output.background== 'white'){
    calc1_output.background= '#eeffee';//'aliceblue';
  }else{
    calc1_output.background= 'white'; //
  }
  lineout(calc1_output.background, calc1_output.color, str);
}
function clear() // use: 'cls'
{
  var calc1_output= document.getElementById('calc1_output');
  calc1_output.innerHTML= "<PRE ID=eval_lines></PRE>"; // [FF2][IE6] (PRE, SAMP: :) )
  //calc1_output.outerHTML= calc1_output.outerHTML;
  lineout('#EEFFEE', '#007777', "enter expression to compute");
}
function Calc_OnKeyDown(event) {
  event= bugfix_event(event);
  var CALC1= document.getElementById('CALC1');
  var kbd= event.keyCode;
  if(kbd== VK_ESC) if(CALC1.value!="") CALC1.value= ' ';
}
function Calc_OnKeyUp(event) {
  event= bugfix_event(event);
  function Calc_prolog() {
    //echo('Calc_OnKeyUp:');//dbg
  }
  function Calc_epilog() {
        //echo('Calc_OnKeyUp.');//dbg
  }
  Calc_prolog();
  Compute(event, Calc_epilog);//Calc_main
  Calc_epilog();
}
function Compute(event) {
  if(arguments.callee.bBugfixIE6== undefined) arguments.callee.bBugfixIE6= window.bBugfixErrorhandler;
  var kbd= event.keyCode;
  var CALC1= document.getElementById('CALC1');
  if(typeof(arguments.callee.functions)== 'undefined') {
    arguments.callee.functions=
    [
       ['clear', clear],
       ['cls', clear],
       ['?', help],
       ['help', help],
       [':', shell], // ':[<shell_command>]' eg.(':winamp')
       ['shell', shell],
       ['quit', close],
       ['exit', close],
       ['reload', reload],
       ['switch', toggle],
       ['toggle', toggle],
       ['edit', edit],
       ['view', view],
       ['menu', menu],
       ['chess', chess],
       ['controlpanel', controlpanel],
       ['memo', 'Memo(true)'],
       ['fullscreen', fullscreen]
    ];
  }
  function Compute_prolog(rewind) {
    var CALC1= document.getElementById('CALC1');
    var h_len= (CALC1.history.length< CALC1.h_max)? (CALC1.history.length): CALC1.h_max;
    CALC1.h_index= new Number(h_len);
    CALC1.history[CALC1.h_index]= expression;
    Compute_epilog.rewind= rewind;
  }
  function Compute_epilog(bError) {//(failsafe)
      var CALC1= document.getElementById('CALC1');
      CALC1.value= "";
          var rewind= arguments.callee.rewind;
          if(bError) if(rewind) rewind(bError);
  }
  function debug(str) {
    var calc1_output= document.getElementById('calc1_output');
    calc1_output.innerText= str;
  }
  function process(expression, rewind) {
         var result, prev, bError;
    function _prolog() {
      result= expression+ " = ";
      prev= window.onerror;
      bError= false;
      //echo('BP: (_prolog)');//DBG
      window.onerror= error_trap;
        }
    function _epilog(rewind, bError) { //(failsafe) rebuild original code structure
      window.onerror= prev;
      //'Calc_OnKeyUp:' 'BP:(failsafe)' 'Calc_OnKeyUp.'
      //if(bError) echo('BP:(failsafe)')//DBG
      if(!bError) {
         output(result);
      }else {
         if(Compute.bBugfixIE6) {
           var e= GetLastError();//a lost tempo?
           var msg= e[0];
           result= "< Error in [ "+expression+" ]: "+ msg+ " >";
           lineout('papayawhip', 'red', result);
         }
      }
      if(rewind) rewind(bError);
    }
    function _code_wrapper() {
      result+= eval(expression); // (user-mode) wild code (error prone)
    }
    function error_trap(msg, url, line) {
      if(!bError) {
         bError= true;
         var e= [msg, url, line, get_call_stack(arguments.callee), expression];
         e[3][e[3].length]= _code_wrapper;
         SetLastError(e);
         if(!Compute.bBugfixIE6) {
           var msg= e[0];
           result= "< Error in [ "+expression+" ]: "+ msg+ " >";
           lineout('papayawhip', 'red', result);
           window.onerror= prev;
         }
      } else {//BUGFIX:[IE6]
               //more info on error..
               //echo([msg, url, line, get_call_stack(arguments.callee)]);//dbg
         //(failsafe) found a new exit point
         //Compute.bBugfixIE6= true;
         _epilog(rewind, true);
      }
      return true;
    }
     _prolog();
     _code_wrapper();
     //(failsafe) this might be a dead end (won't get here after an error)
     _epilog(rewind);
  }//~process()
  function parse(cmd) { // parse shell command
        cmd= trim(cmd);
        if(cmd.charAt(0)== ':') {
        cmd= cmd.substr(1);
        shell(cmd);
        return true;
     }
     return false;
  }
  function shell(cmd) {
      var STR_DEFAULT= 'cmd.exe';
      var STR_DEFAULT_PATCH= STR_DEFAULT+ ' /C start';
      var _shell_path= "HKEY_CURRENT_USER\\Software\\_shell_\\";
      var szCmd;
      var r= new Registry();
      r.root(_shell_path);
      szCmd= r.get();
      if(szCmd== STR_DEFAULT) szCmd= STR_DEFAULT_PATCH;
      if(isNull(szCmd)|| (szCmd== "")) {
         szCmd= prompt("Enter shell path:", STR_DEFAULT);
         r.set(szCmd);
      }
      //WScript_shell.Terminate();
      if(arguments.length== 1) szCmd+= ' '+ cmd;
      window.WScript_shell= WinExec(szCmd);
  }
  function chess() {
     var REG_KEY= 'chess';
     var PROMPT_STR= REG_KEY+ '\nEnter Path';
     var CONFIRM_STR= 'File not found!\nTry again?';
     var r= new Registry();
     var path= r.get(REG_KEY);
     var bRetry= false;
     if(!file_exists(path)) {
        do {
           path= prompt(PROMPT_STR, path);
           if(isNull(path)) break; // user lost interest
           if(file_exists(path)) {
              r.set(REG_KEY, path);
              bRetry= false;
           }else {
              bRetry= confirm(CONFIRM_STR)
           }
        } while(bRetry);
     }
     if(window.hChess)
        window.hChess.Terminate();
     window.hChess= WinExec(r.get(REG_KEY));
  }
  function controlpanel() {
    //var steps= 13; // hmm..
    //while(steps--) {
    //  window.hOSControlPanel= WinExec("rundll32.exe shell32.dll,SHRunControlPanel 0");
    //  if(isEmpty(window.hOSControlPanel))
    //    if(!window.hOSControlPanel.status) steps= 0;
    //}
    window.hOSControlPanel= WinExec("rundll32 shell32.dll,Control_RunDLL");
  }
  function reload() {if(typeof(window.OnReload)== 'function') window.OnReload();}
  function close() {if(typeof(window.OnClose)== 'function') window.OnClose();}
  function edit() {if(typeof(window.OnEdit)== 'function') window.OnEdit();}
  function view() {if(typeof(window.OnView)== 'function') window.OnView();}
  function menu() {if(typeof(window.OnMenu)== 'function') window.OnMenu();}
  var expression= CALC1.value;
  switch(kbd){
  case VK_ENTER:
    {
    if(expression.length!=0)
    {
      var d= arguments.callee.functions;
      var bUserCmd= false;
      for(var i= 0; i< d.length; i++) {
         if(d[i][0]== expression) {
            bUserCmd= true;
            switch(typeof(d[i][1])) {
               case 'function':
                  (d[i][1])();
               break;
               case 'string':
                  eval(d[i][1]);
               break;
               default:
                  // ...give the user a chance to write some code for it...
               break;
            }
            break; //~for
         }
      }
      if(!bUserCmd) {
        Compute_prolog(arguments[1]);
        if(!parse(expression))
           process(expression, Compute_epilog);
      }
      Compute_epilog();
    }else{}
    }
  break;
  case VK_DOWN:
    if(CALC1.h_index<CALC1.history.length- 1) CALC1.h_index++;
    CALC1.value= CALC1.history[CALC1.h_index];
    //output("h_index:"+CALC1.h_index+"\nhistory.length:"+CALC1.history.length);
  break;
  case VK_UP:
    if(CALC1.h_index>0) CALC1.h_index--;
    CALC1.value= CALC1.history[CALC1.h_index+1];
    //output("h_index:"+CALC1.h_index+"\nhistory.length:"+CALC1.history.length);
  break;
  case VK_ESC:
    if(CALC1.value!=""){
      CALC1.value="";
    }else{
      //lineout('gray','white', "Press Ctrl + ~ (tilde); or close() to switch/exit.");
      toggle();
    }
  break;
  default:
     //alert(kbd);
  break;
  }
}//~Compute()
</SCRIPT>
<SCRIPT>

function isDialog() {return (window.dialogLeft== undefined)? false:true;}

function GetViewportRect() {
  var obj= document.body;
  if(typeof obj.scrollLeft== 'number')
    return new Rect(
      obj.scrollLeft, obj.scrollTop,
      obj.scrollWidth, obj.scrollHeight
    );
  else return null;
}

function GetClientRect(obj) {
  var r;
  ////var r= document.body.getClientRects()[0]; // ??
  ////return new Rect(r.left, r.top, r.right, r.bottom);
  if(obj=== window.document.body) arguments.length= 0;
  if(arguments.length) {
    var width, height,  left, top, right, bottom;
    width= obj.offsetWidth;
    height= obj.offsetHeight;
    left= 0;
    top= 0;
    do {
      if(obj.offsetTop!== undefined) {
        left+= obj.offsetLeft;
        top+= obj.offsetTop;
      }
      obj= obj.parentNode;
    } while(obj!== null);
    right= left+ width;
    bottom= top+ height;
    r= DOM_getRect(obj);
    r.left= left;
    r.top= top;
    r.right= right;
    r.bottom= bottom;
  }else {//"win32.GetClientRect(hWnd)"
    obj= window.document.body;
    r= DOM_getRect(obj);
    var attr, v;
    attr= "position:absolute;top:100%;left:100%;width:1px;height:1px;visibility:hidden";
    r.left= obj.offsetLeft;
    r.top= obj.offsetTop;
    obj= DOM_new('DIV', attr);
    DOM_add(document.body, obj);
    DOM_setStyle(obj, attr);
    r.right= ((obj.offsetLeft)? (obj.offsetLeft- 1): 0);
    r.bottom= ((obj.offsetTop)? (obj.offsetTop- 1): 0);
    DOM_remove(obj);
  }
  return r; //putpixel(r.right- 1, r.bottom- 1, 'red');
}//~GetClientRect()

function GetWindowRect() {
 //  if(window.isDialog()) {
      var r= new Rect(window.dialogWidth, window.dialogHeight);
      r.translate(window.dialogLeft, window.dialogTop);
 // }else {
 //    alert("NotImplemented.");
 // }
  return r;
}

function GetMousePos() {// some [IE6] specific [UNDER CONSTRUCTION]
   var x, y, e, peh= [];
 function _local_event_handler(event) {
   event= bugfix_event(event);
   x= event.x;
   y= event.y;
   if(event.cancelBubble) event.cancelBubble();
   return true;
 }
 function _set_event_handler() {
   peh[0]= e.attributes['onclick'].value;
   peh[1]= e.getAttribute('onclick');
   peh[2]= e.onclick;
   e.attributes['onclick'].value= _local_event_handler;
   e.setAttribute('onclick', _local_event_handler);
   e.onclick= _local_event_handler;
 }
 function _remove_event_handler() {
   e.onclick= peh[2];
   e.setAttribute('onclick', peh[1]);
   e.attributes['onclick'].value= peh[0];
 }
   e= document.documentElement;
   if(e.click) {
      _set_event_handler();
      e.click(); // [FF2] BUG
      _remove_event_handler();
   }else { // [FF2]
      if(window.mouse) { // hmm..
         x= window.mouse.x;
         y= window.mouse.y;
      }
   }
   return [x, y];
}//~GetMousePos()

function MoveWindow(x, y, width, height) {
   if(window.dialogTop== undefined) {
      window.moveTo(x, y);
      window.resizeTo(width, height);
   }else {
      window.dialogLeft= x+ "px";
      window.dialogTop= y+ "px";
      window.dialogWidth= width+ "px";
      window.dialogHeight= height+ "px";
   }
}

function GetImageRect(url) {//bug:asynchronous
  var img, r;
  img= new Image();
  url= escape(unescape(url));
  img.src= url;
  //while(!img.complete) new Date();//BUG!
  {
  //img.style.backgroundImage= 'url('+ url+ ')';
  //img.style.visibility= 'hidden';//'visible';//'hidden'
  //window.document.body.appendChild(img);
  //window.document.body.removeChild(img);
  }
  if(!img.complete) return null;//Job not finished! (Retry later!)
  r= new Rect(0, 0, img.width, img.height);
  r.width= width;
  r.height= height;
  return r;
}//~GetImageRect()

function fullscreen() {
   var r= new Rect();
   r.left= 0;
   r.top= 0;
   r.right= window.screen.width;
   r.bottom= window.screen.height;
   for(var i= 0; i< 2; i++) {
      window.MoveWindow(-r.left, -r.top, r.right+ r.left, r.bottom+ r.top);
      r.left= window.screenLeft;
      r.top= window.screenTop;
   }
}

function SetWallpaper(image, color) { // SetWallpaper("Background.jpg", "black");
   var e; try {
      document.body.style.backgroundColor= trim(color);
   } catch(e) {
      document.body.style.backgroundColor= "transparent";
   }
   return document.body.style.background= " "+ document.body.style.backgroundColor+ " url("+ escape(image)+ ") fixed no-repeat ";
}

function panic(msg) {
   var e;
   try{
       unschedule(window.Panic.user.prorogation);
       window.Panic.Close();
   }catch(e){};
   var left= 0;
   var top= 0;
   var width= '100%';
   var height= 13;
   var hwnd= CreateWindow(null, left, top, width, height, "red", "white", msg, true);
   hwnd.ondblclick= new Function("this.Close()");
   window.Panic= hwnd;
   window.Panic.user.prorogation=  schedule("{var e; try{window.Panic.Close()} catch(e){}}", 3000);
}
function errortrap(msg,url,line){
    //alert('Error: '+msg+'\nLine: '+line+'\nUrl: '+url);
    SetLastError([msg, url, line, get_call_stack(arguments.callee)]);
    if(!Bool1){
       panic('(Line: '+line+') Error: '+msg);
    }else{
       var but2= document.getElementById('but2');
       echo("\n< error: "+msg+" >");
       arStatus[0]= arStatus[2];
       Bool1= (0> 1);
       but2.blur();
       (buffer_visible())? buffer_focus(): terminal('focus');
    }
    return true;
}

function OnLoad(){
  window.onerror= errortrap;
  if(window.bBugfixErrorhandler== undefined) {//BUGFIX:[IE6]
    schedule(arguments.callee);
    bugfix0003();
  }
  //throw("bp002");
  //alert("window.document.readyState: "+ window.document.readyState);//'complete'//dbg
  schedule('main()');//main();
}//~OnLoad()

function OnClose(){
 window.Timer1.stop();
 var CON1= document.getElementById('CON1');
 if(CON1.value != "") returnValue= CON1.value.toString();
 try{
	if(!window.external) window.close();
    window.external.close();
 }catch(e) {
   try{
     if(!(window.external.toString().search('xpconnect')>= 0)) {//BUGFIX-FF19: Get rid of warning: ""
       window.close();
     }
   }catch(e){};
 }
 //new_window.close();
// return true;//no unload I guess;
}//~OnClose()

function OnReload() {syscall('reload');}
function OnEdit() {Tooltip("OnEdit");}
function OnView() {Tooltip("OnView");}
function OnMenu() {Tooltip("OnMenu");}

window.panic= panic;
window.OnReload= OnReload;
window.OnEdit= OnEdit;
window.OnView= OnView;
window.OnMenu= OnMenu;
window.OnClose= OnClose;

function fooTimer1(){
   //var t=document.title;  t=t.substring(1,t.length)+t.substring(0,1); document.title=t;
   var d=new Date();
   var s=ZileDinSaptamana[d.getDay()]+"             ";
   s+=Math.floor(d.getHours()/10)+""+(d.getHours()%10)+":";
   s+=Math.floor(d.getMinutes()/10)+""+(d.getMinutes()%10)+":";
   s+=Math.floor(d.getSeconds()/10)+""+(d.getSeconds()%10);
   //s+=":"+d.getMilliseconds();
   s+="             "+d.getDate()+"/";
   s+=LuniDinAn[d.getMonth()]+"/";
   s+=d.getUTCFullYear();
   document.title=s+"             ";
   if(typeof(new_window)== 'undefined') new_window= 0;
   if(!typeof(new_window)== 'null')//if(new_window)
     if(!typeof(new_window.closed)== 'undefined')
       if(!typeof(new_window.closed)== 'unknown'){}else{};
   window.status= arStatus[0];
}
</SCRIPT><SCRIPT>

function terminal(cmd, opt) {
        cmd= trim(cmd);
        var b= buffer_buffers();
        var index= buffer_active();
        var t;
        if(b.terminal) t= b.terminal[index];
        switch(cmd) {
                case 'print':
                case 'echo': {
                //      if(typeof(opt)== 'undefined') { // dbg
// "recurrent call stack: [terminal(cmd, opt), _job(), _defer(),
// thread_OnRun(_this, lParam), run(lParam), wake(bStop)] ?"
                //              var n, cs= get_call_stack(arguments.callee, 1000, true);
                //              n= cs.length;
                //              t.value+= 'CALL STACK: ('+ n+ ') [\n'+ cs.join('\n')+ '\n]';
                //      }//dbg
                        t.value+= opt;
                        return opt;
                break;}
                case 'cls': {
                        t.value= '';
                        var th= thread('terminal print');
                        if(!isNull(th)) {
                                th.jobs(true);
                                th.user.reset(th.user);
                        }
                break;}
                case 'show': {
                        var bFocus= cmd;
                        t.style.visibility= 'visible';
                        if(bFocus&& (!isEmpty(t.focus))) t.focus();
                        buffer_visible(index, false);
                break;}
                case 'focus': {
                        if(t.style.visibility== 'visible')
                           if(!isEmpty(t.focus)) {
                                t.focus(); return true;
                           }
                        return false;
                break;}
                case 'hide': {
                        var bFocus= cmd;
                        buffer_visible(index, true, bFocus);
                        t.style.visibility= 'hidden';
                break;}
                case 'toggle': {
                        (buffer_visible())? terminal('show', true): terminal('hide', true);
                break;}
                case 'blur': {
                        if(!isEmpty(t.blur)) {
                                t.blur(); return true;
                        }
                        return false;
                break;}
                case 'dump': {
                        var th= thread('terminal print');
                        if(!isNull(th)) {
                                th.user.reset(th.user);
                                th.wake();
                        }
                        return t.value;
                break;}
                case 'status': {
                        opt= trim(opt);
                        switch(opt){
                                case 'visibility': {
                                        return t.style.visibility;
                                break;}
                                default: {
                                        return 'available';
                                break;}
                        }
                break;}
                case 'wrap': {
                        if(opt== true) opt= 'soft';
                        else if(opt== false) opt= 'off';
                        opt= trim(opt);
                        switch(opt) {
                                //case 'virtual': // word-wrapping
                                case 'off':
                                case 'physical':
                                case 'soft':
                                   try {t.wrap= opt;}catch(undefined){};
                        };
                break;}
                case 'initialize': {
                        function terminal_initialize_thread() {
                          function thread_OnInit(_this, lParam) {
                                function reset(_) {
                                        _.timestamp_last= 0;
                                }
                            var _= _this.user;
                            _.delay= lParam; // "250: update approx. 4 times per second"
                            _.reset= reset;
                            _.reset(_);
                          }
                          function thread_OnRun(_this, lParam) {
                            function _job() {return terminal("print", lParam);}
                            function _defer() {
                              if(_.timestamp_last) {
                                var t= _.timestamp_run- _.timestamp_last;
                                if(t>= _.delay) {
                                  _.timestamp_last= _.timestamp_run; // reset
                                      return _job();
                                }
                                else return _this.reschedule(_.delay- t, true, lParam);
                              }else {
                                _.timestamp_last= _.timestamp_run; // reset
                                return _job();
                              }
                            }
                            var _= _this.user;
                            if(arguments.length!= 2) return undefined; // (hmm.. "recurrent call stack?")
                            _.timestamp_run= syscall('timestamp');
                            if(isArray(lParam)) lParam= lParam.join('');
                            if(_.delay) return _defer();
                            else  return _job();
                          }
                          function thread_OnDestroy(_this, lParam) {}
                          function thread_OnStop(_this, lParam) {}
                          var thread_events= [];
                          thread_events[ThreadEvents.OnInitialize]= thread_OnInit;
                          thread_events[ThreadEvents.OnDestroy]= thread_OnDestroy;
                          thread_events[ThreadEvents.OnRun]= thread_OnRun;
                          thread_events[ThreadEvents.OnStop]= thread_OnStop;
                          var t= thread_new('terminal print', thread_events, 250);
                        }//~terminal_initialize_thread()

                        terminal_initialize_thread();
                        b.terminal= new Array(opt[0]);
                        for(var i= 0; i< opt[0]; i++) {
                                b.terminal[i]= opt[1];
                        }
                break;}
                default: break;
    }
}//~terminal()


//function print(/* ... */) {
//   for(var i= 0; i< arguments.length; i++) {
//      terminal('print', arguments[i]);
//   }
//}


function print(/* ... */) {
   var t, msg, t_name;
   t_name= 'terminal print';
   t= thread(t_name);
   if(isEmpty(t)) {
      SetLastError(['print: Thread not found! (' + t_name+ ')',
          Errors.ThreadNotFound, get_call_stack(arguments.callee)]);
      return false;
   }
   msg= '';
   for(var i= 0; i< arguments.length; i++) {
      msg+= arguments[i]; // terminal('print', arguments[i]);
   }
   return t.job(msg);
}

function echo(/* ... */) {
   for(var i= 0; i< arguments.length; i++) {
      print(echo.arguments[i]);
   }
   print('\n');
}

window.println= echo;
window.writeln= echo;
</SCRIPT><SCRIPT>
/*
function but1_onclick(event){
   event= bugfix_event(event);
   var aux=new String(typeof(new_window.closed));
   arStatus[0]=arStatus[1];
   //if(aux!='undefined' && aux!='unknown'){ new_window.close();}
   new_window= window.open(_URL,_name,_features.substring(0,_features.length));
   new_window.document.open();
   new_window.document.write(textarea.value);
   new_window.document.close();
   new_window.focus();
   //window.blur();
   arStatus[0]=arStatus[2];
}
function but1_onclick() {
   var r= new Rect(100, 100, 320, 240);
   var hwnd= CreateWindow(null, r.left, r.top, r.right, r.bottom, "white", "black");
   hwnd.innerHTML= textarea.value;
   hwnd.ondblclick= hwnd.CloseWindow;
   hwnd.ShowWindow(true);
};
*/

function but1_onclick(event) {
   event= bugfix_event(event);
   var index= buffer_active();
   if(buffer_visible(index)) {
     buffer_refresh(index, true);
     var szFrm= "<IFRAME ID=ihtml SRC='about:blank' WIDTH=100% HEIGHT=100% MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no BORDERCOLOR='#000000'></IFRAME>";
     var d= document.getElementById('ihtml');
     var r= new Rect(100, 100, 320, 240);
     var hwnd= CreateWindow(null, r.left, r.top, r.right, r.bottom, "white", "black");
     hwnd.innerHTML= szFrm;
     var d= document.getElementById('ihtml');
     if(d!= null) {
       d.hwnd= hwnd;
       d.src= 'about:'+ buffer_get(index);
     }
     hwnd.ondblclick= hwnd.CloseWindow;
     hwnd.ShowWindow(true);
   }
}

function but2_onclick(event){
   event= bugfix_event(event);
   var index= buffer_active();
   if(terminal('status', 'visibility')== 'hidden') buffer_refresh(index, true);
   if(_strlen(buffer_get(index))){
      Bool1=(1>0); arStatus[0]=arStatus[1];
      terminal('cls');
      terminal('show', true);
      buffer_ramdrive_save(index);
      buffer_eval(index); //execScript(textarea.value,language); //execScript(textarea.value, "JavaScript");
      if(!_strlen(terminal('dump'))) terminal('hide', true);
      arStatus[0]=arStatus[2]; Bool1=(0>1);
   }
   event.target.blur();
   buffer_focus();
}

function but3_onclick(event){
  event= bugfix_event(event);
  var index= buffer_active();
  buffer_refresh(index, true);
  help();
  if(!buffer_focus()) terminal('focus');
}
function but4_onclick(event){
  event= bugfix_event(event);
  toggle();
}

function but5_onclick(event){
  event= bugfix_event(event);
  var index= buffer_active();
  if(buffer_visible(index)) {
    buffer_refresh(index, true);
    var filename= buffer_get_filename(index);
    if(!_strlen(filename)) {
      filename= buffer_get_filename(index, true);
    }
    filename= prompt("Open text/html file:", filename);
    if(_strlen(filename)) buffer_load(index, filename);
    buffer_visible(index, true, true);
  }
}//~but5_onclick()

function but6_onclick(event) {
  event= bugfix_event(event);
  var index= buffer_active();
  if(buffer_visible(index)) {
    buffer_refresh(index, true);
    var filename= buffer_get_filename(index);
    if(!_strlen(filename)) {
      filename= buffer_get_filename(index, true);
    }
    var new_filename= prompt("Save text/html file:", filename);
    if(_strlen(new_filename)) {
      var s, bSave;
      bSave= true;
      s= syscall('shell');
      if(!isNull(s)&& !s.isRamdisk(new_filename, true))
        bSave= confirm("Save file?\n"+ new_filename);
      if(bSave) buffer_saveas(index, new_filename, true);
    }
    buffer_visible(index, true, true);
  }
}//~but6_onclick()
</SCRIPT><SCRIPT>
function bugfix_event(event) {//[IE6] [FF2] bug-fix
  if(window.event) {//[IE6]
    event= window.event;
    event.target= event.srcElement;//[FF2]
  }
  if(!isEmpty(event))
    if(typeof(event.srcElement)== 'undefined') {//[FF2]
      //MouseEvent.prototype.__defineGetter__("srcElement", function() {return this.target;});
      //KeyboardEvent.prototype.__defineGetter__("srcElement", function() {return this.target;});
      Event.prototype.__defineGetter__("srcElement", function() {return this.target;});
    }
  return event;
}
function butOnMouseOver(event) {
  event= bugfix_event(event);
  var el, txt;
  var el= event.srcElement;
  el.setAttribute('a', el.innerHTML, true);
  if(el.name) txt= el.name;
  else
    if(el.innerText) //[IE6] (specific)
      txt= el.innerText;
    else // [FF2] bug
      txt= undefined; // UNDER CONSTRUCTION
  if(typeof txt== 'string')
    el.innerHTML= "<FONT FACE='Verdana' SIZE=2 STYLE='color:white'><B><I>"+ txt+ "</I></B></FONT>";
}
function butOnMouseOut(event) {
  event= bugfix_event(event);
  var el= event.srcElement;
  var atr= el.getAttribute('a', 2);
  if(atr!= null) el.innerHTML= atr;
}
function butOnMouseMove(event){
  event= bugfix_event(event);
//document.title="     X="+window.event.x+"Y="+window.event.y+"     ";
//window.status="     X="+window.event.x+"Y="+window.event.y+"     ";
}

function InitButtons(){ // [UNDER CONSTRUCTION]
  var i=new Number(0);
  var obj= document.getElementsByTagName("BUTTON");
  for(i= 0; i<= obj.length- 1; i++) {
    obj.item(i).onmouseover= butOnMouseOver;
    obj.item(i).onmousemove= butOnMouseMove;
    obj.item(i).onmouseout= butOnMouseOut;
    if(obj.item(i).innerText) //[IE6]
      obj.item(i).title= obj.item(i).innerText;
    else // [FF2]
      obj.item(i).title= obj.item(i).name; //hmm..
  }
}//~InitButtons()
function InitKeyboardShortcuts() {
  setKeyFunc(VK_TILDE, toggleOptions);
  for(var i= 1; i<= 12; i++) {
  //function VK_F2_OnEvent() { alert("F2");}
  // setKeyFunc(VK_F2, VK_F2_OnEvent);
  //setKeyFunc(VK_F12, VK_F12_OnEvent);
   var cmd= '';
   if(eval('typeof(VK_F'+ i+ '_OnEvent)')!= 'function')
      cmd= 'function VK_F'+ i+ '_OnEvent() {panic("F'+ i+ '");}\n';
   cmd+= "setKeyFunc(VK_F"+ i+ ", VK_F"+ i+ "_OnEvent);";
   eval(cmd);
  }
}//~InitKeyboardShortcuts()
</SCRIPT>
<SCRIPT>
function bugfix_onclick(obj) {// [IE6] bug-fix
        if(typeof(obj.onclick)!= 'string') return;
        obj.setAttribute('onclick', new Function(obj.getAttribute('onclick')));
}

function InitButtonOptions(){
  n= doc.getElementsByTagName("BUTTON").length;
  for(i= 0; i< n; i++) {
    obj= doc.getElementsByTagName("BUTTON")[i];
    obj._OnClick= obj.onclick;
    obj.setAttribute('onclick', 'butClick(event)'); //obj.onclick= butClick;
    bugfix_onclick(obj);
  }
}
function butClick(event){
  event= bugfix_event(event);
  if(event.ctrlKey){
    butCtrlClick(event);    return;
  }
  if(event.shiftKey){
    butShiftClick(event);    return;
  }
  //if(event.altKey){
  //  butAltClick(event);    return;
  //}
  if(isFunction(event.srcElement._OnClick))
    event.srcElement._OnClick(event);
}
//function butAltClick(event){
//  alert("Under construction");
//}

function butShiftClick(event) {
  var obj= event.srcElement;
  var str= "["+ obj.tagName+ " id= "+ obj.id+ "]\n";
  str+= obj.id+ "._OnClick=\n"+ obj._OnClick;
  alert(str);
}

function butCtrlClick(event) {
  var obj= event.srcElement;
  var textarea= document.getElementById('textarea');
  var str= "//["+ obj.tagName+ " id= "+ obj.id+ "]\n//";
  str+= obj.id+ "._OnClick=\n"+ obj._OnClick;
  if(textarea.value!= '') {
    obj._OnClick= new Function(textarea.value);
  }else {
    textarea.value= str;
  };
}
</SCRIPT>
<SCRIPT>
function reposit(x, v, p) { // put item [x] in vector [v] at positions [p]
   var n= p.length;
   for(var i= 0; i< n; i++) v[p[i]]= x;
   return v;
}
function locate_all(x, v) { // discover ALL positions of item [x] in vector [v]
   var p= new Array();
   var n= v.length;
   for(var i= 0; i< n; i++) if(v[i]== x) p[p.length]= i;
   return p;
}
function replace_all(a, b, v) { // replace EVERY occurence of item [a], with item [b], in vector [v]
   return reposit(b, v, locate_all(a, v));
}
function locate(x, v) { // discover the FIRST position of item [x] in vector [v]
   var p= new Array();
   var n= v.length;
   for(var i= 0; i< n; i++) if(v[i]== x) return [i];
   return [];
}
function replace(a, b, v) { // replace the FIRST occurence of item [a], with item [b], in vector [v]
   return reposit(b, v, locate(a, v));
}
function search(x, a) { // return the index of item [x] in vector [a] (the FIRST occurence or undefined if none)
   var p= locate(x, a);
   if(p.length== 0) return undefined;
   else return p[0];
}
</SCRIPT>
<SCRIPT>
function foreach(code, lParam/*, bSetLastError, bStopOnError*/) {// for n items v[i] is the current item; local variables: [code, v, i, n, lParam];
  var v, i, n;
  v= this;
  n= this.length;
  for(i= 0; i< n; i++) {
    try {
      eval(code);
    }catch(foreach) {
      if(arguments[2]) {//bSetLastError
        try{SetLastError(['Error: foreach: '+ foreach.description, foreach.number& 0xFFFF, get_call_stack(arguments.callee), [code, v, i, n, lParam]]);}catch(foreach){};
      }
       if(arguments[3]) break;//bStopOnError
     }
  }
  return this; // w= new Array(13); w.foreach('v[i]= lParam++', 13);
}//~foreach()

Array.prototype.foreach= foreach;

function _array_push_unique(x) {// put element "x" in this vector; insert no duplicate values
  var i, n, bUnique;
  n= this.length;
  bUnique= true;
  for(i= 0; i< n; i++) if(this[i]== x) bUnique= false;
  if(bUnique) this.push(x);
  return bUnique;
}//~_array_push_unique()

Array.prototype.push_unique= _array_push_unique;

function _array_unique() {//remove duplicate values from this vector
  return vector_replace_all(this, this, true);
}//~_array_unique()

Array.prototype.unique= _array_unique;


function generate_random_number() {// Calculate pseudo-random 32 bit number based on linear congruential method.
  var DEFAULT_SEED= 22222;// Change this for different random sequences.
  var rand_seed;
  if(isEmpty(arguments.callee.rand_seed)) {
    rand_seed= DEFAULT_SEED;
  } else {
    rand_seed= arguments.callee.rand_seed;
  }
  rand_seed= uint32((rand_seed* 196314165)+ 907633515);
  arguments.callee.rand_seed= rand_seed;
  return uint32(rand_seed>> 8)//% 0x1000000;// a 24bit actually...
}//~generate_random_number()

function _rand(seed) {
   //return ((integer((2.0* random()- 1.0)* 0x100000000, 0xFFFFFFFF)>> 16)& 0xFFFF);
   if(arguments.length) {
     seed= parseInt(seed);
     if(!seed) seed= 0;
   }else {
     seed= arguments.callee.rand_seed;
   }
   if(typeof(seed)!= 'number') seed= 0;
   seed*= 0x343FD;
   seed+= 0x269EC3;
   seed&= 0xFFFFFFFF;
   arguments.callee.rand_seed= seed;
   seed>>=  0x0A; //sar eax, 10
   seed&= 0x7FFF;
   return seed;
}//~_rand()

function rand(seed) {
  if(arguments.length) {
    return ((_rand(seed)<< 16)| _rand());
  }else {
    return ((_rand()<< 16)| _rand());
  }
}//~rand()

function rand(seed) {//a 31-bit random number
   //return integer((2.0* random()- 1.0)* 0x100000000, 0xFFFFFFFF);
   if(arguments.length) {
     seed= parseInt(seed);
     if(!seed) seed= 0;
   }else {
     seed= arguments.callee.rand_seed;
   }
   if(typeof(seed)!= 'number') seed= 0;
   seed= ((seed* 0x41C64E6D)+ 0x3039)& 0x7FFFFFFF;
   arguments.callee.rand_seed= seed;
   return seed;//bug: "(rand()& 0xFF)"
}//~rand()

function Random(lowerbound, upperbound) {//bug: under construction.
  var iRand, dRand, RAND_MAX;
  lowerbound-= 1;
  upperbound+= 1;
  RAND_MAX= 0x7FFF;
  iRand= (rand()>> 10)& 0x7FFF;
  dRand= iRand/ (RAND_MAX+ 1);
  iRand= (((upperbound- lowerbound)* dRand+ lowerbound)& 0xFFFFFFFF);
  iRand= clip(iRand, lowerbound+ 1, upperbound- 1);
  return iRand;
}//~Random()

function _random(min, max) {
    var r= (rand()<< 15)| rand();
    return ((r& 0xFFFFFFF)/ (0xFFFFFFF+ 1))* (max- min)+ min;
}

function random_T() {
  function T(x) {//x in (0.. 1)
    return 4.0* x* (1- x);// for x= 0.5 try 3.99* x* (1- x)
  }
  var seed= arguments.callee.seed;
  if(seed== undefined) {//some seeds are better than others in (0..1) interval
    seed= 0.13;// 0.53; 0.97; // a bad one is .5
  }
  seed= T(seed);
  arguments.callee.seed= seed;
  return seed;
}//~random_T()

/*
function mt_rand(t) {//under construction
  return (rand()% t);
}
*/

function mt_rand(t) {//bug: under construction
  var y, TEMPERING_MASK_B, TEMPERING_MASK_C;
  //Tempering parameters
  TEMPERING_MASK_B= 0x9d2c5680;
  TEMPERING_MASK_C= 0xefc60000;
  t&= 0xFFFF;
  if(!t) t= 0xFFFF;
  if(arguments.callee.next== undefined) {
    next= ((6789* 65536)+ 12345)>>> 0;
  }else {
    next= arguments.callee.next;
  }
  next= rol((0x6C078965* (next^  shr(next, 30))), 1)>>> 0;
  y= next;
  y=  y^ ((y>>> 11)>>> 0);
  y= (y^ ((y<< 7)>>> 0))& TEMPERING_MASK_B;
  y= (y^ (y<< 15)>>> 0)& TEMPERING_MASK_C;
  y=  (y^ ((y>>> 18)>>> 0))>>> 0;
  arguments.callee.next= next++>>> 0;
  return (y% t);
}//~mt_rand()

function random_vector(n, bNatural, bNormalized) { // return [n] random values (Natural: in [0, n] interval; Normalized: include always 0 & n)
   var v= [];
   for(var i= 0; i< n; i++) v[i]= random();
   if(bNatural) {
      if(bNormalized) vector_normalize(v);
      vector_scale(v, n- 1);
      for(var i= 0; i< n; i++) v[i]= round(v[i]);
   }
   return v; // "v= random_vector(2, true); w= random_vector(2, true, true)"
}

function vector_equal(v, w) {
   var n= v.length;
   if(n!= w.length) return false;
   for(var i= 0; i< n; i++) if(v[i]!= w[i]) return false;
   return true;
}

function vector_reverse(v) {
    v.reverse();
    return v;
}

/*
function vector_shuffle(v, bVariant) { // fast and clean :))
   if(!bVariant) {
      var n= mod(rand(), v.length);
      if(n< v.length/ 2) vector_reverse(v);
   }
   return v.sort(new Function('return true;'));//BUG: [FF2]
}
*/

function vector_shuffle(v) {
   var n= v.length- 1;
   for(var i= n; i> 0; i--) {
      var j = Math.floor(Math.random()* (i+ 1));
      var tmp= v[i];
      v[i]= v[j];
      v[j]= tmp;
   }
   return v; //"vector_shuffle(range(13))"
}

function vector_disperse(v, bSimple) {
  if(bSimple) {
    var n= v.length;
    for(var i= 0; i< n>> 1; i+= 2) {
      var t= v[i];
      v[i]= v[i+ n>> 1];
      v[i+ n>> 1]= t;
    }
    return v;
  }
  function _vector_disperse(v, a, b) {
    if((b- a)<= 2) return v;
    var n= b- a+ 1;
    n-= n% 2;
    var m= n>> 1;
    n-= 1;
    var p= m>> 1;
    for(var i= p; i< m; i++) {
      var t= v[a+ i];
      v[a+ i]= v[a+ m+ i];
      v[a+ m+ i]= t;
    }
    var m= (a+ b)>> 1;
    _vector_disperse(v, a, m);
    _vector_disperse(v, m+ 1, b);
    return v;
  }//~vector_disperse._vector_disperse()
  return _vector_disperse(v, 0, v.length- 1);
}//~vector_disperse()

function vector_copy(v) {
   //and now.. some AI for "vector_copy(arguments)":
   // iff (!) efficiency is desirable use (more or less) efficiently some (or every) available
   // means to achieve the specified objective in an efficient (ditto) manner
   if(arguments.length< 1) {//implement functions with C-like variable arguments
     if(arguments.caller&& arguments.caller.length) {//BUG: IE6 SPECIFIC!!
       v= arguments.caller;
     }else
       v= arguments.callee.caller.arguments;//BUG-FIX: FF3: CALLER is defined...
   }
   var n, i, w;
   n= v.length;
   w= [];
   for(i= 0; i< n; i++) w[i]= v[i];
   return w;
}

function vector_replace_all(a, b, bUnique) {//empty vector "a" then fill vector "a" only with elements from vector "b"
  var bIdentical= ((a=== b)? true: false);
  if(bIdentical) {
    if(!bUnique) return a;
    b= vector_copy(b);
  }
  a.length= 0;
  if(bUnique) {
    b.foreach('lParam.push_unique(v[i])', a);
  }else {
    b.foreach('lParam[i]= v[i]', a);
  }
  return a;
}//~vector_replace_all()

function vector_range(v) {
  var i, n, _min, _max;
  n= v.length;
  _min= v[0];
  _max= v[0];
  for(i= 0; i< n; i++) {
     if(_min> v[i]) _min= v[i];
     if(_max< v[i]) _max= v[i];
  }
  return [_min, _max];
}

function vector_translate(v, dist) {
   var i, n;
   n= v.length;
   for(i= 0; i< n; i++) {
      v[i]+= dist;
   }
   return v;
}

function vector_scale(v, ratio) {
   var i, n;
   n= v.length;
   for(i= 0; i< n; i++) {
      v[i]*= ratio;
   }
   return v;
}

function vector_normalize(v) {
   var r= vector_range(v);
   if(r[1]- r[0])
      return vector_scale(vector_translate(v, -r[0]), 1/(r[1]- r[0]))
   else
      return vector_translate(v, -r[0]);
}

/*
function vector_normalize(v) {
  var i, n, t, _min, _max, range;
  range= vector_range(v);
  _min= range[0];
  _max= range[1];
  n= v.length;
  t= _max- _min;
  if(t!= 0) { // translate & scale
     for(i= 0; i< n; i++) {
        v[i]-= _min;
        v[i]/= t;
     }
  }else { // translate
     for(i= 0; i< n; i++) {
        v[i]-= _min;
     }
  }
  return v;
}
*/

function vector_normal2integer(v, scale) {
  vector_scale(v, scale);
  v.foreach('v[i]= integer(v[i], lParam);', scale);
  return v;
}

function vector_normalscale(v, scale) {
  return vector_normal2integer(vector_normalize(v), scale);
}

function vector_smooth(v, bStretch) {
  var i, n, v2, r;
  if(bStretch) {
    r= vector_range(v);
    vector_normalize(v);
  }
  n= v.length;
  v2= [];
  v2[0]= 0.5* (0.5* (v[n- 1]+ v[1])+ v[0]);
  v2[n- 1]=  0.5* (0.5* (v[n- 2]+ v[0])+ v[n- 1]);
  for(i= 1; i< n- 1; i++) v2[i]= 0.5* (0.5* (v[i- 1]+ v[i+ 1])+ v[i]);
  for(i= 0; i< n; i++) v[i]= v2[i];
  delete v2;
  if(bStretch) {
    var s= fabs(r[0]- r[1]);
    vector_normalize(v);
    vector_scale(v, s);
    vector_translate(v, r[0]);
  }
  return v;
}//~vector_smooth()

function vector_compact(v) {//remove undefined items from vector
  var i, n;
  for(n= 0, i= 0; i< v.length; i++) {
    if(typeof(v[i])!= 'undefined') {
       if(n!= i) {
         v[n++]= v[i];
       }else {n++;}
    }
  }
  v.length= n;
  return v;
}//~vector_compact()

function vector2vector2D(v) {
  var i, n, v2D;
  v2D= [];
  n= v.length>> 1;
  for(i= 0; i< n; i++) {
    v2D.push([v[2* i], v[2* i+ 1]]);
  }
  return v2D;
}

function vector2D2vector(v2D) {
  var v, i, n;
  v= [];
  n= v2D.length;
  for(i= 0; i< n; i++) {
    v.push(v2D[i][0], v2D[i][1]);
  }
  return v;
}

function vector_rotate(v, n, bCounterclockwise) {//"roteşte în sensul acelor de ceasornic sau în sens trigonometric (sens invers acelor de ceasornic)"
  var i, x;
  if(bCounterclockwise) {//"anticlockwise, or trigonometric"
    for(i= 0; i< n; i++) {
      x= v.first();
      v.push(x);
    }
  }else {
    for(i= 0; i< n; i++) {
      x= v.pop();
      v.first(x);
    }
  }
  return v;
}//~vector_rotate()


window.random_vector= random_vector;
window.vector_equal= vector_equal;
window.vector_reverse= vector_reverse;
window.vector_shuffle= vector_shuffle;
window.vector_copy= vector_copy;
window.vector_range= vector_range;
window.vector_translate= vector_translate;
window.vector_scale= vector_scale;
window.vector_normalize= vector_normalize;
window.vector_smooth= vector_smooth;
window.vector_rotate= vector_rotate;
</SCRIPT>
<SCRIPT>
function bitget32(x, i) {//DWORD
  //i= clip(i, 0, 31);//BUG!
  if(i& (~31)) return 0;//"outside range [0..31]"
  //i&= 31;
  return ((x& ((1<< i)))? 1: 0);
}

function bitset32(x, b, i) {//DWORD
  //i= clip(i, 0, 31);//BUG!
  if(i& (~31)) return uint32(x);//"if index outside of range [0..31]"
  //i&= 31;//"clip, just to be sure"
  var m= uint32(((b)? 1: 0)<< i);//mask
  if(m) return uint32(x| m);
  m= uint32(~(1<< i));
  return uint32(x& m);
}

function bitget(x, i) {//DWORD
  return bitget32(x, i);
}

function bitset(x, b, i) {//DWORD
  return bitset32(x, b, i);
}

function clip(x, _min, _max) {
   return max(min(x, _max), _min);
}

function bitxor(x, mb, i) { // bitwise-XOR operation on bits
  if(i& (~31)) return uint32(x);//"if index outside of range [0..31]"
  var b= bitget(x, i);
  return bitset(x, (b^ mb), i);
}

/*
function bitnot(x, i) { // bitwise-NOT operation on bits
  //i= clip(i, 0, 31);//BUG!
  if(i& (~31)) return uint32(x);//"if index outside of range [0..31]"
  var b= bitget(x, i);
  return bitset(x, (~b), i);
}
*/
function bitnot(x, i) {return bitxor(x, 1, i)}

function dump_register(r, size) {return BITS(r, size).reverse().join('');}

/* Reverse the first N bits of X, using straightforward code
   (a faster method would use a table)
*/
function bit_reverse(x, n){
   var res= 0;
   do{
      res<<= 1;
      res|= x& 1;
      x>>>= 1;
   } while(--n> 0);
   return res;
}
/* Reverse the bits of a 32bit number
  (eg. the order; as opposed to the NOT(~) operator)
*/
function rev32(x) {
   return bit_reverse(DWORD(x), 32);
}
function rev16(x) {
   return bit_reverse(WORD(x), 16);
}
function rev8(x) {
   return bit_reverse(BYTE(x), 8);
}
/* Bitwise rotate a 32-bit number to the left.
 */
function rol32(x, n) {
   //n= clip(n, 0, 32);//BUG!
   n%= 32;//"Note: (CL= (n& 0xFF)% 32)" "Note too: ((n%= 32)=== (n&= 0x1F))."
   return (x<< n)| (x>>> (32- n));
}
/* Bitwise rotate a 32-bit number to the right
 */
function ror32(x, n) {
   //n= clip(n, 0, 32);//BUG!
   n%= 32;//"Note: (n&= 0x1F) is a faster equivalent."
   return (x>>> n)| (x<< (32- n));
}

function bswap32(x) {//"byte swap: change register endianness"
  var y;
  x= uint32(x);
  y= ((x& (0xFF<< 0))<< 24)| ((x& (0xFF<< 8))<< 8)| ((x& (0xFF<< 16))>> 8)| ((x& (0xFF<< 24))>>> 24);
  return uint32(y);
}//~bswap32()

function bsf32(x) {//"bit scan forward"
  var ZF, i;
  ZF= 0;
  for(i= 0; i<= 31; i++) {
    if(bitget(x, i)) {
      ZF++; break;
    }
  }
  return [ZF, (ZF&& i)];//"return ZF flag and an index to the first set bit"
}//~bsf32()

function bsr32(x) {//"bit scan in reverse"
  var ZF, i;
  ZF= 0;
  for(i= 31; i>= 0; i--) {
    if(bitget(x, i)) {
      ZF++; break;
    }
  }
  return [ZF, (ZF&& i)];//"return ZF flag and an index to the first set bit"
}//~bsr32()

function DWORD(x) {
   //return (x& 0xFFFFFFFF);
   return uint32(x);
}
function WORD(x) {
   return (DWORD(x)& 0xFFFF);
}
function BYTE(x) {
   return (DWORD(x)& 0xFF);
}
function HIWORD(x) {
   return DWORD(x) >>> 16;
}
function LOWORD(x) {
   return WORD(x);
}
function HIBYTE(x) {
   return WORD(x) >>> 8;
}
function LOBYTE(x) {
   return BYTE(x);
}
function BIT(x, n) {
   n= clip(n, 0, 32);
   x= DWORD(x);
   return ((x& (1<< n))>>> n);
}
function BITS(x, n) {
   n= clip(n, 0, 32);
   var a= new Array;
   for(var i= 0; i< n; i++) {
      a[i]= BIT(x, i);
      //a[i]= (BIT(x, i))? 'X':'.'; //dbg
   }
   return a;
}
function BITS32(x) {
   return BITS(x, 32);
}
function BITS16(x) {
   return BITS(x, 16);
}
function BITS8(x) {
   return BITS(x, 8);
}

function bitset_count16(x) {//Return number of bits set in X.
  //We assume that no more than 16 bits are used.
  x= ((x& ~0x5555)>> 1)+ (x& 0x5555);
  x= ((x& ~0x3333)>> 2)+ (x& 0x3333);
  x= ((x>> 4)+ x)& 0x0f0f;
  x= ((x>> 8)+ x)& 0xff;
  return x;
}//~bitset_count16()

function bitset_count32(x) {return (bitset_count16(x>>> 16)+ bitset_count16(x& 0xFFFF));}

function uint32(x) {return ((x)>>> 0);}//{return parseInt(hex(x), 16);}

function uint32_ones(n) { // generate a mask of maximum 32 bits
   if(n== 32) return uint32(~0);
   return uint32(~((~0)<< n));//return uint32(~(-1<< n));
   //return ( ((n== 32)? 0xFFFFFFFF: (uint32((0x00000001<< n)- 1))) ); //"uint32_ones(3)== 7"
}

//function int32(x) {return(((~0)& x)& 0xFFFFFFFF);}
function int32(x) {return((~0)& x);}// "~0== -1"

function DWORD2int(dwX) {return int32(dwX);}

/*
function test_bits() {
   echo('ROL - Bitwise rotate a 32-bit number to the left.');
   var x= 0x12345678;
   for(var i= 0; i<= 32; i++) {
      echo(BITS32(x).reverse());
      x= rol32(x, 1);
   }
   echo();
   echo('ROR - Bitwise rotate a 32-bit number to the right.');
   x= 0x12345678;
   x= 0xF0000000;
   for(var i= 0; i<= 32; i++) {
      //x= ror(x, i);
      //echo(i, ' ', hex(x));
      echo(BITS32(x).reverse());
      x= ror32(x, 1);
   }
}
test_bits();
*/
</SCRIPT>
<SCRIPT>//Gallery of rounding and truncation functions
function Frac(x) { // the fractional part of x
   if(x== 0.0) return 0.0;
   if(x< 0.0) return (x- ceil(x));
   return (x- floor(x));
}

function Int(x) { // the integer part of x
   return (x- Frac(x)); // x:= Int(x)+ Frac(x)
}

function Round(x) { // DigitRound(x, -1)
   if(x>= 0) return Int(x+ 0.5); // rounding towards +Infinity
   return Int(x- 0.5); // rounding towards -Infinity
}

function DigitRound(x, n) {
   n= parseInt(n);
   if(n== 0) {
      if(x== 0.0) return 0.0;
      if(x< 0.0) return -1.0;
      return 1.0;
   }
   if(n< 0) {
      if(x>= 0.0) return (pow(10, -n -1)* Int(x* pow(10, n+ 1)+ 0.5));
      return (pow(10, -n- 1)* Int(x* pow(10, n+ 1)- 0.5));
   }
   if(x>= 0.0) return (pow(10, -n)* Int(x* pow(10, n)+ 0.5));
   return (pow(10, -n)* Int(x* pow(10, n)- 0.5));
}

function _DigitRound(x, n) {
  var f= (x< 0)? ceil(x): floor(x);
  var g= x- f;
  var h= pow(10, n);
  g*= h;
  g= round(g);
  g/= h;
  var y= f+ g;
  return y;
}

/*
function test_DigitRound() {
  var r= 100- (453* 100)/ 762
  //r*= -1;
  var d= DigitRound(r, 2)
  var d2= _DigitRound(r, 2);
  echo(d);
  echo(d2);
}
test_DigitRound();
*/

function StatisticalRound(x, n) {
   n= parseInt(n);
   if(n== 0) return undefined;
   if(n< 0) {
      if((Frac(x* pow(10, n+ 1))== 0.5) && (Even(Digit(x, n))== 1))
         return (Int(x* pow(10, n+ 1))* pow(10, -n- 1));
      return DigitRound(x, n);
   }
   if((Frac(x* pow(10, n))== 0.5) && (Even(Digit(x, n))== 1))
      return (Int(x* pow(10, n))* pow(10, -n));
   return DigitRound(x, n);
}

function Ceiling(x) {
   if(Frac(x)== 0.0) return x;
   if(Frac(x)> 0.0) return Int(x+ 1.0);
   return (Int(x- 1.0)+ 1.0);
}

function Floor(x) {
   if(Frac(x)== 0.0) return x;
   if(Frac(x)> 0.0) return Int(x);
   return (Int(x)- 1.0);
}

function Divides(y, x) { // tell if y divides evenly into x
   if(y== 0.0) return NaN; // undefined
   if(x== (y* Int(x/ y))) return 1;
   return 0;
}

function Even(x) {
   if(Frac(x)!= 0.0)return undefined;
   if(x== (2.0* Int(x/ 2.0))) return 1;
   return 0;
}

function Odd(x) {
   if(Frac(x)!= 0.0)return undefined;
   if(x== (2.0* Int(x/ 2.0))) return 0;
   return 1;
}

function Digit(x, n) {
   n= parseInt(n);
   if(n== 0) return undefined;
   if(n> 0) return Int(Frac(x* pow(10, n- 1))* 10);
   return Int(Frac(x* pow(10, n))* 10);
}

function Parity(x) {
   return (pow(-1, Int(x)));
}

function fmod(x, y, bFast) { // the mod function for real numbers
   if(bFast) return (x% y);
   if(y== 0.0) return x;
   return (y* Frac(x/ y));
}

function integer(x, max_int) {//"A new entry in my gallery of rounding functions!"
  var s, i;
  if(fabs(x)== max_int) return x;
  s= sign(x);
  x= fabs(x)/ max_int;
  i= (s* ((x* (max_int+ 1))>>> 0));
  return i;
}//~integer()

window.Int= Int;
window.Frac= Frac;
window.Round= Round;
window.DigitRound= DigitRound;
window.StatisticalRound= StatisticalRound;
window.Ceiling= Ceiling;
window.Floor= Floor;
window.Divides= Divides;
window.Even= Even;
window.Odd= Odd;
window.Parity= Parity;
window.Digit= Digit;
window.fmod= fmod;
window.integer= integer;
</SCRIPT>
<SCRIPT>//Perlin Noise

function sinc(t) {
  t*= Math.PI;
  if(t!= 0.0) return (sin(t)/ t);
  return 1.0;
}//~sinc()

function _revolve(t, m) {//Revolve t around m. (0.0<= t<= 1.0), (0.0<= m<= 1.0)
  t+= m;
  if(t> 1.0) t-= 1.0;
  return t;
}

function revolve(t, m) {//Revolve t around m. (0.0<= t<= 1.0), (0.0<= m<= 1.0)
  t+= m;
  t%= 1.0;
  return t;
}

//revolve & _revolve are ALMOST equal in the [0..1] interval...
//See: "revolve(t, t)== 0"  while "_revolve(t, t)== 1".

//reparameterize: utility functions: t2u, u2t
function t2u(t) {return (2.0* t- 1);}//t: [0.. 1]-> u: [-1.. 1]
function u2t(u) {return 0.5* (u+ 1);}//u: [-1.. 1]-> t: [0.. 1]

function linear_coefficients(a, b, n) {
  var A, B;
  A= b- a;
  B= a;
  if(n>>> 0) {//forward differencing
    var ax, bx, dt;
    dt= 1/ n;
    ax= B;
    bx= A* dt;
    return [ax, bx];
  }
  return [A, B];
}//~linear_coefficients()

function quadratic_coefficients(a, b, c, n) {
  var A, B, C;
  if(n>>> 0) {//forward differencing
    var ax, bx, cx, k, dt;
    dt= 1/ n;
    k= a+ c- (b+ b);
    ax= a;
    bx= (c- a- (k+ k))* dt;
    cx= (k+ k)* dt* dt;
    bx= bx+ cx;
    cx= cx+ cx;
    return [ax, bx, cx];
  }else {
    A= a+ c- (b+ b);
    A+= A;
    B= c- a- A;
    C= a;
  }
  return [A, B, C];
}//~quadratic_coefficients()

function cubic_coefficients(a, b, c, d, bSpline, n, bBezier, bCatmullRom) {//a cubic, from graph space to equation space
  var A, B, C, D, dxab;
  if(bSpline) {
    if(bCatmullRom) {"interpolate_linear(interpolate_quadratic(a, b, c, 0.5* t+ 0.5), interpolate_quadratic(b, c, d, 0.5* t), t);"
      //A= 0.5* (-a+ 3* b- 3* c+ d);
      //B= 0.5* (2* a- 5* b+ 4* c- d);
      //C= 0.5* (c- a);
      //D= 0.5* (2* b);
      A= 0.5* (d- a)+ 1.5* (b- c);//  A= 2* (b- c)+ 0.5* (c- a+ d- b);
      B= a- 2.5* b+ 2* c- 0.5* d;
      C= 0.5* (c- a);
      D= b;
    }else {//fast and ugly (see also: "")
      dxab= a- b;
      A= (d- c)- dxab;
      B= dxab- A;
      C= c- a;
      D= b;
    }
  }else {
    if(bBezier) {//a cubic Bezier curve
      A= (d+ 3.0* (b- c))- a;
      B= 3.0* (a+ (c- b- b));
      C= 3.0* (b- a);
      D= a;
    }else {//cubic interpolation
      A= 0.5* ( -9* a+ 27* b- 27* c+ 9* d);
      B= 0.5* (+18* a- 45* b+ 36* c- 9* d);
      C= 0.5* (-11* a+ 18* b-  9* c+ 2* d);
      D= a;
    }
  }
  if(n>>> 0) {//forward differencing
    var ax, bx, cx, dx, dt;
    dt= 1/ n;// "n:= number of points, >0, integer"
    ax= D;
    bx= ((A* dt+ B)* dt+ C)* dt;
    cx= (6* A* dt+ 2* B)* dt* dt;
    dx= 6* A* dt* dt* dt;
    return [ax, bx, cx, dx];//"do{x= ax, ax+= bx, bx+= cx, cx+= dx;} while(n--);"
  }
  return [A, B, C, D];
}//~cubic_coefficients()

/*
function foo(bSpline, color) {//draw a cubic by forward differencing
  var i, n, x, y, v, ax, bx, cx, dx, ay, by, cy, dy, bSpline;
  n= 200;//How many points to draw.
  marker(100, 100, 'red');  marker(200, 200, 'red');//control points
  marker(300, 100, 'red');  marker(400, 200, 'red');
  cf= cubic_coefficients(100, 200, 300, 400, bSpline, n);
  ax= cf[0]; bx= cf[1]; cx= cf[2]; dx= cf[3];
  cf= cubic_coefficients(100, 200, 100, 200, bSpline, n);
  ay= cf[0]; by= cf[1]; cy= cf[2]; dy= cf[3];
  do {//Evaluation of cubic polynomial by forward differencing.
    x= ax, ax+= bx, bx+= cx, cx+= dx;//abscissa
    y= ay, ay+= by, by+= cy, cy+= dy;//ordinate
    putpixel(x, y, color);
  }while(n--);
}//~foo();
foo(false, 'red');
foo(true, 'green');
*/

function easy_curve(t, bNew) { // a more pleasing curve than linear interpolation
   function T3(x) {return (4.0* x* x* x- 3.0* x);}//polinom Chebishev de speta intaia, de ordinul 3
   if(bNew) {
     return t* t* t* (t* (t* 6.0- 15.0)+ 10.0);
   }else {
     //return (0.5* (1.0- T3(t- 0.5)));//same as (3* t* t- 2* t* t* t)
     //interpolate_cubic(1, 0, 1, 0, t, true)// ditto
     var t2;
     t2= t* t;
     t*= t2;
     t+= t;
     t2+= t2+ t2;
     return (t2- t);//fast
   }
}//~easy_curve()

function interpolate_lagrange(v, t) {//interpolate using a degree n polynomial, at time t; "n:= (v.length- 1)"; "t:= [0.. 1]"
  if(arguments.length> 2) {
    v= vector_copy();//vector_copy(arguments);
    t= v.pop();
  }
  var i, n, x, vxy, bEasy;
  if(t.length== 2) {
    bEasy= t.pop();
    t= t.pop();
  }
  n= v.length;
  vxy= range(1, n+ 1, 1);
  vector_normalize(vxy);
  //NOTE: vxy is arbitrary and I see no reason why not to choose another vector (e.g. see the easy curve interpolant, for example)
  //     ...actually I see every reason you'll want to choose another one
  //        if you are looking for the smallest (euclidean distance) curve through given points.
  if(bEasy)
    vxy.foreach("v[i]= interpolate_easy(0, 1, v[i])");//HOW ABOUT THAT?! :)
  vxy.foreach("v[i]= [v[i], lParam[i]]", v);//"vxy[i]= [vxy[i], v[i]]"
  x= lagrange(vxy, t, false); // extrapolate if t is outside the [0, 1] interval
  return x; //"interpolate_lagrange([1, 4, 3, 2, 5], 0.5)= 3"
}

function interpolate_linear(a, b, t) {
   return (b- a)* t+ a; //return ((1- t)* a+ t* b);
}

function interpolate_quadratic(a, b, c, t) {// return x in [a, c] interval for t in [0, 1]
  var A, B, C;
  A= a+ c- (b+ b);
  A+= A;
  B= c- a- A;
  C= a;
  //return horner([C, B, A], t);
  return (t* (t* A+ B)+ C);//"x= b, for t= 0.5"
}

function interpolate_cubic(a, b, c, d, t, bSpline) {
  if(bSpline) { // return x in [b, c] interval for t in [0, 1]
   var A, B, C, D, dxab;
   dxab= a- b;
   A= (d- c)- dxab;
   B= dxab- A;
   C= c- a;
   D= b;
   //return horner([D, C, B, A], t);
   return (t* (t* (t* A+ B)+ C)+ D); // horner
  }else { // return x in [a, d] interval for t in [0, 1]
    return interpolate_lagrange(a, b, c, d, t);
  }
}//~interpolate_cubic()

function interpolate_quintic(a, b, c, d, e, t) {
  var x;
  x= interpolate_lagrange([a, b, c, d, e], t);//NOTE: lagrange is slow. TODO: use newton interpolation.
  return x;
}//~interpolate_quintic()

function interpolate_easy(a, b, t) { // use the "easy curve" interpolant (more pleasing, a 3rd order polynomial)
   var p= easy_curve(t); // is equal to linear for 3points [0, 0.5, 1], but closer to 0 in (0, 0.5) and closer to 1 in (0.5, 1)
   return interpolate_linear(a, b, p);
}

function interpolate_cosine(a, b, t) {
   t*= Math.PI;
   t= 0.5* (1.0- cos(t));
   return interpolate_linear(a, b, t);
}

function extrapolate(v) {
  var u, x, i, n, t;
  u= [];
  n= v.length;
  if(!n) return 0.0;
  if(n== 1) return v[0];
  for(i= 0; i< n; i++) { //>
    u.push([i, v[i]]);
  }
  t= n;
  x= interpolate_classic(u, t);
  return x; // return interpolate_lagrange(v, (v.length/ (v.length- 1.0)));
}//~extrapolate()

function extrapolate_linear(x0, x1) {
  var x2;
  x2= (-1.0* x0)+ (2.0* x1);
  return x2; // return interpolate_linear(x0, x1, 2.0/ 1.0);
}//~function extrapolate_linear()

function extrapolate_quadratic(x0, x1, x2) {
  var x3;
  x3= (1.0* x0)+ (-3.0* x1)+ (3.0* x2);
  return x3; // return interpolate_quadratic(x0, x1, x2, 3.0/ 2.0);
}//~extrapolate_quadratic()

function extrapolate_cubic(x0, x1, x2, x3) {
  var x4;
  x4= (-1.0* x0)+ (4.0* x1)+ (-6.0* x2)+ (4.0* x3);
  return x4; // return interpolate_cubic(x0, x1, x2, x3, 4.0/ 3.0);
}//~function extrapolate_cubic()

function extrapolate_quintic(x0, x1, x2, x3, x4) {
  var x5, v;
  v= [
    +1*  1, // interpolate_quintic(1, 0, 0, 0, 0, 5/4);
    -1*  5, // interpolate_quintic(0, 1, 0, 0, 0, 5/4);
    +1* 10, // interpolate_quintic(0, 0, 1, 0, 0, 5/4);
    -1* 10, // interpolate_quintic(0, 0, 0, 1, 0, 5/4);
    +1*  5, // interpolate_quintic(0, 0, 0, 0, 1, 5/4);
  ]; 
  x5= (v[0]* x0)+ (v[1]* x1)+ (v[2]* x2)+ (v[3]* x3)+ (v[4]* x4); //x5= extrapolate([x0, x1, x2, x3, x4]);
  return x5;//interpolate_quintic(x0, x1, x2, x3, x4, 5/4)
}//~extrapolate_quintic()


function easyT(t) {return (t- interpolate_easy(0, 1, t));}

function noise_smooth(priv_x, x, next_x) {
   return (0.5* (0.5* (priv_x+ next_x)+ x));
}

function noise_get(x, bInteger) { // x:= integer32 [for Perlin noise]
  //return (1.0- ((x* (x* x* 15731+ 789221)+ 1376312589)& 0x7FFFFFFF)/ 1073741824.0); // truncation error
  var a, b, c, d, e, f, g, h, y;
  x= int32(x);
  a= (x<< 13)^ x;
  b= int32(a* a); // is different from the C version
  c= int32(b* 15731);
  d= int32(c+ 789221);
  e= int32(a* d);
  f= int32(e+ 1376312589);
  g= int32(f& 0x7FFFFFFF);
  h= 1.0- g/ 1073741824.0;
  if(!bInteger) return h;
  y= integer(h* 0x10000, 0xFFFF);
  return y;
}//~noise_get()

function noise_get2D(x, y) { // x:= int32 [for 2D Perlin noise]
   var z= x+ 57* y;
   return noise_get(z);
}

function noise_get_smooth(x) { // x:= int32
   var priv_x= noise_get(x- 1);
   var next_x= noise_get(x+ 1);
   return noise_smooth(priv_x, x, next_x);
}

function noise_get_smooth2D(x, y) {
   var c, s, d;
   c= noise_get2D(x, y); // center
   s= noise_get2D(x- 1, y)+ noise_get2D(x+ 1, y)+
      noise_get2D(x, y- 1)+ noise_get2D(x, y+ 1); // sides
   d= noise_get2D(x- 1, y- 1)+ noise_get2D(x+ 1, y- 1)+
      noise_get2D(x- 1, y+ 1)+ noise_get2D(x+ 1, y+ 1);// corners
   return (c/ 4+ s/ 8+ d/ 16);
}

function sawtooth(t, teeth) {
  if(!teeth) teeth= 1.0;
  t*= teeth;
  // make sure t is within 0 to 1
  t %= 1.0;
  if (t< .0) t+= 1.0;
  if (t> .5) t= 1.0- t;
  t+= t;
  t/= teeth;
  return t;
}//~sawtooth()

window.easy_curve= easy_curve;
window.interpolate_linear= interpolate_linear;
window.interpolate_quadratic= interpolate_quadratic;
window.interpolate_cubic= interpolate_cubic;
window.interpolate_quintic= interpolate_quintic;
window.interpolate_easy= interpolate_easy;
window.interpolate_cosine= interpolate_cosine;
window.extrapolate= extrapolate;
window.extrapolate_linear= extrapolate_linear;
window.extrapolate_quadratic= extrapolate_quadratic;
window.extrapolate_cubic= extrapolate_cubic;
window.extrapolate_quintic= extrapolate_quintic;
window.noise_smooth= noise_smooth;
window.noise_get= noise_get; // Perlin
window.noise_get2D= noise_get2D; // Perlin
window.noise_get_smooth= noise_get_smooth; // Perlin
window.noise_get_smooth2D= noise_get_smooth2D; // Perlin
</SCRIPT>
<SCRIPT>
//Math Methods
abs= Math.abs; acos= Math.acos; asin= Math.asin; atan= Math.atan; atan2= Math.atan2;
ceil= Math.ceil; cos= Math.cos; exp= Math.exp; floor= Math.floor; log= Math.log;
/*max= Math.max; min= Math.min;*/ pow= Math.pow; random= Math.random; round= Math.round;
sin= Math.sin; sqrt= Math.sqrt; tan= Math.tan; /*ln= Math.log;*/

//Math Properties
E= Math.E; LN2= Math.LN2; LN10= Math.LN10; LOG2E= Math.LOG2E; LOG10E= Math.LOG10E;
PI= Math.PI; SQRT1_2= Math.SQRT1_2; SQRT2= Math.SQRT2;

window.Math.DELTA= math_delta();
window.Math.RESOLUTION= math_resolution();

//"Math.E== pow(1.0+ Math.DELTA, Math.RESOLUTION- 1.0)"

/*
  Machine floating point math:

  MATH RESOLUTION: 4503599627370497
  MATH DELTA: 2.220446049250313e-16

  machine delta:
    A measure of precision; which can be expressed
  in terms of the smallest number that can be
  added to 1.0 without loss of significance.
*/
function math_delta() { // the smallest fraction of a unit
  var t, dx;
  dx= 1.0;
  do {
     dx/= 2.0;
     t= 1.0+ dx;
  } while(t!= 1.0);
  return (2.0* dx);
}

function math_resolution() { // how many numbers can we discriminate in [0..1] interval
  var delta= math_delta();
  var resolution= (1.0/ delta)+ 1;
  return resolution;
}

window.math_resolution= math_resolution;
window.math_delta= math_delta;

window.Math.DELTA= math_delta();
window.Math.RESOLUTION= math_resolution();


//NOTE: Parameter n must be the same for the inverse to work (eg. f2i(i2f(x, n), n)== x).
//NOTE: For (n .lt.OR.eq. 0) the return value for this function and its inverse is undefined.
function i2f(i, n) {//i2f: convert integer to float: inverse of f2i()
  var t;
  //if(n== 0) return NaN;
  if(n== 0) return 0.0;
  t= i/ n; // NOTE: The inverse is not that simple as "return (i= n* t);"!
  return t;
}//~i2f()

//NOTE: f2i() is the TRUE inverse of i2f()!
//NOTE: BREAKTHROUGH! This is some of my finest work! Simple enough; yet it took me some time to think things through...
function f2i(t, n) {//f2i: convert float to integer: inverse of i2f()
  var i;
  //if(n== 0) return NaN;
  if(n== 0) return 0;
  if(t- Math.floor(t)) {//"if has fractional component"
    i= Math.floor((n+ 1)* t);
    if(t< 0.0) i+= 1; //  i= Math.floor((n+ 1)* t)+ 1;//i= Math.ceil((n+ 1)* t);//i= -1* Math.floor((n+ 1)* Math.abs(t));
  }else {//"if possible overshoot"
    i= Math.floor(n* t);
  }
  return i;//"hex(f2i(i2f(0x0D, 0xFF), 0xFFFFFFFF))== '0x0D0D0D0D'"
}//~f2i()

function math_percent(n, i, p) {
  if(arguments.length== 1) {//"'39'.percent(33.33)= 12.9987"
    p= n;
    n= parseFloat(this);
    i= (n* p)/ 100;
    return i;//echof("%f is approx. %.2f%% of %f", i, p, n);
  }
  if(n== undefined) {
    if(p!= 0) {
      n= (i* 100)/ p;
    }else {
      n= NaN;
    }
  }
  if(i== undefined) {
    i= (n* p)/ 100;
  }
  if(p== undefined) {//"i is p% of n"
    if(n== 0) p= NaN;
    else p= (i/ n)* 100;
  }
  return [n, i, p];//"[n:whole, i:part, p:percent]"
}//~math_percent()

window.math_percent= math_percent;
Math.percent= math_percent;
String.prototype.percent= math_percent;
Number.prototype.percent= math_percent;

/*
function fact(x) { // factorial
   var x= parseInt(arguments[0]);
   if(x== 1) {
                  return 1;
   }else {
      if(x== 0) {
                  return 0;
      }else {
                  return (x* fact(x- 1));
      }
   }
}
*/

function fact(x) { // factorial
   var n= parseInt(arguments[0]);
   var f= 1;
   for(var i= 2; i<= n; i++) f*= i;
   return f;
}

function _round(x) {
   return floor(x+ 0.5);
}

function fabs(x){
   if(x< 0.0) return -x;
   return x;
}
/*
function _cbrt(x) { // Cube root algorithm (Newton method) (see also the "_gnrt" function)
   var r, RC3;
   var DELTA= Math.DELTA;
   if(x< 0.0) return null;
   RC3= 1/ 3;
   r= x/ 3.0;
   while(fabs(x- r* r* r)> DELTA* x) { // BUG!! "echo(_cbrt(6))" BUG!! (infinite loop)
      r= RC3* (x/ (r* r)+ r+ r);
   };
   return r; // "x= _cbrt(3); (x* x* x== 3.0) true"
}
*/

function _cbrt(x) { // Cube root algorithm (Newton method) (see also the "_gnrt" function)
   var pr, r, RC3, depth;
   var DELTA= Math.DELTA;
   if(x== 0.0) return 0.0;
   if(x< 0.0) return null;
   RC3= 1/ 3;
   r= x/ 3.0;
   depth= 64; // bug control unit [under construction]
   do {
      pr= r;
      r= RC3* (x/ (r* r)+ r+ r);
//echo(r);
      if(!depth--) break; // dbg
   } while(fabs(pr -r)> DELTA); //
   return r;
}

function _sqrt(x, bVariant) { // Newton's square root algorithm [UNDER DEVELOPMENT]
   var pr, r;
   var DELTA= Math.DELTA;
   if(x< 0.0) return null;
   r= 0.5* x;
   if(!bVariant) {
     do {
       pr= r;
       r= 0.5* (x/ r+ r);
     } while(fabs(pr- r)> DELTA);
   }else {  //DO THE UNSTABLE (!!!BEWARE!!!)
     while(fabs(x- r*r)> DELTA* x) {// BUG! BUG!
       r= 0.5* (x/ r+ r);
     } //BUG! BUG! '(_sqrt(1.026425633341087))' GONE INTO HYPERSPACE!!
   }
   return r;
}

function _hypot(x, y) { // sqrt(a^2+ b^2) (without [under/over]flow)
   var r;
   if (fabs(x)> fabs(y)) {
      r= y/ x;
      r= fabs(x)* _sqrt(1.0+ r* r);
   } else if (y!= 0.0) {
      r= x/ y;
      r= fabs(y)* _sqrt(1.0+ r* r);
   } else {
      r= 0.0;
   }
   return r;
}

function _atan_v0001(x) { // compute the arctangent using the HYBRID power series expansion formula (ORIGINAL) [NETERMINATA]
   if(x== 0.0) return x;
   if(x< 0.0) return -_atan_v0001(-x);
   if(x> 1.0) return 0.5* Math.PI- _atan_v0001(1/ x);
   var DELTA= Math.DELTA;
   var pt, t, i, x2, dn;
   i= 1.0;
   dn= 1.0;
   x2= x* x;
   t= x;
   var v= []; // refinement vector
   var MAX_STEPS=  77; //3158 total steps (46: 1174 steps)
   var   steps= MAX_STEPS;
   v[v.length]= t;
   do {
      pt= t;
      i*= -1.0;
      x*= x2;
      dn+= 2.0;
      t+= i* (x/ dn);
   v[v.length]= t;
   } while(steps--);
//steps= MAX_STEPS; //dbg
   while(v.length!= 1) { // refinement
     for(var i= 1; i< v.length; i++) {
       v[i- 1]= 0.5* (v[i- 1]+ v[i]);
//       steps++; //dbg
     }
     v.length= v.length- 1;
   }
//echo('steps: '+ steps); //dbg
   return (v[0]); // "_atan(1.0) equal PI/ 4"
}//~_atan_v0001()

function _atan_v0002(x) { // compute the arctangent using the HYBRID power series expansion formula (ORIGINAL) [NETERMINATA]
   if(x== 0.0) return x;
   if(x< 0.0) return -_atan_v0002(-x);
   if(x> 1.0) return 0.5* Math.PI- _atan_v0002(1/ x);
   var DELTA= Math.DELTA;
   var pt, t, i, x2, dn, m, n;
   i= 1.0;
   dn= 1.0;
   x2= x* x;
   t= x;
   var v= []; // refinement vector
   var MAX_STEPS= 78; //78: 1678 total steps (46: 622 steps)
   var   steps= MAX_STEPS;
   v[v.length]= t;
   do {
      pt= t;
      i*= -1.0;
      x*= x2;
      dn+= 2.0;
      t+= i* (x/ dn);
   v[v.length]= t;
   } while(steps--);
   n= v.length;
   m= 1;
   while(n>= m) { // refinement
     for(var i= m; i< n; i++) {
       v[i- 1]= 0.5* (v[i- 1]+ v[i]);
     }
     n--;
     m++;
   }
   return (v[n]); // "_atan(1.0) equal PI/ 4"
}//~_atan_v0002()

function _atanX(x) { // arctangenta [ probabil mai rapida decat cea cu radicali, de testat] (Euler)
   if(x== 0.0) return x;
   if(x< 0.0) return -_atanX(-x);
   if(x> 1.0) return 0.5* Math.PI- _atanX(1/ x);
   var dx, dy, x2, y, pt, t, i, a, b;
var steps= 64;//dbg
   x2= x* x;
   y= x2/ (1+ x2);
   t= 1.0;
   i= 0;
   a= 1.0;
   b= 1.0;
   dy= 1.0;
   do {
      i+= 2;
      a*= i;
      b*= i+ 1;
      dx= a/ b;
      dy*= y;
      pt= t;
      t+= dy* dx;
echo(64- steps+ ':\t'+ (4.0* (y/ x)* t));//dbg
if(!steps--){ echo('_atanX[bp]!'); break};
   }while(fabs(pt- t)> Math.DELTA);
   return ((y/ x)* t);
}//~_atanX()

//function _atan(x) {return integral(0, x, '1/ (1+ x* x)');}

/*
function _atan0002(x) {//Foloseste formula de aproximare "f(x)~= f(x0)+ f'(x0)(x- x0)" Manualul de AnalizaMatematica clasa a XI-a
  //converge rapid dar pe un interval restrans (  6 steps: [-1.1677094524216222, 1.1677094524216222])
  if((x< -6.283185307179586)|| (x> 6.283185307179586)) {
    SetLastError(['_atan0002: x= '+ x+ '(not in [-6.283185307179586,  6.283185307179586]) not Implemented!',
                 Errors.NotImplemented, get_call_stack(arguments.callee)]);
    return NaN;
  }
  var steps= 17;//loop: _atan0002(0.0000001)
  var t, at, df;
  fd= 1/ (1+ x* x);//f'(x): in teorie ar trebui sa fie f'(x0), dar atata timp cat procesul este convergent, oricum, x0 tinde catre x
  t= fd* x;
  //echo(t+ ' '+ (0.5+ 0.5*(1.0- _tan(0.5))));//"0.5 0.7268487550781048" HMM..
  do {
    at= t;
    t= t+ fd* (x- _tan(t));
    //echo(t);//dbg
    if(!--steps) break;//
  }while(t!= at);//}while(fabs(t- at)> Math.DELTA);
  //echo('steps:'+ (17- steps));//dbg
  return at;
}//~_atan0002()
*/

function _atan0002(x) {//Foloseste formula de aproximare "f(x)~= f(x0)+ f'(x0)(x- x0)" Manualul de AnalizaMatematica clasa a XI-a
  if(x== 0.0) return x;
  if(x< 0.0) return -arguments.callee(-x);
  if(x> 1.0) return 0.5* Math.PI- arguments.callee(1/ x);
  var t, dx, fd;
  fd= 1/ (1+ x* x);//f'(x); (corectie la formula de aproximare liniara) vezi si versiunea Euler
  t= fd* x;
  do {
    dx= fd* (x- _tan(t));
    t+= dx;
  }while(dx> Math.DELTA);
  return t;
}//~_atan0002()

function _atan0003(x) {
  if(x== 0.0) return x;
  if(x< 0.0) return -arguments.callee(-x);
  if(x> 1.0) return 0.5* Math.PI- arguments.callee(1/ x);
  var t, fd, x2;
  x2= x* x;
  fd= 1.0/ (1.0+ x2);
  t= x/ (1.0+ 0.27323954473516265* x2);
  t+= fd* (x- _tan(t));
  t+= fd* (x- _tan(t));
  t+= fd* (x- _tan(t));
  return t;
}//~_atan0003()

function _atan(x) { // compute the arctangent using the half-angle formula (improved)
   if(x== 0.0) return x;
   if(x< 0.0) return -arguments.callee(-x); //"-_atan(-x);"
   if(x> 1.0) return 0.5* Math.PI- arguments.callee(1/ x);//"0.5* Math.PI- _atan(1/ x);"
   function atan1_2(x) {//equivalent of "return (x/ (1.0+ _hypot(1.0, x)));", faster
     //return (x/ (1.0+ _hypot(1.0, x)));
     //return (x/ (1.0+ sqrt(1.0+ x* x)));
     //return (((sqrt(1.0+ x* x)- 1.0)/ x));//numerically unstable
     var y, py, DELTA;
     DELTA= 0.5* Math.DELTA;//constant
     x= 0.5* x;
     y= x;
     do {
       py= y;
       y= x* (1- y* y);
     } while(fabs(py- y)> DELTA);
     return y;
   }//~atan1_2()
   var DELTA= Math.DELTA;
   var i, r1, r2;
   i= 1//0.5;
   r2= x;
   do {
      r1= r2;
      x= atan1_2(x);//"x/= (1.0+ _hypot(1.0, x));"
      i+= i;
      r2= i* x;
   } while((r1- r2)> DELTA);
   return (r2); // "_atan(1.0) equal PI/ 4"
}//~_atan()

function _atan2(y, x) {
  if(x== 0.0) {
     if(y== 0.0) return 0.0;
     else if(y< 0) return -0.5* Math.PI;
          else return 0.5* Math.PI;
  }
  return (2.0* _atan(y/ (x+ _hypot(x, y)))); // "_atan2(1.0, 0.0) equal PI/ 2"
}

function _asin(x) { // arcsin ["_asin(_sin(.3223))= 0.3223"]
   return (2* _atan(x/ (1+ _sqrt(1- x* x))));
}

function _acos(x) { // arccos
   if(x== -1.0) return Math.PI;
   return (2* _atan(_sqrt(1- x* x)/ (1+ x)));
}

function _actan(x) { // arccot
   return (Math.PI/ 2- _atan(x));
}

window._cbrt= _cbrt;
window._sqrt= _sqrt;
window._hypot= _hypot;
window._atan_v0001= _atan_v0001;
window._atan= _atan;
window._atan2= _atan2;

window._asin= _asin;
window._acos= _acos;
window._actan= _actan;

</SCRIPT><SCRIPT>
/* isqrt:
    ENTRY x: unsigned long
    EXIT  returns floor(sqrt(x) * pow(2, BITSPERLONG/2))

    Since the square root never uses more than half the bits
    of the input, we use the other half of the bits to contain
    extra bits of precision after the binary point.

    EXAMPLE
        suppose BITSPERLONG = 32
        then    usqrt(144) = 786432 = 12 * 65536
                usqrt(32) = 370727 = 5.66 * 65536

    NOTES
        (1) change BITSPERLONG to BITSPERLONG/2 if you do not want
            the answer scaled.  Indeed, if you want n bits of
            precision after the binary point, use BITSPERLONG/2+n.
            The code assumes that BITSPERLONG is even.
        (2) This is really better off being written in assembly.
            The line marked below is really a "arithmetic shift left"
            on the double-long value with r in the upper half
            and x in the lower half.  This operation is typically
            expressible in only one or two assembly instructions.
        (3) Unrolling this loop is probably not a bad idea.

    ALGORITHM
        The calculations are the base-two analogue of the square
        root algorithm we all learned in grammar school.  Since we're
        in base 2, there is only one nontrivial trial multiplier.

        Notice that absolutely no multiplications or divisions are performed.
        This means it'll be fast on a wide range of processors.
*/

function isqrt(x) {
        x= DWORD(x);
        //echo(x);//dbg
        var BITSPERLONG= 32;
        //function TOP2BITS(x) {return ((x& (3<< (BITSPERLONG- 2)))>> (BITSPERLONG- 2));}//BUG!: JAVASCRIPT is not C
        function TOP2BITS(x) {return (bitget(x, BITSPERLONG- 1)<< 1)| bitget(x, BITSPERLONG- 2)}
        var a= 0;// accumulator
        var r= 0;// remainder
        var e= 0;// trial product
        for (var i= 0; i< BITSPERLONG; i++) {// NOTE 1
                r= (r<< 2)+ TOP2BITS(x); x<<= 2; // NOTE 2
                a<<= 1;
                e= (a<< 1)+ 1;
                if (r>= e) {
                        r-= e;
                        a++;
                }
        }
        return a;
}//~isqrt()

/*
function test_isqrt() {
  var x;
  x= 2;
  echo("sqrt(", x, ")");
  echo("ISQRT: ", _DigitRound(isqrt(x<< 16)/(65536* 256), 7));
  echo("SQRT:  ", sqrt(x));
  x= 3;
  echo("sqrt(", x, ")");
  echo("ISQRT: ", _DigitRound(isqrt(x<< 16)/(65536* 256), 7));
  echo("SQRT:  ", sqrt(x));
  x= 65535/ 4;//16383
  echo("sqrt(", DWORD(x), ")");
  echo("ISQRT: ", _DigitRound(isqrt(x<< 16)/(65536* 256), 7));
  echo("SQRT:  ", sqrt(x));
}

//test_isqrt();
*/

function test_isqrt() {//FixedPoint MATH
  var a, b, c, x, y;
  x= 1//1;//2;//65535;// FixedPoint real number
  y= isqrt(x);
  a= x/ 65536;
  b= y/ (65536* 256);// (y/ 65536)/ 256;
  c= sqrt(a);
  echo('x= '+ a);
  echo('isqrt(x): '+ _DigitRound(b, 7));
  echo('sqrt(x):  '+ c);
}

</SCRIPT><SCRIPT>
/*
 * 16.16 FIXED POINT MATH (PROOF OF CONCEPT)
*/
function Real2Fixedpoint(x) {//16.16 FIXEDPOINT
  var FXPT_MIN= -2147483648; // ((int) 0x80000000)
  var FXPT_MAX= 2147483647; // ((int) 0x7FFFFFFF)
  x= round(x* (1<< 16));
  return clip(x, FXPT_MIN, FXPT_MAX);
}
function Fixedpoint2Real(x, bAccurate) {
  if(bAccurate) return (x/ (1<< 16));
  return _DigitRound((x/ (1<< 16)), 5);
}
function Fixedpoint2Int(x) {
  if(x< 0) return ceil(x/ (1<< 16));//fix: 4 JavaScript
  return (x>> 16);//in C only this is required and is much faster
}

function sqrt_Fixedpoint(x) { //16.16 FIXEDPOINT MATH
  var pr, r, t;
  var DELTA= 1; //floor(0.00002* (1<< 16))
  x= DWORD(x);
  if(x<= 0){
    r= 0;
  }else {
    r= ((x== 1)? 2: (x>> 1));
    do {
      pr= r;
      t= DWORD(x/ pr);
      r= (pr+ t)>> 1;
    }while(abs(pr- r)> DELTA);
  }
  return (r<< 8);//"x= 2; Fixedpoint2Real(sqrt_Fixedpoint(Real2Fixedpoint(x)))== 1.41406"
}//~sqrt_Fixedpoint()

</SCRIPT><SCRIPT>
function logarithm(base, x, bFast) { // a brute-force approach (dependencies: pow()) [bug: "TEST MORE!"]
   if((base<= 0.0)|| (base== 1.0)) return NaN;  //base: logarithm base (eg. for log3(x) the base should be 3)
   var bFractionalBase= (base< 1.0);
   if(x< 0.0) return NaN;
   if(x== 0.0) return -Infinity;
   if(x== 1.0) return 0.0;
   if(bFast) {return ((1.0/ log(base))* log(x));}//dbg
   if(bFractionalBase) {base= 1.0/ base;}
   if(x== base) return 1.0;
   var MAX_STEPS= 64; //dbg  [guard aganist infinite-loops] arbitrary value (has impact on output resolution)
   var bFractional= (x< 1.0);
   if(bFractional) {// use the logarithm property: "logB(x/y)= logB(x)- logB(y); where x= 1 and y= 1/z, z in (0.0 .. 1.0) interval, where B is the BASE"
      x= 1.0/ x;
   }
   var sup, inf;
   inf= 0;

   //bug: TEST THE STARTING CONDITIONS (maybe start in the middle of the interval?)
   sup= x+ 1;//x
   var y= x;//0.5* (sup+ inf);

   var t= pow(base, y);
   var steps= MAX_STEPS; //dbg
   while(fabs(t- x)> Math.DELTA) {//binary-search
     if(t> x) {
       if(sup== y) break;
       sup= y;
     }else {
       if(inf== y) break;
       inf= y;
     }
     y= 0.5* (sup+ inf);
     t= pow(base, y);
     if(!--steps) break;//dbg
   }
   if(bFractional) {y= -y;}
   if(bFractionalBase) {y= -y;}
   return y; //"logarithm(1/ 3, 81)== -4"
}//~logarithm() "Some of my finest work!..."

function _log2(x) {
  var M_LN2= 0.69314718055994530942;
  return ((1.0/ M_LN2)* log(x));
}

function log2(x) {
  return logarithm(2, x); // "pow(2, log2(13))== 13; log2(0.3)== -1.736965594166206"
}

function log10(x) {//lg: logaritm zecimal (vulgar); logaritm cu baza 10
  return logarithm(10, x);// "pow(10, log10(13))== 13.000000000000005; log10(0.3)== -0.5228787452803376"
}//~log10() "the common logarithm"

function lg(x) {return log10(x);}

function ln(x) {//ln: logaritm natural (neperian); logaritm cu baza e (e== exp(1.0))
  return logarithm(Math.E, x);
}//~ln() "the natural logarithm"
</SCRIPT><SCRIPT>
function math_odd(x) {
  return ((x% 2)== 1);
}
function math_even(x) {
  return ((x% 2)== 0);
}

function math_real2rational(x) {// x= A/ B
  if(x< 0.0) {
    SetLastError(['math_real2rational: Negative argument not yet implemented ('+ x+ ')', Errors.NotImplemented, get_call_stack(arguments.callee)]);
    return NaN;
  }
  var X= x.toString();
  X= X.split('e');
  if(X.length== 1) {
    X= X[0].split('.');
    if(X.length== 1) {
       return [parseInt(X[0]), 1];
    }else {
       var A= parseInt(X[0]+ X[1], 10);
       var B= parseInt('1'+ strdup('0', strlen(X[1])- 1));
       var C= gcd(A, B);
       echo('x '+ x); echo('X '+ X); echo('A '+ A); echo('B '+ B); echo('C '+ C);//dbg
       return [A/ C, B/ C]; //"numerator/ denominator"
    }
  }else {
    SetLastError(['math_real2rational: Not yet implemented ('+ x+ ')', Errors.NotImplemented, get_call_stack(arguments.callee)]);
    return NaN;
  }
}//~math_real2rational()

function math_pow(a, b) {
  var t;
  var bNegative= (b< 0);
  if(bNegative) b= -b;//change sign
  if(isUnsignedInteger(b)) {//al-Kashi algorithm for integer powers
    var i= 0;//dbg
    t= 1;
    while(b> 0) {
      if(math_odd(b)) {//PASCAL: "IF ODD(b) THEN"
        t*= a;
        i++;
      }
      a= sqr(a);
      i++;
      b= (b- (b% 2))/ 2;// PASCAL: "b:= b DIV 2;"
    }
    //echo('numar de inmultiri: '+ i);//dbg
  }else {
    var r= math_real2rational(b);
    t= math_pow(math_root(r[1], a), r[0]); // "math_pow(0.12, 0.13)== pow(pow(0.12, 1/100), 13)"
  }
  if(bNegative) return math_reciprocal(t);// (1/ t);
  return t;//"math_pow(1+ Math.DELTA, Math.RESOLUTION)"
}//~math_pow()

/*
function math_root(ord, x) { // the [ord] root of x "ord-th root the quantity raised to the power '1/ ord'"
  ord= parseInt(ord);
  if((ord< 2)|| (ord>Math.RESOLUTION)) {
    SetLastError(["math_root: "+ ord+ " (order): invalid argument.", Errors.InvalidArgument, get_call_stack(arguments.callee)]);
    return NaN;
  }
  if (x< 0.0) return NaN;
  var bFractional= ((x> 0)&& (x< 1));
  var r, a, b;
  if(bFractional) {
    a= x;
    b= 1;
  }else {
    a= 0;
    b= x;
  }
  while(1) {//binary-search "SIMPLE YET NUMERICALLY STABLE"
    r= 0.5* (a+ b);
    if(math_pow(r, ord)< x) {
      if(r== a) break;
      a= r;
    }else {
      if(r== b) break;
      b= r;
    }
  }
  return r;//"pow(0xFFFFFFFF, math_reciprocal(123456789))== math_root(123456789, 0xFFFFFFFF)"
}//~math_root() "Some of my finest work!.."
*/
function math_root(ord, x) { // the [ord] root of x "ord-th root the quantity raised to the power '1/ ord'"
  ord= parseInt(ord);
  if((ord< 2)|| (ord>Math.RESOLUTION)) {
    SetLastError(["math_root: "+ ord+ " (order): invalid argument.", Errors.InvalidArgument, get_call_stack(arguments.callee)]);
    return NaN;
  }
  if (x< 0.0) return NaN;
  var bFractional= ((x> 0)&& (x< 1));
  var r, a, b;
  if(bFractional) {
    a= x;    b= 1;
  }else {
    a= 0;    b= x;
  }
  function f(r, lParam) {
    var x, y, ord;
    x= lParam[0];
    ord= lParam[1];
    y= math_pow(r, ord);
//    if(fabs(y- x)<= Math.DELTA) return 0;
    if(y< x) return 1;
    else return -1;
  }
  r= binary_search(a, b, f, [x, ord]);
  return r;//"pow(0xFFFFFFFF, math_reciprocal(123456789))== math_root(123456789, 0xFFFFFFFF)"
}//~math_root() "Some of my finest work!.."

function math_sqrt(x) {// square root
  return math_root(2, x);//"pow(x, 1/ 2)"
}

function math_cbrt(x) {// cube root
  return math_root(3, x);//"pow(x, 1/ 3)"
}

function math_qart(x) {// the 4th (quart) root of x
  return math_root(4, x);
}

function math_cbrt(x) { // cube root (TODO: de incercat cautarea prin interpolare) bug: TEST MORE "math_cbrt(6)"
  if (x< 0.0) return NaN;
  var r, a, b;
  if((x> 0)&& (x< 1)) {
    a= x;
    b= 1;
  }else {
    a= 0;
    b= x;
  }
  while(1) {//binary-search
    r= 0.5* (a+ b);
    if((r* r* r)< x) {
      if(r== a) break;
      a= r;
    }else {
      if(r== b) break;
      b= r;
    }
  }
  return r; // math_root(3, x);
}//~math_cbrt()
</SCRIPT><SCRIPT>
//METRIC SYSTEM:
MetricType= new Enum(["centimeter", "cm", "meter", "m", "inch", "point", "pt"]);

function metric_sys(x, type_from, type_to, bRevert) {
  if(bRevert) {var tmp= type_from; type_from= type_to; type_to=tmp;}
  var mt= MetricType;
  switch(type_from) {
    case mt.cm:
    case mt.centimeter: {
      switch(type_to) {
         case mt.inch: return cm2inch(x);
         default: return undefined;
      }
    }break;
    case mt.inch: {
      switch(type_to) {
         case mt.cm:
         case mt.centimeter: return inch2cm(x);
         case mt.pt:
         case mt.point: return inch2pt(x);
         default: return undefined;
      }
    }break;
    case mt.pt://point (typography) PDF
    case mt.point: {
      switch(type_to) {
        case mt.inch: return pt2inch(x);
      };
    }break;
    default: return undefined;
  }
}//~metric_sys()

function inch2cm(x) {return (2.54* x);}
function cm2inch(x) {return (x/ 2.54);}

function pt2inch(x) {return (0.013835* x);}//point (typography)
function inch2pt(x) {return ((1/ 0.013835)* x);}//~72



</SCRIPT><SCRIPT>
function get_PI() { // return an approximation for PI= 3.141592653589793...
   function _tan(x) { // some of my finest work
      if(x< 0) return -_tan(-x);
      if(x== 0.0) return 0.0;
      var i, t;
      i= 0;
      while(x> Math.DELTA) {
        x/= 2;
        i++;
      }
      while(i--) {
         t= x;
         x= 2* t/ (1- t* t);
      }
      return x;
   }//~_tan()
   var i, dx, t, at;
   t= 1.0;                       // tan(PI/ 4)= 1.0 (easy)
   at= 3.0/ 4.0;                 // first approximation of atan(tan(PI/4)) (a quarter of three point something...)
   dx= 1.0;                      // first step
   while(dx>= Math.DELTA) {
      dx/= 2.0;                  // refine step
      if(_tan(at+ dx)>= t) continue; // not good, maybe next time...
      at+= dx;                   // step forward (next approximation)
   }
   dx= t- _tan(at);
   if(dx== Math.DELTA) at= (2.0* at+ dx)/ 2.0; // polishing
   return (4.0* at);
}//~get_PI()

function get_PI0002() { // return an approximation for PI= 3.141592653589793...
   function _tan(x) { // some of my finest work
      if(x< 0) return -_tan(-x);
      if(x== 0.0) return 0.0;
      var i, t;
      i= 0;
      while(x> Math.DELTA) {
        x/= 2;
        i++;
      }
      while(i--) {
         t= x;
         x= 2* t/ (1- t* t);
      }
      return x;
   }//~_tan()
   function _atan(x) {//Foloseste formula de aproximare "f(x)~= f(x0)+ f'(x0)(x- x0)" Manualul de AnalizaMatematica clasa a XI-a
     var steps= 0;//dbg
     var t, at, fd;
     fd= 1/ (1+ x* x);//f'(x): in teorie ar trebui sa fie f'(x0), dar atata timp cat procesul este convergent, oricum, x0 tinde catre x
     t= fd* x;
     do {
       at= t;
       t= t+ fd* (x- _tan(t));
       steps++;//dbg
     }while(t!= at);
     echo('steps:'+ steps);//dbg
     return at;
   }//~_atan()
   return 4.0* _atan(1.0);//"tan(PI/ 4)= 1.0 => PI= 4.0* atan(1.0)"
}//~get_PI0002()

function _tan(x) {
   if(fabs(x)> Math.PI/ 4.0) undefined; // incompleta
   if(x< 0) return -_tan(-x);
   if(x== 0.0) return 0.0;
   if(x== Math.PI) return 0.0;
   var i, t;
   i= 0;
   while(x> Math.DELTA) {
      x/= 2;
      i++;
   }
   while(i--) {
      t= x;
      x= 2* t/ (1- t* t);
echo(i+ ': '+ x); // _tan(deg2rad(360))
   }
   return x;
}

/*
function _sin(x) { // [incompleta]
   var t;
   t= _tan(x);
   return (t/ _sqrt(1+ t* t));
}

function _cos(x) { // [incompleta]
   var t;
   t= _tan(x);
   return (1/ _sqrt(1+ t* t));
}
*/

function _sin(x) { // [incompleta]
   var t;
   t= _tan(x/ 2.0);
   return (2.0* t/ (1.0+ t* t));
}

function _cos(x) { // [incompleta]
   var t2;
   t2= _tan(x/ 2.0);
   t2*= t2;
   return ((1.0- t2)/ (1.0+ t2));
}

function _ctan(x) {
   if(x) return (1.0/ _tan(x));
   return Infinity;
}

window.get_PI= get_PI;
window._tan= _tan;
window._sin= _sin;
window._cos= _cos;
window._ctan= _ctan;

</SCRIPT><SCRIPT>
function sincosT(t) {//a reparameterized circle (0.0<= t<= 1.0)
  //use only "the idea" of sine and cosine (Because sines, cosines, and tangents are interdependent. And we're not computing the tangent.)
  function u(t) {//a parabola (fast), if you want more accuracy use higher degree polynomials (we're actually simulating a tangent function)
    var m;
    m= Math.SQRT2- 1;//constant
    m+= m;
    m+= m;
    t= t* (t* (2- m)+ m- 1);
    return t;
  }

  ////function u(t) {return interpolate_quadratic(0, tan(rad(45/ 2)), 1, interpolate_easy(0, 1, t));}//dbg
  ////function u(t) {return interpolate_easy(0, 1, interpolate_quadratic(0, tan(rad(45/ 2)), 1, t));}//dbg
  ////function u(t) {return easyT(interpolate_quadratic(0, tan(rad(45/ 2)), 1, t));}//dbg

  //function u(t) {return interpolate_quadratic(0, tan(rad(45/ 2)), 1, t);}//a parabola
  //function u(t) {return interpolate_cubic(0, tan(rad(1/ 3* 45)), tan(rad(2/ 3* 45)), 1, t);}
  //function u(t) {return interpolate([0, tan(rad(1/ 4* 45)), tan(rad(2/ 4* 45)), tan(rad(3/ 4* 45)), 1], t);}
  //function u(t) {return interpolate([0, tan(rad(1/ 5* 45)), tan(rad(2/ 5* 45)), tan(rad(3/ 5* 45)), tan(rad(4/ 5* 45)), 1], t);}
  //function u(t) {return interpolate([0, tan(rad(1/ 6* 45)), tan(rad(2/ 6* 45)), tan(rad(3/ 6* 45)), tan(rad(4/ 6* 45)), tan(rad(5/ 6* 45)), 1], t);}
  //function u(t) {return interpolate([0, tan(rad(1/ 7* 45)), tan(rad(2/ 7* 45)), tan(rad(3/ 7* 45)), tan(rad(4/ 7* 45)), tan(rad(5/ 7* 45)), tan(rad(6/ 7* 45)), 1], t);}
  //function u(t) {return interpolate([0, tan(rad(1/ 8* 45)), tan(rad(2/ 8* 45)), tan(rad(3/ 8* 45)), tan(rad(4/ 8* 45)), tan(rad(5/ 8* 45)), tan(rad(6/ 8* 45)), tan(rad(7/ 8* 45)), 1], t);}
  //function u(t) {return t;}//dbg (fastest but quite crude)
  var s, c, t2, d;
  if(t< 0.5) {//I- II
    if(t<= 0.25){//Quadrant I
      t+= t; t+= t;
      t= u(t);//rearrange the points on the circle more or less equidistant (so to speak)
      t2= t* t;
      d= 1/ (1+ t2);//(atan(t))'
      s= d* (t+ t);//sine
      c= d* (1- t2);//cosine
    }else {//Quadrant II
      t-= 0.25;
      t+= t; t+= t;
      t= 1- t;
      t= u(t);
      t2= t* t;
      d= 1/ (1+ t2);
      s= d* (t+ t);
      c= -d* (1- t2);
    }
  }else {//III-IV
    if(t<= 0.75) {//Quadrant III
      t-= 0.50;
      t+= t; t+= t;
      t= u(t);
      t2= t* t;
      d= 1/ (1+ t2);
      s= -d* (t+ t);
      c= -d* (1- t2);
    }else {//Quadrant IV
      t-= 0.75;
      t+= t; t+= t;
      t= 1- t;
      t= u(t);
      t2= t* t;
      d= 1/ (1+ t2);
      s= -d* (t+ t);
      c= d* (1- t2);
    }
  }//I-II-III-IV
  return [s, c];
}//~sincosT()

function circle2point(cx, cy, r, t, u) {
  switch(arguments.length) {
    case 1: {
      u= 1.0;
      t= arguments[0];
      r= 1.0;
      cy= 0.0;
      cx= 0.0;
    }break;
    case 2: {
      u= 1.0;
      t= arguments[1];
      r= arguments[0];
      cy= 0.0;
      cx= 0.0;
    }break;
    case 3: {
      u= arguments[2];//ray's fraction; interval [0.0 .. 1.0]
      t= arguments[1];//arc's angle (normalized: eg. not in degrees or radians); interval: [0.0 .. 1.0]
      r= arguments[0];//circle's radius
      cy= 0.0;        //center's ordinate
      cx= 0.0;        //center's abscissa
    }break;
    case 4: {
      u= 1.0;
    }break;
  }
  var sc, x, y;
  var sc= sincosT(t);
  x= interpolate_linear(cx, cx+ r* sc[1], u);
  y= interpolate_linear(cy, cy+ r* sc[0], u);
  return new Point2D(x, y);
}//~circle2point()

</SCRIPT><SCRIPT>

function _cos(x) { // aproximeaza functia cosinus (NETERMINATA)
   var DELTA= Math.DELTA;
   var f, t, i, xp;
   var x= parseFloat(arguments[0]);
   //if(x> PI) x = PI+ mod(x, PI); //hmm..
   xp= -x* x;
   i= 2;
   f= t= 1.0;
   while(fabs(t/ f)> DELTA) {
      t*= xp/ i/ (i- 1); // t*= xp/ (i* (i- 1));
      f+= t;
      i+= 2;
   }
   if(f< -1.0) f= -1.0;//_cos(deg2rad(180)), _cos(deg2rad(-180))
   if(f> 1.0) f= 1.0;//_cos(deg2rad(-360)- Math.DELTA* 6), _cos(deg2rad(360)+ Math.DELTA*6)
   return f;   // "deg2rad(90)= 1.5707963267948965" ; "cos(deg2rad(90))= 6.123031769111886e-17";"_cos(deg2rad(90))= 4.264794050055452e-17"
}

//rad2deg(acos(_cos(deg2rad(90))))= 90

function _sin(x) { // aproximeaza functia sinus (NETERMINATA)
   var DELTA= Math.DELTA;
   var f, t, i, xp;
   var x= parseFloat(arguments[0]);
   xp= -x* x;
   i= 3;
   f= t= x;
   while(fabs(t/ f)> DELTA) {
      t*= xp/ (i* (i- 1));
      f+= t;
      i+= 2;
   }
   if(f< -1.0) f= -1.0;//_sin(deg2rad(-90))
   if(f> 1.0) f= 1.0;//_sin(deg2rad(90))
   return f;
}

function _pi() { // calculeaza cu aproximatie numarul PI (PI aprox.= 3.141592653589793)
   var DELTA= Math.DELTA;
   var p0, p1, t, i;
   p0= 0;
   p1= 1;
   t= 0;
   i= 3;
   //j= 1; //dbg
   DELTA= 1.0e-6; // pentru DELTA= 1.0e-6 afla pi= 3.1415919999999997 in 500000 de iteratii
   while(fabs(p1- p0)> DELTA){
      t= (t<0)? (1/ i): (-1/ i); //pow(-1, j)/ i
      p0= p1;
      p1= p0+ t;
      i+= 2;
      //j++; //dbg
   }
   p1= floor(p1/ DELTA)* DELTA;
   return (4* p1); // pentru DELTA= 1.0e-7 afla pi= 3.1415927999999997 in 5000000 de iteratii
}


window._cos= _cos;
window._sin= _sin;
window._pi= _pi;
/*
function test_sincos() {
 var i, eps, delta;
 //delta= 1.0e-7;
 delta= Math.DELTA* 10;
 echo('sin tolerance:'+ delta);
 for(i= 360-3; i<= 360; i++) {
   eps= fabs(asin(sin(deg2rad(i)))- asin(_sin(deg2rad(i))));
   if(eps> delta) {//failed
      echo(i+ ' :\t _sin: '+ _sin(deg2rad(i))+ '\t sin: '+ sin(deg2rad(i)));
   }
 }
 delta= Math.DELTA* 1000;
 echo('cos tolerance:'+ delta);
 for(i= -360; i<= 360; i++) {
   eps= fabs(acos(cos(deg2rad(i)))- acos(_cos(deg2rad(i))));
   if(eps> delta) {//failed
      echo(i+ ' :\t _cos: '+ rad2deg(acos(_cos(deg2rad(i))))+ '\t cos: '+ rad2deg(acos(cos(deg2rad(i)))));
   }
 }
}

test_sincos();
*/
/* (C) */
function _tan(x) { // evalueaza tangenta în punctul x utilizând reprezentarea cu fractii continue
   var DELTA= Math.DELTA;
   var a, b, p, pm, pp, q, qm , qp;
   if(x== 0.0) return x;
   pm= 0.0; p= x; a= 1.0;
   qm= 1.0; q= 1.0; b= -x*x;
   while(fabs(1.0- (pm* q)/ (p* qm))> DELTA) {
      a+= 2.0;
      pp= a* p+ b* pm; pm= p; p= pp;
      qp= a* q+ b* qm; qm= q; q= qp;
   }
   return (p/ q);
}

function _exp(x) { // evalueaza exponentiala în punctul x din dezvoltarea ei în serie
   var DELTA= Math.DELTA;
   var absx, f, t, i;
   i= 1;
   f= t= 1.0;
   absx= fabs(x);
   while(fabs(t/ f)> DELTA) {
      t*= absx/ (i++);
      f+= t;
   }
   return (x>= 0.0? f: 1.0/ f);
}

function _ln(x) { // logaritm natural [NETERMINATA] (de testat)
   if(x< 0.0) return NaN;
   else if(x== 0.0) return -Infinity;
   if(x> 2.0) return -_ln(1/ x);
//   if((x< -2.0)|| (x> 2.0)) return undefined;  // serie definita pe intervalul -1< x< 1
var steps= 374+ 1; // o imensitate de iteratii (convergenta EXTREM de lenta  pasi insuficienti)
  var a, b, ps, s, t, i;
  x-= 1.0; // _ln(1+ x):= serie convergenta (deci x:= argumentul(x)- 1)
  s= x;
  t= 1.0;
  i= 1.0;
  a= 1.0;
  b= x;
  do { // seria convergenta
     i+= 1.0;
     t*= -1.0;
     a= 1/ i;
     b*= x;
     ps= s;
     s+= t* a* b;
if(!steps--){echo('_ln: [BP1]'); break; };
  } while(fabs(ps- s)> Math.DELTA);
  return s;
}//~_ln()

window._tan= _tan;
window._exp= _exp;
window._ln= _ln;

//x= 30, 360, dtan(deg2rad(90))
function dtan(x) { //debug the _tan function
   return '\n tan:'+ tan(x)+ '\n_tan:'+ _tan(x)+ '\nerr:'+ (tan(x)- _tan(x));
}
window.dtan= dtan;

function _pow(a, b) {
   return exp(b* log(a));
}

function horner(a, x) { //evalueaza un polinom [p] de ordinul [n] cu coeficienti reali [a(i)] în punctul [x] (schema lui Horner)
   var p, i; // n= a.length;
   i= a.length- 1;
   p= a[i];
   while(--i >= 0) p= p* x+ a[i];
   return p; // "horner([.21, .45], .5) = 0.435"
}

/* (C) */
function integral(a, b, f) { // calculeaza integrala functiei [f] pe intervalul [a, b] (formula lui Simpson)
   var DELTA= Math.DELTA* 2; // hmm..
   var KMAX= 27; // adĂ˘ncime
   var h, s, s0, sum, t, t0, i, k, n;
   if(typeof(f)== 'string') f= new Function("var x= arguments[0]; return("+ f+ ');')
   h= b- a;
   n= 1;
   s0= t0= 0.5* h* (f(a)+ f(b));
   for(k= 1; k<= KMAX; k++) {
      sum= 0.0;
      for(i= 1; i<= n; i++) sum+= f(a+ (i- 0.5)* h);
      t= 0.5* (t0+ h* sum);
      s= (4* t- t0)/ 3;
      if(fabs(s- s0)<= DELTA* fabs(s)) break;
      h*= 0.5;
      n*= 2;
      s0= s;
      t0= t;
   }
//   if(k>= KMAX) return null; // a atins limita arbitrara impusa // echo(integral(0, 1, 'sqrt(x)'));//== 2/ 3 ~= 0.6666666666666
   return s; // "integral(1, E, 'log(x)* log(x)')= 0.7182818284590446 (should be approx. 0.71828182867017, or 286565/398959)"
}//~integral()

window.horner= horner;
window.polinomial= horner;
window.integral= integral;

function isUnsignedInteger(x) {
  xi= parseInt(x);
  if(isNaN(xi)|| ((xi!= x))) return false;
  var xf= parseFloat(x);
  if(xf< 0) return false;
  if(xi!= xf) return false;
  return true;
}

function isPrime(x) { // prime number
   function ODD(x) { // odd number
      if(x% 2) return true;
      else     return false;
   }
   var x= parseInt(arguments[0]);
   if(x> 1) {
      if(ODD(x)) {
         var n= round(sqrt(x));
         for(var i= 3; i<= n; i+= 2)
            if(x% i== 0) return false;
         return true;
      }else return (x== 2); // only 2 is even & a prime number
   }else return false;
}

function factor(x) {//prime factorization of a natural number
  // -- 2008 -- a JavaScript modified version (under GPL, version 2) of "`factor.c' by Ray Gardner -- 1985 -- public domain; Modified Feb. 1989 by Thad Smith > public domain"
  function push_all(d, k) {
    v.push(d);
    if (k> 1) {
      k--;
      while(k--) v.push(d);
    }
  }
  var v= [];
  var d;
  var k;
  if (fmod(x, 1.0)!= 0.0) {
    SetLastError(["factor: "+ x+ " is not an integer.", ErrorPrimeFactorization.NotAnInteger, get_call_stack(arguments.callee)]);
    return [];
  }
  if (x< 2.0) {
    SetLastError(["factor: "+ x+ " is less than 2.", ErrorPrimeFactorization.LessThanTwo, get_call_stack(arguments.callee)]);
    return [];
  }
  //original:
  //d= x+ 1;     /* test for roundoff error */
  //if ((x+ 3)!= (d+ 2)) {

  //a novel idea(?):
  if((x- 1)== (x+ 2)) {// :) "RESOLUTION"
  //if(x!= parseInt(x)) {//relax
    SetLastError(["factor: "+ x+ " is too large to process.", ErrorPrimeFactorization.TooLarge, get_call_stack(arguments.callee)]);
    return [];// factor(0xFFFFFFFFFFFFFFFF);
  }else {
    d= 2;
    for (k= 0; fmod(x, d)== 0.0; k++) x/= d;
    if (k)  push_all(d, k);
    for (d= 3; d* d<= x; d+= 2) {
      for (k= 0; fmod(x, d)== 0.0; k++) x/= d;
      if (k) push_all(d, k);
    }
    if(x!= 1) v.push(x);
  }
  return v;// "factor(13333333333333): 13 1025641025641"
}//~factor()

/*
factor(1025641025641+ 1): 2,512820512821
factor(512820512821+ 3): 2,2,2,2,64102564103
factor(64102564103- 1): 2,32051282051
factor(1333333333333333): 1333333333333333
*/

function isRelativelyPrime(a, m) {
  if(!((a>= 1)&& (m>= 2))) return false;
  return(gcd(a, m)== 1);
}

function euler_phi(m) {//"Count numbers relatively prime with m."
  var u, v, i, j, k, n;
  if(m<= 1) return undefined;
  v= factor(m);//factor should return a sorted array, but sort anyway, just to be sure
  shell_sort(v);//we need this, next, to compute the powers of each unique prime
  u= [];
  for(i= 0, k= 0; v.length; i++) {
    if(!k) {
      j= v.pop();
      k++;
    }else {
      if(v[v.length- 1]== j) {
        v.pop();
        k++;
      }else {
        u.push([j, k]);
        k= 0;
      }
    }
  }
  u.push([j, k]);//tuples: [prime_pi, power_ei]
  n= 1;
  while(u.length) {
    i= u.pop();
    n*= pow(i[0], i[1])- pow(i[0], i[1]- 1);
  }
  return n;
}//~euler_phi()


/*
function testPrimeNumbers() {
   var n= 10000;
   var primes= new Array();
   for(var i= 0; i< n; i++)
      if(isPrime(i)) primes[primes.length]= i;
   echo('(', primes.length, ') prime numbers found in [0 .. ', n,']:\n', primes, '.');
}
testPrimeNumbers();
*/

/*
  chr(123) == ord('{')
*/
function chr(_ord){ return String.fromCharCode(_ord)}
function ord(_chr){ return _chr.charCodeAt(0)}
function abs(a){ return  (a>=0)?a:-a}//SEE ALSO:abs32 (integers only), fabs (floats)
function sgn(a){ return (a>=0)?1:-1}
function sign(a) {
   if(a== 0) return 0;
   return (a>= 0)? 1: -1;
}
function trunc(x) {
   var x= parseFloat(arguments[0]);
   return parseInt(x);
}
function trim(str) {
  if(!str) return '';
  var re= /^\s*(\S+(\s+\S+)*)\s*$/;
  var tmp = str.match(re);
  return (tmp== null)? '': tmp[1];
}

function _strlen(s) {return (isNull(s)|| (typeof(s.length)== 'undefined'))? 0: s.length;}
function _strcmp(s1, s2) {
        if(isNull(s1)|| (typeof(s1.length)== 'undefined')) s1= '';
        if(isNull(s2)|| (typeof(s2.length)== 'undefined')) s2= '';
        return strcmp(s1, s2);
}
function strlen(s) {return s.length;}
function strcmp(s1, s2) {
  var sLen1=strlen(s1);
  var sLen2=strlen(s2);
  s1=s1.split("");
  s2=s2.split("");
  if(sLen1==sLen2) {
    var n=sLen1;
    var i;
    for(i=0;i<n;i++)
      if(s1[i]!=s2[i])
        return (s1[i]<s2[i])?-1:1;
    return 0;
  }else {
    return (sLen1<sLen2)?-1:1;
  }
}
function strrev(s) { // string in reverse order
   s= s.split('');
   s.reverse();
   s= s.join('');
   return s;
}

function strdup(s, n) { // duplicate [n] times the string [s] [NETERMINATA] (ineficienta)
  var sd= s;
  for(var i= 0; i< n; i++) {
    sd+= s;
  }
  return sd;
}

function substr(str, start, len) {//return part of string
  if(start< 0) start= strlen(str)+ start;
  if(len< 0) len= (strlen(str)- start)+ len;
  if(len== undefined) return str.substr(start);//[FF3] bug-fix
  return str.substr(start, len);
}

function strpos(haystack, needle, offset) {//Find position of first occurence of a string (return -1 for none)
  return haystack.indexOf(needle, offset);
}

function strstr(haystack, needle) {//Find first occurence of a string
  var start= strpos(haystack, needle);
  if(start== -1) return '';
  return haystack.slice(start);
}

function strtok(str, tokens) {//Tokenize string
  var k, i, n;
  var k= [str];
  tokens= tokens.split('');
  while(tokens.length) {
    var token, nk;
    token= tokens.pop();
    nk= [];
    while(k.length) {
      str= k.pop();
      var kk= str.split(token);
      kk.foreach("if(strlen(v[i])) lParam.push(v[i])", nk);
      //nk.reverse();//fun :)
    }
    k= nk;
    k.reverse();
  }
  k.reverse();
  return k;//"strtok("a1;a2;a3,a4,a5 a6 a7: a8: a9::::::::", "; :,");"
}//~strtok()

function crlf2nl(str) {//remove carriage return characters from string
  var re= /(\r)+/;
  while(re.test(str)) str= str.replace(re, '');
  return str;
}//~crlf2nl()

function toArray() {
   a= new Array();
   for(var i= 0; i< this.length; i++) {
      a[i]= this.charAt(i);
   }
   return a;
}
String.prototype.toArray= toArray;

function str_replace_all(strOld, strNew) {
  var i, j, n, str;
  if(typeof strNew== 'string') {
    if(typeof strOld== 'string') return this.split(strOld).join(strNew);
    str= this;
    n= strOld.length;
    for(i= 0; i< n; i++) {
      str= str.split(strOld[i]).join(strNew);
    }
    return str;
  }
  str= this;
  if(typeof strOld== 'string') {
    n= strNew.length;
    for(i= 0; i< n; i++) {
      str= str.split(strOld).join(strNew[i]);
    }
  }else {
    n= min(strOld.length, strNew.length);
    for(i= 0; i< n; i++) {
      str= str.split(strOld[i]).join(strNew[i]);
    }
  }
  return str;
}//~str_replace_all()

String.prototype.replace_all= str_replace_all;

function str_indent(n) { // increase indent [NETERMINATA] (decrease indent; tabs..)
  var s= this.lines();
  s= s.foreach('v[i]= lParam+ v[i]', strdup(' ', n- 1));
  return s.join('\n');
}
String.prototype.indent= str_indent;

function str_lines(delimiter, bNonEmpty, bRelaxed) { // "var x='line1#line2#line3'; x.lines('#')"
  if (typeof delimiter == "undefined") {
      delimiter = "\n";
      if(bRelaxed== undefined) bRelaxed= true;
  }
  if(bNonEmpty) {
    var str, needle, nOffset;
    str= this;
    if((delimiter== "\n")&& bRelaxed) str= str.replace_all("\r\n", "\n").replace_all("\r", "\n");
    needle= delimiter+ delimiter;
    while(str.indexOf(needle)!= -1) {
      str= str.replace_all(needle, delimiter);
    }
    nOffset= str.length- delimiter.length;
    if(str.indexOf(delimiter, nOffset)== nOffset) str= str.slice(0, nOffset);
    if(str.indexOf(delimiter)== 0) str= str.slice(delimiter.length, -1);
    return str.split(delimiter);
  }
  if((delimiter== "\n")&& bRelaxed) return this.replace_all("\r\n", "\n").replace_all("\r", "\n").split(delimiter);
  return this.split(delimiter);
}//~str_lines()

String.prototype.lines= str_lines;

function str_explode(block_length) {
  if(!block_length) return [this];
  var s, i, m, n;
  s= [];
  n= this.length;
  m= mod(n, block_length);
  n= (n- m)/ block_length;
  for(i= 0; i< n; i++)
    s[s.length]= this.slice(i* block_length, (i+ 1)* block_length);
  if(m) s[s.length]= this.slice(n* block_length);
  return s;
}//str_explode()

String.prototype.explode= str_explode;

function string_histogram() {
  function fnCompare(a, b) {
    if(a== b) {
      return 0;
    }else {
      if(a< b) {
        return -1;
      }else {
        return 1;
      }
    }
  }//~string_histogram.fnCompare()
  var c, v, s, idx, ch, cnt;
  v= [];
  c= [];
  s= this;
  if(!s.length) return [];
  do {
    idx= c.length;
    ch= s.charAt(0);
    c.push(ch);
    s= s.split(ch);
    cnt= s.length- 1;
    s= s.join('');
    v[idx]= sprintf("%08X", cnt)+ '-'+ sprintf("%04X", ord(ch));//ord(ch);
    //echo(v[idx]);    //echo(ch+ '('+ ord(ch)+ '): '+ cnt);//dbg
  } while(s!= '');
  v= v.sort(fnCompare);//shell_sort(v);
  v= v.reverse();
  v.foreach("v[i]= v[i].split('-'); v[i][0]= parseInt(v[i][0], 16); v[i][1]= chr(parseInt(v[i][1], 16))");
  return v;
}//~string_histogram()

String.prototype.histogram= string_histogram;

/*
function foo() {
  var s, v, n, len;
  s= buffer_get(0);
  n= s.length;
  len= [0];
  v= s.histogram();
  v.foreach('lParam[0]+= v[i][0]', len);
  v.foreach("echo(v[i][0]+ '\\t\\''+ v[i][1]+ '\\''+ '\\t('+ ord(v[i][1])+ ')')");
  echo('character count: '+ len[0]+ ((len[0]== n)? '== ': ' ')+ n);
}//~foo()
*/
function array(/* ... */)
{
   var i;
   var _array= new Array(array.arguments.length);
   for(i=0; i<array.arguments.length; i++)
      _array[i]= array.arguments[i];
   return _array;
}

function vector_first(value) {
  if(arguments.length) {
    var i= arguments.length;
    while(--i>= 0) this.splice(0, 0, arguments[i]);
    return this.length;
  }
  return this.splice(0, 1)[0];
}
function vector_last(value) {
  if(arguments.length) {
    var i= arguments.length;
    while(--i>= 0) this.push(arguments[i]);
    return this.length;
  }
  return this.pop();
}
function vector_split(offset, bEncode) {
  var a, b;
  offset= parseInt(offset);
  if(bEncode) offset= this.length- offset;
  a= this.splice(0, offset);
  b= this.splice(0, this.length);
  this.length= 0;
  this.splice(0, 0, a, b);//this[0]= a;  this[1]= b;
  //delete this;
  return this;
}//~vector_split()

Array.prototype.first= vector_first;
Array.prototype.last= vector_last;
Array.prototype.split= vector_split;

function _array_prepend(item) {
   var n= arguments.length;
   var i= 0;
   while(i< n) {
      this.splice(0, 0, arguments[n- ++i]);
   }
   return this.length;
}

Array.prototype.prepend= _array_prepend;

function _array_append(item) {
   var n= arguments.length;
   var i= 0;
   while(i< n) {
      this[this.length]= arguments[i++];
   }
   return this.length;
}

Array.prototype.append= _array_append;

/*
//BUG! (original vector is left unchanged)
function _array_remove(index) { // "var x= [-1, -3, -13, -7].remove(2) := [-1, -3, -7]"
  var a;
  if(index) a= this.slice(0, index);
  else return this.slice(1);
  return a.concat(this.slice(index+ 1));
}
*/
function _array_remove(index) { // "var x= [-1, -3, -13, -7].remove(2) := [-1, -3, -7]"
  this.splice(index, 1);
  return this;
}


Array.prototype.remove= _array_remove;

/*
//BUG! (original vector is lost)
function _array_insert(index, element) { // "[-3, -1, 0, 1, 2].insert(1, -2) := [-3, -2, -1, 0, 1, 2]"
  if(!index) return [element].concat(this);
  var a= this.slice(0, index);
  a.append(element);
  return a.concat(this.slice(index));
}
*/

function _array_insert(index, element) {// "[-3, -1, 0, 1, 2].insert(1, -2) := [-3, -2, -1, 0, 1, 2]"
  this.splice(index, 0, element);
  return this;
}


Array.prototype.insert= _array_insert;

function _array_clone() { // make a clone array
        var a, i;
        a= [];
        for(i in this) a[i]= this[i];
        return a;
}

Array.prototype.clone= _array_clone;

function _array_keys() {
  var v= [];
  for(var i in this) v.push(i);
  return v;
}

Array.prototype.keys= _array_keys;

function _array_dump(bCustom) {
  function tuple_sort_func(a, b) {
    a= parseInt(a[0]);//because ten is greater than two
    b= parseInt(b[0]);
    if(a== b) {
      return 0;
    }else {
      if(a< b) {
        return -1;
      }else {
        return 1;
      }
    }
  }
  var v= [];
  if(!bCustom) {
    for(var i in this) v.push([i, this[i]]);
  }else { // dump [key, value] tuples only for keys in range [0.. SOME_BIG_INT] then reindex and throw the keys
    if(!this.length) return v;
    for(var i in this) {// retain only unsigned integer keys and non undefined values
      if((this[i]!= undefined)&& (isUnsignedInteger(i))) v.push([i, this[i]]);
    }
    v.sort(tuple_sort_func);
    var n= v.length;
    //for(var i= 0; i< n; i++) v[i][0]= i; // reindex (redundant: we throw the keys anyhow)
    for(var i= 0; i< n; i++) v[i]= v[i][1];// throw the keys
  }
  return v; //"var x= [1, 2, undefined, 4, 5];var y= x.dump(true);y[2]== 4"
}//~_array_dump()

Array.prototype.dump= _array_dump;

function _array_lsearch(key, fCompare) {//linear-search
  var v, compare, i, retVal;
  function _compare(a, b) {
    if(a== b) return 0;
    if(a< b) return -1;
    return 1;
  }
  if(typeof(fCompare)!= 'function') {
    if(typeof(fCompare)== 'string') {compare= new Function('a', 'b', fCompare);}
    compare= _compare;
  }else {
    compare= fCompare;
  }
  v= this;
  for(i= 0; i< v.length; i++) {
    retVal= compare(key, v[i]);
    if(!retVal) return i;
  }
  return null;//"[1, 3, 5, 7].lsearch(5)== 2"
}//~_array_lsearch()

Array.prototype.lsearch= _array_lsearch;

function _array_bsearch(key, fnCompare) {//binary-search
  var v, compare, left, center, right, index, steps, retVal;
  function _compare(a, b) {
    if(a== b) return 0;
    if(a< b) return -1;
    return 1;
  }
  if(typeof(fnCompare)!= 'function') {
    if(typeof(fnCompare)== 'string') {compare= new Function('a', 'b', fnCompare);}
    compare= _compare;
  }else {
    compare= fnCompare;
  }
  steps= 0;
  v= this;
  index= null;
  right= this.length- 1;
  left= 0;
  if((right<= 0)|| (left> right)) return index;
  do {
    steps++;
    center= floor((left+ right)/ 2);
    retVal= compare(key, v[center]);
    switch(retVal) {
      case(-1): {
        right= center;
      break;}
      case(1): {
        left= center;
      break;}
      case(0): {
        index= center;
        return index;
      break;}
      default: {
        SetLastError(['bsearch: compare: Unexpected return value '+ retVal+ '!', Errors.InvalidReturnValue, get_call_stack()]);
        left= right;
      break;}
    }
  }while((left!= right)&& (steps< 1024));
  return index;//"[1, 3, 5, 7].bsearch(5)== 2"
}//~_array_bsearch()

Array.prototype.bsearch= _array_bsearch;

function ListMRU(nSize) {//a List of Most Recently Used items
  function add(item) {
    if(this.v.length== this.length) this.v.first();
    this.v.push(item);
  }
  function items() {return this.v;}//get the items kept in the list
  function count() {return this.v.length;}
  function resize(nSize) {//how many items to keep in the list
    this.length= nSize;
    this.v.length= min(this.v.length, nSize);
  }
  this.v= [];
  this.length= nSize;
  this.add= add;
  this.count= count;
  this.resize= resize;
  this.items= items;
  return this;
}//~ListMRU()

//function max(a,b){ return (a>b)?a:b}
//function min(a,b){ return (a<b)?a:b}
function min(/* ... */)
{
   var i;
   var _min= min.arguments[0];
   for(i=1; i<min.arguments.length; i++)
      if(_min > min.arguments[i]) _min= min.arguments[i];
   return _min;
}
function max(/* ... */)
{
   var i;
   var _max= max.arguments[0];
   for(i=1; i<max.arguments.length; i++)
      if(_max < max.arguments[i]) _max= max.arguments[i];
   return _max;
}

function limits() { // for the the input array of integers, returns the the min& max limits
   var s= arguments;
   if(arguments.length== 1)
      if(arguments[0].constructor== Array) s= arguments[0];
   var a= new Array(2);
   if(s.length!= 0) {
      var x= parseInt(s[0]);
      a[0]= x- 1;
      a[1]= x+ 1;
      var n= s.length;
      for(var i= 0; i< n; i++) {
         x= parseInt(s[i]);
         if(x<= min(x, a[0])) a[0]= x- 1;
         if(x>= max(x, a[1])) a[1]= x+ 1;
      }
   }
   return a;
}

function selection_sort(v) { // metoda de sortare
   var i, j, n, tmp, min;
   n= v.length;
   for(i= 0; i< n; i++) {
      min= i;
      for(j= i+ 1; j<= n; j++)
         if(v[j]< v[min]) min= j;
      tmp= v[min];
      v[min]= v[i];
      v[i]= tmp;
   }
   return v;
}

function bubble_sort(v) { // works for a homogenous array of strings or floats and/or integers
   var i, n, b, aux;
   n= v.length;
   do {
      b= true;
      for(i= 1; i< n; i++) {
         if(v[i]< v[i-1]) {
            aux= v[i-1];
            v[i-1]= v[i];
            v[i]= aux;
            b= false;
         }
      }
   } while(!b);
   return v;
}

function shell_sort(v, bPermutation) { // metoda de sortare prin micşorarea incrementului (bubble-sort îmbunătăţit)
   var i, n, k, b, aux, u;
   n= v.length;
   k= n;
   if(!k) return [];
   if(k<= 1) {//nothing to do
     if(bPermutation) {
	   return [0];
	 }else {
	   return v;
	 }
   }
   if(bPermutation) {
     u= range(n);
     do {
        k>>= 1;
        do {
           b= true;
           for(i= 0; i<= n- k; i++)
              if(v[u[i]]> v[u[i+ k]]) { //v[i]= v[i]+ v[i+ k]- (v[i+ k]= v[i]);
                 aux= u[i+ k];
                 u[i+ k]= u[i];
                 u[i]= aux;
                 b= false;
              }
        } while(!b);
     } while(k!= 1);
     return u;
   }else {
      do {
          k >>= 1;
          do {
              b = true;
              for (i = 0; i <= n - k; i++) {
                  if (v[i] > v[i + k]) {
                      aux = v[i + k];
                      v[i + k] = v[i];
                      v[i] = aux;
                      b = false;
                  }
              }
          } while (!b);
      } while (k != 1);
      return v;
   }
}//~shell_sort()

function quick_sort(v) { // metoda de sortare quicksort (logaritmica)
   var threshold= 13;
   function _quick_sort(v, left, right) {
      function _partition() {
         var x, lt, rt;
         x= v[left];
         lt= left- 1;
         rt= right+ 1;
         while(1) {
            do{rt--; } while(v[rt]> x);
            do{lt++; } while(v[lt]< x);
            if(lt< rt) {
                var tmp= v[rt];
                v[rt]= v[lt];
                v[lt]= tmp;
            }else
              return rt;
         }
      }
      function _selection_sort(i, n) {
         var j, tmp, min;
         for(; i< n; i++) {
            min= i;
            for(j= i+ 1; j<= n; j++)
               if(v[j]< v[min]) min= j;
            tmp= v[min];
            v[min]= v[i];
            v[i]= tmp;
         }
         return v;
      }
      if(left< (right- threshold)){
         var s= _partition();
         _quick_sort(v, left, s);
         _quick_sort(v, s+ 1, right);
      }else
         _selection_sort(left, right);
      return v;
   }
   return _quick_sort(v, 0, v.length);   // for large vectors you will get only "Out of stack space!" errors
}//~quick_sort()

function merge_sort(v) {
  function _merge(A, p, q, r) {
//print(".");//dbg (Note: This function is called a constant number of times that only depends on A.length and not the contents of A.)
    var i, j, k, n1, n2, L, R;
    n1= q- p+ 1;
    n2= r- q;
//echof("p q r ; n1 n2: %s %s %s ; %s %s", p, q, r, n1, n2);//dbg
    L= new Array(n1+ 1);
    R= new Array(n2+ 1);
    for(i= 0; i< n1; i++) L[i]= A[p+ i];
    for(j= 0; j< n2; j++) R[j]= A[q+ j+ 1];
    L[n1]= Infinity;//sentinel
    R[n2]= Infinity;//ditto
//echof("%s L[%s] R[%s]", q, L, R);//dbg
    i= 0;
    j= 0;
    for(k= p; k<= r; k++) {
      if(L[i]<= R[j]) {
        A[k]= L[i];
        i= i+ 1;
      }else {
        A[k]= R[j];
        j= j+ 1;
      }
    }
//echof("A: [%s]\n", A);//dbg
  }//~merge_sort._merge()
  function _merge_sort(A, p, r) {
    var q;
    if(p< r) {
      q= floor(0.5* (p+ r));
      _merge_sort(A, p, q);
      _merge_sort(A, q+ 1, r);
//echof("p q r: %s %s %s", p, q, r);//dbg
      _merge(A, p, q, r);
    }
  }//~merge_sort._merge_sort()
  _merge_sort(v, 0, v.length- 1);
  return v;
}//~merge_sort()

function sum(/* ... */)
{
   var i;
   var _sum= sum.arguments[0];
   for(i=1; i<sum.arguments.length; i++)
      _sum+= sum.arguments[i];
   return _sum;
}
function avg(/* ... */)
{
   var i;
   var _avg= 0;
   for(i=0; i<avg.arguments.length; i++)
      _avg += avg.arguments[i]/avg.arguments.length;
   return _avg;
}

function standard_deviation(v) { // calculate the [standard deviation] for the elements of vector [v]
   var i, n, nm1, average, sum, sqsum, stddev;
   n= v.length;
   nm1= n- 1;
   if(!nm1) return 0.0;
   sum= 0.0;
   sqsum= 0.0;
   for(var i= 0; i< n; i++) {
      sum+= v[i];
      sqsum+= v[i]* v[i];
   }
   average= sum/ n;
   stddev= sqrt((sqsum- n* average* average)/ nm1);
   //return [average, stddev]; // an array with two elements [ovarall average (first), standard deviation (second)]
   return stddev;
}

function binary_search(a, b, f, lParam) {//"SIMPLE YET NUMERICALLY STABLE"
  var x, y;
  while (fabs(a- b)> Math.DELTA) {//TODO:scale & translate (back & forth): [0, Math.RESOLUTION] & [a, b].
    x= (a+ b)/ 2;
    y= f(x, lParam);
    switch(y) {
      case -1: b= x; break;
      case  0: return x;
      case  1: a= x; break;
    }  
  }
  return a;
}//~binary_search()

/*
  lagrange interpolating polynomial:
    input: (arguments)
     - v: [[t0, x0], [t1, x1], ..., [tn, xn]] (for a degree n polynomial in t)
     - t: time:
          - in [t0, tn] interval: interpolate
          - else: extrapolate
   output: "f(t)= x"
     - xt: the interpolated/extrapolated value at time t
*/
function lagrange (v, t, bInverse) { // the lagrange interpolating polynomial of (v.length- 1) degree (eg. for v[i][0] return v[i][1], else interpolate, else extrapolate)
  var n, y, j, i, s, p;
  n= v.length;
  s= 0.0;
  if(bInverse) {
    for(i= 0; i< n; i++) {
      p= 1.0;
      for(j= 0; j< n; j++) {
        if(i!= j) {
          p*= (t- v[j][1])/ (v[i][1]- v[j][1]);
        }
      }
      s+= v[i][0]* p;
    } // "lagrange([[1, 2], [3, 4], [5, 6]], .23, true);= -0.77"
    return s; // inverse lagrange interpolator
  }else {
    for(i= 0; i< n; i++) {
      p= 1.0;
      for(j= 0; j< n; j++) {
        if(i!= j) p*= ((t- v[j][0])/ (v[i][0]- v[j][0]));
      }
      s+= v[i][1]* p;
    }
    return s; // "lagrange([[1, 3], [2, 4], [3, 7]], 4.0);= 12.0"
  }
}//~lagrange()

function interpolate_classic(v, t) {//Newton's interpolation formula (better than Lagrange in terms of arithmetic operation count)
  var a, p, i, j, n;
  n= v.length- 1;
  //compute the coefficients for the interpolating polynomial (classic interpolation method: linear correlation factor)
  a= [];
  for(i= 0; i<= n; i++) {
    a[i]= v[i][1];
  }
  for(i= 1; i<= n; i++) {
    for(j= n; j>= i; j--) {
      a[j]= (a[j]- a[j- 1])/ (v[j][0]- v[j- i][0]);
    }
  }
  //evaluate the polynomial using one generalization of Horner's rule
  i= n;
  p= a[i];
  while(--i>= 0) {
    p= p*(t- v[i][0]) + a[i];
  }
  return p; // "interpolate_classic([[1, 3], [2, 4], [3, 7]], 4.0);= 12.0"
}//~interpolate_classic;

function interpolate(v, t, vt) {//parametric interpolation; t:= [0.. 1]; vt: nonlinear correlation factor (normalized)
  var n, m, p, i;
  n= v.length; // n- 1 degree interpolating polynomial
  m= v[0].length; // m-dimensional point (m-dimensional parametric interpolation)
  if(arguments.length< 3) {//use a linear correlation factor (classic interpolation method)
    vt= range(1, n+ 1, 1);
    vector_normalize(vt);
  }//else:
  if(m== undefined) {//the unidimensional case
    var vxy= vector_copy(vt);
    vxy.foreach("v[i]= [v[i], lParam[i]]", v);//convert a 1D vector to a 2D vector because the classic interpolation scheme is 2D
    p= interpolate_classic(vxy, t);//lagrange(vxy, t);
    return p;
  }
  p= [];
  for(i= 0; i< m; i++) {
    var vxy= vector_copy(vt);
    vxy.foreach("v[i]= [v[i], (lParam[1][i][lParam[0]])];", [i, v]);
    //proof that the classic interpolation method is useful even for the nonlinear correlation factor (Now I have no idea what this means :) )
    //...the "unisolvence theorem" is a dud nonetheless! (I was wrong: the "unisolvence theorem" is OK)
    p.push(interpolate_classic(vxy, t));// p.push(lagrange(vxy, t));
  }
  return p;
}//~interpolate()

function lerp(a, b, n) {
   var n= parseInt(arguments[2]);
   var a= parseFloat(arguments[0]);
   var b= parseFloat(arguments[1]);
   switch(n) {
   case 0: return null;
   case 1: return (a+ b)/ 2;
   case 2: return [a, b];
   case 3: return [a, (a+ b)/ 2, b];
   case 4:
      return [a, (2* a+ b)/ 3, (a+ 2* b)/ 3, b];
   default:
      var p= new Array(n);
      p[0]= a;
      p[--n]= b;
      for(var i= 1; i< n; i++) {
         p[i]= ((n- i)* a+ i* b)/ n;
      }
      return p;
   }
}
function stripe(base, steps, step) {
   if(arguments.length== 1) {
      var v= arguments[0];
      var a= new Array(v.length- 1);
      var n= a.length;
      for(var i= 0; i!= n; i++) {
         a[i]= abs((abs(parseFloat(v[i]))- abs(parseFloat(v[i+ 1]))));
      }
      return a;
   }else {
      var base= parseFloat(arguments[0]);
      var step= parseFloat(arguments[2]);
      var n= parseInt(arguments[1]);
      p= new Array(n);
      for(var i=0; i<= n; i++) {
         p[i]= i* step+ base;
      }
      return p;
   }
}

function range(start, stop, step) { // emulate the PYTHON range function
   var t= arguments.length;
   if(t== 1) stop= start;
   if(t< 2) start= 0;
   if(t< 3) step= 1;
   var r= [];
   if(step== 0) return r;
   if(step> 0) {
      if(start>= stop) return r;
   }else {
      if(start<= stop) return r;
   }
   var n= ceil( fabs(start- stop)/ fabs(step));
   for(var i= 0; i< n; i++) {
      r[i]= start+ i* step;
   }
   return r;
}

function hex(nr)
{
  nr=parseInt(nr, 10);
  if(isNaN(nr)) {
    SetLastError(['hex: Function argument 1 is NaN!', Errors.InvalidArgument, get_call_stack()]);
    return '????????';
  }
  var hex_digits= new Array('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
  var i, hex_nr="0x";
  for(i= 7; i >= 0; i--){
    hex_nr+= hex_digits[(nr >> (i*4)) & 0xF];
  }
  return hex_nr;
}

function oct(nr) {
   return '0'+ floor(abs(nr)).toString(8);
}

function bin(nr) {
   return floor(abs(nr)).toString(2)+ 'b';
}

function base_convert(x, fromBase, toBase) {//convert a number between arbitrary bases
  return parseInt(x, fromBase).toString(toBase);
}
function decbin(x) {return x.toString(2);}
function bindec(x) {return parseInt(x, 2);}
function decoct(x) {return x.toString(8);}
function octdec(x) {return parseInt(x, 8);}
function dechex(x) {return x.toString(16);}
function hexdec(x) {return parseInt(x, 16);}

function bin2dec(a) {
  return parseInt(a, 2).toString(10);
}
window.dec2bin= decbin;

function gcd(n, m) { // Greatest Common Divisor
   var n= parseInt(arguments[0]);
   var m= parseInt(arguments[1]);
   if(n< 0) n= -n;
   if(m< 0) m= -m;
   while(true) {
      if( m ) n %= m; else return n;
      if( n ) m %= n; else return m;
   }
}

function lcm(n, m) { // Least Common Multiple
   var n= parseInt(arguments[0]);
   var m= parseInt(arguments[1]);
   if(!n || !m) return 0;
   n /= gcd(n, m); n *= m;      // lcm( n, m ) == ( n * m ) / gcd( n, m )
   if(n< 0) n= -n;
   return n;
}
cmmdc= gcd; // Cel Mai Mare Divizor Comun
cmmmc= lcm; // Cel Mai Mic Multiplu Comun
function and(a, b) {return (a& b)}
function or (a, b) {return (a| b)}
function not(a)    {return (~a  )}
function xor(a, b) {return (a^ b)}
function rol(x, n) {return rol32(x, n)}
function ror(x, n) {return ror32(x, n)}
function rev(x)    {return rev32(x)}
function sar(x, n) {return (x>> n)} // bitwise shift arithmetic right
function shr(x, n) {return (x>>> n);} // bitwise shift right
function shl(x, n) {return (x<< n)} // bitwise shift left

function mod(a, b) {
   if(arguments.length!= 2) return undefined;
   var a= parseFloat(arguments[0]);
   var b= parseFloat(arguments[1]);
   return (a% b);
}

function div(a, b) {
   if(arguments.length!= 2) return undefined;
   var a= parseFloat(arguments[0]);
   var b= parseFloat(arguments[1]);
   return (a/ b);
}

function modinv32(a, b) {//Extended Euclidean Algorithm for modular inverse: (((a* _a_)% b) == 1)
  var a0, b0, t0, t, r;
  b0= b;
  a0= (a% b);
  t0= 0;
  t= 1;
  q= floor(b0/ a0);
  r= b0- q* a0;
  while(r) {
    var tmp= t0- q* t;
    if(tmp >= 0) {
      tmp= tmp% b;
    }else {
      tmp= b- ((-tmp)% b);
    }
    b0= a0;
    a0= r;
    t0= t;
    t= tmp;
    q= floor(b0/ a0);
    r= b0- q* a0;
  }
  if(a0!= 1) return 0; //undefined; //a nu are inversÄ mod b
  return t; // a^-1 (mod b) = t
}//~modinv32()

function sqr(x) {return x*x;}
function hypot(x, y) {return _hypot(x, y);}

// 1 rad= 57 deg 17 min 45 sec

/*
function deg2rad(x) {
   var x= parseFloat(arguments[0]);
   if((x>= 0 && x<= 360.0)|| (x<= 0 && x>= -360.0))
      return ((Math.PI* x)/ 180)
   else
      return undefined;
}
*/
function deg2rad(x) {
   var x= parseFloat(arguments[0]);
   x= fmod(x, 360.0+ Math.DELTA* 129.0);
   return ((Math.PI* x)/ 180)
}

function rad2deg(x) {
   var x= parseFloat(arguments[0]);
   if((x>= 0 && x<= deg2rad(360))|| (x<= 0 && x>= deg2rad(-360)))
      return ((x/ Math.PI)* 180)
   else
      return undefined;
}
rad= deg2rad;

function rgb2intensity(r, g, b) { // INTENSITY=(r* 0.30+ g* 0.59+ b* 0.11+ 0.01)
   return ((r* 77+ g* 150+ b* 29)>> 8);//round((77* r+ 150* g+ 28* b)/ 255);
}
function rgb2alpha(r, g, b, bInvert, bPHPgd) {//"black: opaque"
  var intensity, alpha;
  intensity= rgb2intensity(r, g, b);//"intensity: 0 black; 255 white"
  if(!bPHPgd) {
    alpha= intensity;
    if(bInvert) alpha= 255- alpha;
    return alpha;
  }
  alpha= floor(intensity/ 2);//"alpha: 0 opaque; 127 transparent"
  if(bInvert) alpha= 127- alpha;
  return alpha;
}//~rgb2alpha()

window.color_intensity= rgb2intensity;
</SCRIPT><SCRIPT>
//
//and, or, not, xor
//

function unsigned8(x) {
  var AL;
  AL= x;

  AL&= 0xFF;
  AL>>>= 0;

  return AL;
}

function signed8(x) {
  var AL;
  AL= x;

  AL<<= 24;
  AL>>= 24;

  return AL;
}

function unsigned16(x) {
  var AL;
  AL= x;

  AL&= 0xFFFF;
  AL>>>= 0;

  return AL;
}

function signed16(x) {
  var AL;
  AL= x;

  AL<<= 16;
  AL>>= 16;

  return AL;
}

function unsigned32(x) {
  var EAX;
  EAX= x;

  EAX>>>= 0;

  return EAX;
}//~unsigned32()

function signed32(x) {
  var EAX;
  EAX= x;

  EAX>>= 0;

  return EAX;
}//~signed32()

function inc32(x) {
  var EAX;
  EAX= x;

  EAX++; //INC EAX

  return signed32(EAX);
}//~inc32()

function dec32(x) {
  var EAX;
  EAX= x;

  EAX--; //DEC EAX

  return signed32(EAX);
}//~dec32()

function add32(x, y) {//Add integers, wrapping at 2^32. (uses 16-bit operations internally)
  var lsw= (x& 0xFFFF)+ (y& 0xFFFF);
  var msw= (x>> 16)+ (y>> 16)+ (lsw>> 16);
  return (msw<< 16)| (lsw& 0xFFFF);
}

function abs32(x) {//calculate the absolute value of a signed 32bit number without branching
  var EAX, EDX;
  EAX= x;

  EDX= EAX; //MOV EDX, EAX
  EDX>>= 31;//SAR EDX, 31
  EAX^= EDX;//XOR EAX, EDX
  EAX-= EDX;//SUB EAX, EDX

  return EAX;
}//~abs32()

function neg32(x) {
  var EAX;
  EAX= x;

  EAX= ~EAX;//NOT EAX
  EAX= inc32(EAX);

  return EAX;
}//~neg32()

function odd32(x) {
  var EAX;
  EAX= x;

  EAX&= 1;

  return EAX;
}//~odd32()

function even32(x) {
  return ((~odd32(x))& 1);
}//~even32()

function flipflop32() {
  var t;
  t= abs32(dec32(arguments.callee.t));
  arguments.callee.t= t;
  return t;
}//~flipflop32()

/*
function foo() {
  var v= range(256);
  v.foreach('v[i]= signed8(v[i])');
  echo(v);
  echo();
  v.foreach('v[i]= unsigned8(v[i])');
  echo(v);
}//~foo()

foo();
*/
</SCRIPT><SCRIPT>
function mul32(u16, v16) {//"a* b= 0.5* (sqr(a)+ sqr(b)- sqr(a- b))" "Three superfast FFT's in parallel?"
  var a32, b32, c32, EAX;
  u16= unsigned16(u16);
  v16= unsigned16(v16);
  a32= uint32(sqr(u16));//"sqr(x) is a special case of mul(x, x); and for it there is a special/faster case of FFT"
  b32= uint32(sqr(v16));
  c32= uint32(sqr(abs32(u16- v16)));
  EAX= shr64(sub64(add64([a32, 0], [b32, 0]), [c32, 0]), 1)[0];
  return EAX;
}//~mul32()

function add64(u64, v64, vcr1) {//Add 64bit integers, wrapping at 2^64. (might use 32-bit operations internally)
  var r, cr;
  r= [];
  r[0]= add32(u64[0]& 0xFFFF, v64[0]& 0xFFFF);
  cr= r[0]>> 16;
  r[0]&= 0xFFFF;

  r[1]= add32((u64[0]>> 16)& 0xFFFF, (v64[0]>> 16)& 0xFFFF);
  r[1]= add32(r[1], cr);
  cr= r[1]>> 16;
  r[1]&= 0xFFFF;

  r[2]= add32(u64[1]& 0xFFFF, v64[1]& 0xFFFF);
  r[2]= add32(r[2], cr);
  cr= r[2]>> 16;
  r[2]&= 0xFFFF;

  r[3]= add32((u64[1]>> 16)& 0xFFFF, (v64[1]>> 16)& 0xFFFF);
  r[3]= add32(r[3], cr);
  cr= r[3]>> 16;
  r[3]&= 0xFFFF;

  //if(cr) {var bOverflow= true;}  //alert("Carry: "+ hex(cr));//dbg

  if(arguments.length>= 3&& vcr1.length) vcr1[0]= cr;//return carry bit;

  return [uint32((r[1]<< 16)| (r[0]& 0xFFFF)), uint32((r[3]<< 16)| (r[2]& 0xFFFF))];
}//~add64()

function sub64(u64, v64, vcr1) {
  if(arguments.length>= 3) {
    return add64(u64, neg64(v64), vcr1);
  }else {
    return add64(u64, neg64(v64));
  }
}//~sub64()

function inc64(u64, vcr1) {
  var v64;
  if(arguments.length>= 2) {
    v64= add64(u64, [1, 0], vcr1);
  }else {
    v64= add64(u64, [1, 0]);
  }
  return v64;
}//~inc64()

function dec64(u64, vcr1) {
  var v64;
  if(arguments.length>= 2) {
    v64= sub64(u64, [1, 0], vcr1);
  }else {
    v64= sub64(u64, [1, 0]);
  }
  return v64;
}//~dec64()

function neg64(u64) {
  var v64;
  var EAX, EBX;
  EAX= u64[0];
  EBX= u64[1];

  EAX= ~EAX;//NOT EAX
  EBX= ~EBX;

  v64= inc64([uint32(EAX), uint32(EBX)]);
  return v64;
}//~neg64()

function and64(u64, v64) {
  return [uint32(u64[0]& v64[0]), uint32(u64[1]& v64[1])];
}//~and64()

function or64(u64, v64) {
  return [uint32(u64[0]| v64[0]), uint32(u64[1]| v64[1])];
}//~or64()

function not64(u64) {
  return [uint32(~u64[0]), uint32(~u64[1])];
}//~not64()

function xor64(u64, v64) {
  return [uint32(u64[0]^ v64[0]), uint32(u64[1]^ v64[1])];
}//~xor64()

function abs64(u64) {//calculate the absolute value of a signed 64bit number without branching
  var a64, b64, EDX;
  a64= u64;                           //";load eax"
  //b64= [a64[0], a64[1]];            //MOV EDX, EAX
  EDX= (and(a64[1], 0x80000000)>> 31);//
  b64= [uint32(EDX), uint32(EDX)];    //SAR EDX, 63
  a64= xor64(a64, b64);               //XOR EAX, EDX
  a64= sub64(a64, b64);               //SUB EAX, EDX  //a64= add64(a64, neg64(b64));        //SUB EAX, EDX
  return a64;
}//~abs64()

function odd64(u64) {
  return and64(u64, [1, 0]);
}//~odd64()

function even64(u64) {
  return and64(not64(odd64(u64)), [1, 0]);
}//~even64()

function sar64(u64, n) {
  var v64, EAX, EBX, CX, DX;
  n&= 0x3F;//n%= 64;
  if(!n) {//Note: "sarX(aX, 0)== sarX(aX, X)"
    v64= [u64[0], u64[1]];
  }else
  if(n>= 32) {
    EAX= sar(u64[1], 31);
    v64= [uint32(shr(u64[1], n- 32)), uint32(EAX)];
    if(EAX) {
      EBX= not(shr(EAX, n& 31));
      v64[0]= uint32(v64[0]| EBX);
    }
  }else {
    CX= n& 31;
    DX= 32- CX;
    EAX= uint32((u64[1]& shr(~0, DX))<< DX);
    v64= [uint32((shr(u64[0], CX))| EAX), uint32(sar(u64[1], CX))];
  }
  return v64;
}//~sar64()

function shr64(u64, n) {
  var v64, EAX, CX, DX;
  n%= 64;
  if(!n) {//Note: "shrX(aX, 0)== shrX(aX, X)"
    v64= [u64[0], u64[1]];
  }else
  if(n>= 32) {
    v64= [uint32(shr(u64[1], n- 32)), 0];
  }else {
    CX= n& 31;//n% 32;//n& 31;
    DX= 32- CX;//Note: "(CX== 0) is a special case which is handled elseware."
    EAX= uint32((u64[1]& ((~0)>>> DX))<< DX);
    v64= [uint32((u64[0]>>> CX)| EAX), uint32(u64[1]>>> CX)];
  }
  return v64;
}//~shr64()

function shl64(u64, n) {
  var v64, EAX, CX, DX;
  n%= 64;
  if(!n) {//Note: "shlX(aX, 0)== shlX(aX, X)"
    v64= [u64[0], u64[1]];
  }else
  if(n>= 32) {
    v64= [0, uint32(shl(u64[0], n- 32))];
  }else {
    CX= n& 31;//n% 32;//n& 31;
    DX= 32- CX;//Note: "(CX== 0) is a special case which is handled elseware."
    EAX= uint32((u64[0]& ((~0)<< DX))>>> DX);
    v64= [uint32(u64[0]<< CX), uint32((u64[1]<< CX)| EAX)];
  }
  return v64;
}//~shl64()

function ror64(u64, n) {
   n%= 64;//"Note: (n%= 64)=== (n&= 0x3F) but the second form is faster."
   return or64(shr64(u64, n), shl64(u64, (64- n)));
}

function rol64(u64, n) {
   n%= 64;//n&= 0x3F;
   return or64(shl64(u64, n), shr64(u64, (64- n)));
}

function bswap64(u64) {"byte swap: change register endianness"
  var v64= [bswap32(u64[1]), bswap32(u64[0])];
  return v64;
}//~bswap64()

function bsf64(u64) {//"bit scan forward"
  var ZF, i, vy;
  vy= bsf32(u64[0]);
  ZF= vy[0];
  if(ZF) return vy;
  vy= bsf32(u64[1]);
  ZF= vy[0];
  i= vy[1]+ 32;
  return [ZF, (ZF&& i)];//"return ZF flag and an index to the first set bit"
}//~bsf64()

function bsr64(u64) {//"bit scan in reverse"
  var ZF, i, vy;
  vy= bsr32(u64[1]);
  ZF= vy[0];
  i= vy[1]+ 32;
  if(ZF) return [ZF, (ZF&& i)];
  vy= bsr32(u64[0]);
  return vy;//"return ZF flag and an index to the first set bit"
}//~bsr64()

function shld32(u32, v32, n) {//"double precision shift left"
  var u64= [v32, u32];
  n&= 31;//only the first 5 bits
  u32= shl64(u64, n)[1];
  return u32;
}//~shld32()

function shrd32(u32, v32, n) {//"double precision shift right"
  var u64= [u32, v32];
  n&= 31;//only the first 5 bits
  u32= shr64(u64, n)[0];
  return u32;
}//~shrd32()

function uint64(u64) {//"use only unsigned int components (helper function to validate user input)"
  u64[0]= uint32(u64[0]);
  u64[1]= uint32(u64[1]);
}//~uint64()

function eq64(u64, v64) {//"equal"
  //return (!neq64(u64, v64));
  return ((u64[0]== v64[0])&& (u64[1]== v64[1]));
}

function neq64(u64, v64) {//"not equal"
  //return (!eq64(u64, v64));
  return ((u64[0]!= v64[0])|| (u64[1]!= v64[1]));;
}

function lt64(u64, v64, bFast) {//"less than (64bit unsigned int)"
  if(!bFast) {
    uint64(u64);
    uint64(v64);
  }
  if(u64[1]< v64[1]) return true;
  if(u64[1]> v64[1]) return false;
  if(u64[0]< v64[0]) return true;
  return false;
}//~lt64()

function gt64(u64, v64, bFast) {//"greater than (64bit unsigned int)"
  if(!bFast) {
    uint64(u64);
    uint64(v64);
  }
  if(u64[1]> v64[1]) return true;
  if(u64[1]< v64[1]) return false;
  if(u64[0]> v64[0]) return true;
  return false;
}//~gt64()

function lte64(u64, v64) {//"less than or equal (64bit unsigned int)"
  if(eq64(u64, v64)) return true;
  return lt64(u64, v64);
}//~lte64()

function gte64(u64, v64) {//"greater than or equal (64bit unsigned int)"
  if(eq64(u64, v64)) return true;
  return gt64(u64, v64);
}//~gte64()

function min64() {
  var i;
  var callee= arguments.callee;
  var _min64 = callee.arguments[0];
  for (i= 1; i< callee.arguments.length; i++) {
    if (gt64(_min64, callee.arguments[i])) {
      _min64 = callee.arguments[i];
    }
  }
  return _min64;
}//~min64()


function max64() {
  var i;
  var callee= arguments.callee;
  var _max64= callee.arguments[0];
  for (i= 1; i< callee.arguments.length; i++) {
    if (lt64(_max64, callee.arguments[i])) {
      _max64= callee.arguments[i];
    }
  }
  return _max64;
}//~max64()

function clip64(x64, _min64, _max64) {
  return max64(min64(x64, _max64), _min64);
}

function mul64(u32, v32) {//"Multiply two 32bit unsigned int registers into one 64bit unsigned int register."
  var u0, u1, v0, v1;
  var a32, b32, c32, cr;
  var p32_0, p32_1, p32_2, p32_3;

  var a0, a1, b0, b1, c0, c1;
  var w0, w1, w2, w3, w32_0, w32_1, w64;

  //"unpack"
  u0= u32& 0xFFFF;
  v0= v32& 0xFFFF;
  u1= (u32>>> 16)& 0xFFFF;
  v1= (v32>>> 16)& 0xFFFF;

  //"the only four costly 32bit multiplies"
  //p32_0= uint32(u1* v1);  p32_1= uint32(u1* v0);  p32_2= uint32(u0* v1);  p32_3= uint32(u0* v0);
  p32_0= mul32(u1, v1);
  p32_1= mul32(u1, v0);
  p32_2= mul32(u0, v1);
  p32_3= mul32(u0, v0);

  c32= (p32_3);
  w64= add64([p32_1, 0], [p32_2, 0]);//b32= (p32_1+ p32_2);
  b32= w64[0];
  a32= (p32_0);

  //cr= ((b32- uint32(b32))* (1/ 0x10000));//"get carry bit (always zero or one, times 0x10000)" (kludge: a costly floating point multiply)
  //cr= ((((b32- uint32(b32))- 0xFFFFFFFF)== 1)<< 16);//"get carry bit (always zero or one, times 0x10000)"
  cr= uint32(w64[1]<< 16);
  a32+= cr;//"propagate carry"
  //a32= uint32(a32);
  //b32= uint32(b32);
  //c32= uint32(c32);

  //"some simple shifting and adding operations"
  c0= c32& 0xFFFF;
  c1= (c32>>> 16)& 0xFFFF;
  w0= c0;                 //[16bit]
  b32= add32(b32, c1);
  b0= b32& 0xFFFF;
  b1= (b32>>> 16)& 0xFFFF;
  w1= b0;                //[16bit]
  a32= add32(a32, b1);
  a0= a32& 0xFFFF;
  a1= (a32>>> 16)& 0xFFFF;
  w2= a0;                //[16bit]
  w3= a1;                //[16bit]

  //pack the result (note that we must use a vector because we don't have a native 64bit register in this javascript version)
  w32_0= uint32((w1<< 16)| w0);//low 32bits
  w32_1= uint32((w3<< 16)| w2);//high 32bits

  //echof("a 64bit result (%s:%s:%s:%s)", w3.toString(16), w2.toString(16), w1.toString(16), w0.toString(16));//dbg
  w64= [w32_0, w32_1];
  return w64;
}//~mul64()

function mul128(u64, v64) {//"Multiply two 64bit unsigned int registers into one 128bit unsigned int register."
  var a64, b64, c64, cr;
  var p64_0, p64_1, p64_2, p64_3;
  var w32_0, w32_1, w32_2, w32_3, w128;

  //"the only four costly 64bit multiplies"
  p64_0= mul64(u64[1], v64[1]);
  p64_1= mul64(u64[1], v64[0]);
  p64_2= mul64(u64[0], v64[1]);
  p64_3= mul64(u64[0], v64[0]);

  cr= [0];
  c64= (p64_3);
  b64= add64(p64_1, p64_2, cr);//"return sum and carry"
  a64= (p64_0);

  cr= [0, cr[0]];//"get carry bit (always zero or one, times 0x100000000)"
  a64= add64(a64, cr);//"propagate carry"

  //"some simple shifting and adding operations"
  w32_0= c64[0];
  b64= add64(b64, [c64[1], 0]);
  w32_1= b64[0];
  a64= add64(a64, [b64[1], 0]);
  w32_2= a64[0];
  w32_3= a64[1];

  w128= [w32_0, w32_1, w32_2, w32_3];
  return w128;
}//~mul128()

function div64(u64, v64) {//"TODO: optimize (We use the binary-search algorithm for now; but it seems we can do better.)"
  var p64, x64, y64, z64;
  var a64, a128;
  var bOverflow, i, n;

  if(lt64(u64, v64)) return zero64();
//  echof("u64[0]/ v64[0]: %08X/ %08X=  %08X", u64[0], v64[0], floor(u64[0]/ v64[0]));//dbg
  if(lte64(u64, [0xFFFFFFFF, 0])) return (uint64(x64= [floor(u64[0]/ v64[0]), 0]), x64);//"we got small values (half precision max)"

  //"binary-search algorithm"

  y64= one64();//"lower limit"
  z64= dup64(u64);//"upper limit"

  x64= shr64(add64(y64, z64), 1);;//"first approximation"
  a128= mul128(v64, x64);
  bOverflow= (a128[2]|| a128[3]);
  uint64(a64= [a128[0], a128[1]]);

  n= 64;//"compute only 64 bits"
  for(i= 0; i< n; i++) {
    if(bOverflow|| gt64(a64, u64)) {
//      echof("L: %s %s %s", hex64(y64), hex64(x64), hex64(z64));//dbg
      z64= dup64(x64);
    }else {
//      echof("R: %s %s %s", hex64(y64), hex64(x64), hex64(z64));//dbg
      y64= dup64(x64);
    }
    p64= x64;//"previous approximation"
    x64= shr64(add64(y64, z64), 1);//"next approximation"
    a128= mul128(v64, x64);
    bOverflow= (a128[2]|| a128[3]);
    uint64(a64= [a128[0], a128[1]]);
//    echof("%d: x64: %s", i, hex64(x64));//dbg
    if(eq64(p64, x64)) break;//"shortcut"
  }

  return x64;
}//~div64()

function mod64(u64, v64) {//"TODO: bSigned", "-15% 4== -3", "15% -4== 3"
  var x64;
  x64= div64(u64, v64);

  x64= mul128(v64, x64);
  x64= sub64(u64, x64);
  return x64;
}//~mod64()

function dup64(u64) {//"duplicate QWORD"
  var v64= [u64[0], u64[1]];
  return v64;
}//~dup64()

function bitget64(u64, i) {//QWORD
  if(i& (~63)) return 0;//"outside range [0..63]"
  i&= 63;
  return ((u64[i>> 5]& ((1<< (i& 31))))? 1: 0);
}//~bitget64()

function bitset64(u64, b, i) {//QWORD
  var v64, m;
  v64= dup64(u64);
  if(i& (~63)) return v64;//"if index outside of range [0..63]"
  i&= 63;
  m= uint32(((b)? 1: 0)<< (i& 31));//mask
  if(m) return v64[i>> 5]= uint32(v64[i>> 5]| m), v64;
  m= uint32(~(1<< (i& 31)));
  v64[i>> 5]= uint32(v64[i>> 5]& m);
  return v64;
}//~bitset64()

function bitxor64(u64, mb, i) { // bitwise-XOR operation on bits
  var b, v64;
  v64= dup64(u64);
  if(i& (~63)) return v64;//"if index outside of range [0..63]"
  b= bitget64(v64, i);
  return bitset64(v64, (b^ mb), i);
}//~bitxor64()

/*
function bitnot64(u64, i) { // bitwise-NOT operation on bits
  var b, v64;
  v64= dup64(u64);
  if(i& (~63)) return v64;//"index out of range"
  var b= bitget64(u64, i);
  v64= bitset64(u64, (~b), i);
  return v64;
}//~bitnot64()
*/

function bitnot64(u64, i) {return bitxor64(u64, 1, i);}

function bin64(u64) {//".toString(2) with zero padding to the left"
  return sprintf("%032s%032s", (u64[1]>>> 0).toString(2), (u64[0]>>> 0).toString(2));
}

function vector2hex(v, bStripPrefix, bDigitGrouping, n) {//"convert a big unsigned int to hexadecimal representation"
  var str, i;
  if(bDigitGrouping) bStripPrefix= true;
  str= ((bStripPrefix)? '': '0x');
  if(arguments.length< 4) n= v.length;
  n-= 1;
  for(i= 0; i<= n; i++) {
    str+= sprintf("%08X", v[n- i]);
  }
  if(bDigitGrouping) str= str.explode(4).join(' ');
  return str;
}//~vector2hex()

function hex64(u64, bStripPrefix, bDigitGrouping) {
  return vector2hex(u64, bStripPrefix, bDigitGrouping, 2);
}//~hex64()

function hex128(u128, bStripPrefix, bDigitGrouping) {
  return vector2hex(u128, bStripPrefix, bDigitGrouping, 4);
}//~hex128()

function uint642hex(u64) {
  return hex64(u64); //return sprintf("0x%08X%08X", u64[1], u64[0]);
}//~uint642hex()

function hex2uint64(x) {//BUG: under construction! (parseInt("0x123q4568AABBCCDD", 16)== 0x123)
  var v;
  x= trim(x);
  x= x.split('0x');
  if(x.length== 1) {
    x= strrev(x[0]).explode(8);
  }else {
    x= strrev(x[1]).explode(8);
  }
  if(x.length== 2) {
    v= [parseInt(strrev(x[0]), 16), parseInt(strrev(x[1]), 16)];
  }else {
    if(x.length) {
      v= [parseInt(strrev(x[0]), 16), 0];
    }else {
      v= zero64();
    }
  }
  return v;
}//~hex2uint64()

function zero64() {return [uint32(0), uint32(0)];}
function one64() {return [uint32(1), uint32(0)];}

//"fixpoint 32.32"
function zero32p32() {return zero64();}
function one32p32() {return shl64(one64(), 32);}
function half32p32() {return inc64(shr64([uint32(~0), uint32(0)], 1));}

window.mul32= mul32;//"multiply 32bit"
window.add64= add64;//"add"
window.sub64= sub64;//"subtract"
window.inc64= inc64;//"increment by one"
window.dec64= dec64;//"decrement by one"
window.neg64= neg64;//"negative"
window.and64= and64;//"bitwise and"
window.or64= or64;//"bitwise or"
window.not64= not64;//"bitwise not"
window.xor64= xor64;//"bitwise xor"
window.abs64= abs64;//"absolute value of"
window.odd64= odd64;//"odd number"//TODO: optimize!
window.even64= even64;//"even number"//TODO: optimize!
window.sar64= sar64;//"shift arithmetic right"
window.shr64= shr64;//"bitwise shift right"
window.shl64= shl64;//"bitwise shift left"
window.ror64= ror64;//"bitwise rotate right"
window.rol64= rol64;//"bitwise rotate left"
window.bswap64= bswap64;//"byte swap: change register endianness"
window.bsf64= bsf64;//"bit scan forward"
window.bsr64= bsr64;//"bit scan in reverse"
window.shld32= shld32;//"double precision shift left"
window.shrd32= shrd32;//"double precision shift right"
//TODO: "shld64();shrd64()."
window.uint64= uint64;//"use only unsigned int components (helper function to validate user input)"
window.eq64= eq64;//"equal"
window.neq64= neq64;//"not equal"
window.lt64= lt64;//"less than"
window.gt64= gt64;//"greater than"
window.lte64= lte64;//"less than or equal"
window.gte64= gte64;//"greater than or equal"
window.min64= min64;//"minimum"
window.max64= max64;//"maximum"
window.clip64= clip64;//"clip value to range"
//window.land64= land64;//"logical and"
//window.lor64= lor64;//"logical or"
//TODO: "sqr32()"
window.mul64= mul64;//"multiply 64bit"
window.mul128= mul128;//"multiply 64bit (128bit result)"
//TODO:"bSigned(div64, mod64)"
window.div64= div64;//"divide 64bit (unsigned)"
window.mod64= mod64;//"module (reminder modulo) 64bit (unsigned)"
//TODO: "modinv64()", "smodinv64()", "smod64()", "sdiv64()"
window.dup64= dup64;//"duplicate QWORD"
window.bitget64= bitget64;
window.bitset64= bitset64;
window.bitxor64= bitxor64;//"bitwise-XOR operation on bits"
window.bitnot64= bitnot64;//"bitwise-NOT operation on bits"
window.bin64= bin64;//"convert to string like .toString(2) but with padding zeros to the left"
window.vector2hex= vector2hex;//"convert a big unsigned int to hexadecimal representation"
window.hex64= hex64;
window.hex128= hex128;
window.uint642hex= uint642hex;
window.hex2uint64= hex2uint64;
//window.str2uint64= str2uint64;//TODO
//window.uint642str= uint642str;//TODO
window.zero64= zero64;//"zero"
window.one64= one64;//"one"
window.zero32p32= zero32p32;//"0.0 fixpoint 32.32"
window.one32p32= one32p32;//"1.0 fixpoint 32.32"
window.half32p32= half32p32;//"0.5 fixpoint 32.32"
</SCRIPT><SCRIPT>
function time() {return (+new Date);}
function date2string(d) {//Ziua Luna Ziua(zz) Ora(hh:mm:ss) Anul
  var s, strDay, strMonth;
  if(!arguments.length) d= new Date;
  strDay= 'SunMonTueWedThuFriSat'.explode(3);
  strMonth= 'JanFebMarAprMayJunJulAugSepOctNovDec'.explode(3);
  s= '';
  s+= strDay[d.getDay()];
  s+= ' '+ strMonth[d.getMonth()];
  s+= ' '+ d.getDate();
  s+=' '+ Math.floor(d.getHours()/10)+""+(d.getHours()%10)+":";
  s+=Math.floor(d.getMinutes()/10)+""+(d.getMinutes()%10)+":";
  s+=Math.floor(d.getSeconds()/10)+""+(d.getSeconds()%10);
  s+= ' '+ d.getUTCFullYear();
  return s;
}//~date2string()

function rawrgb(width, height, bWhiteBackground) {return strdup(((bWhiteBackground)? '\xFF': '\0'), (3* width* height- 1));}
function rawrgb_rgb2bgr(data) {return data.explode(3).foreach('v[i]= v[i].split("").reverse().join("");').join('');}
function rawrgb_bgr2rgb(data) {return rawrgb_rgb2bgr(data);}
function rawrgb_putpixel(x, y, rgb, data, width, height) {//bug: inefficient!
  x*= 3;  y*= 3;  width= abs(parseInt(width));
  var offset= y* width+ x;
  return data.substr(0, offset)+ rgb+ data.substr(offset+ 3);
}

function rawrgb2bmp(data, width, height, bBgr) {
  var raw_data, size, args, bBottomUp;
  bBottomUp= true;// [IE6] bug-fix (amazing!)
  if(!bBgr) data= rawrgb_rgb2bgr(data);
  if(bBottomUp) {data= data.explode(width* 3).reverse().join('');}
  size= 3* width* height;
  raw_data= base642string(
    'Qk0jAAAAADYAAAAoAAAAIyMBABgAAAAAACMAAAAAAAAAAAAAAAAAAAAA'
  ).split('#');
  args= [size, width, ((bBottomUp)? height: -height), size, data];
  data= '';
  for(var i= 0; i< args.length- 1; i++) {
    data+= raw_data.first()+ DWORD2string(args[i]);
  }
  data+= raw_data.first()+ args[args.length- 1];
  return data;
}//~rawrgb2bmp

function bmp2rawrgb(data) {//process "24bpp, BI_RGB" bitmaps only
  var header, width, height, bBgr, bBottomUp;
  bBgr= true;
  bBottomUp= true;
  header= substr(data, 0, 0x36);
  data= substr(data, 0x36);
  echo(data.charAt(0));//dbg
  height= DWORD2int(string2DWORD(header, 0x16));
  if(height< 0) {
    bBottomUp= false;
  }
  if(bBottomUp) {
    width= DWORD2int(string2DWORD(header, 0x12));
    data= data.explode(width* 3).reverse().join('');
  }
  if(bBgr) {data= rawrgb_bgr2rgb(data);}
  return data;
}//~bmp2rawrgb;

function rawrgb2eps(data, width, height, title) {//BUG: under construction!
  var raw_data, creator, date, args, data_size, bBottomUp;
  raw_data= base642string(
    'JSFQUy1BZG9iZS0yLjAgRVBTRi0xLjINCiUlQ3JlYXRvcjogIw0KJSVUaXRsZTogIw0KJSVDcmVh'+
    'dGlvbkRhdGU6ICMNCiUlUmVzb2x1dGlvbjogNzINCiUlQm91bmRpbmdCb3g6IDAgMCAjICMNCiUl'+
    'RG9jdW1lbnREYXRhOiBDbGVhbjdCaXQNCiUlRW5kQ29tbWVudHMNCi93aWR0aCAjIGRlZg0KL2hl'+
    'aWdodCAjIGRlZg0KL3dpZHRocHggIyBkZWYNCi9oZWlnaHRweCAjIGRlZg0KL3N0cnBpYyB3aWR0'+
    'aCBzdHJpbmcgZGVmDQovcGljdHVyZSB7DQpnc2F2ZSB3aWR0aCBoZWlnaHQgOA0KW3dpZHRoIDAg'+
    'MCBoZWlnaHQgMCBoZWlnaHQgbmVnXQ0Ke2N1cnJlbnRmaWxlIHN0cnBpYyByZWFkaGV4c3RyaW5n'+
    'IHBvcH0NCmZhbHNlIDMgY29sb3JpbWFnZSBncmVzdG9yZSB9IGRlZg0KMCBoZWlnaHQgbmVnIHRy'+
    'YW5zbGF0ZSB3aWR0aHB4IGhlaWdodHB4IHNjYWxlDQpwaWN0dXJlDQojDQolJUVPRg0K'
  ).split('#');
  bBottomUp= true;
  width= abs(parseInt(width));
  height= abs(parseInt(height));
  if(isNaN(width)) width= 0;
  if(isNaN(height)) height= 0;
  if(title== undefined) title= 'undefined';
  creator= 'ScriptX 0.13';
  date= date2string(new Date);
  data_size= width* height* 3;
  if(strlen(data)!= data_size) {
    data+= strdup('\0', data_size- strlen(data)- 1);
  }
  if(bBottomUp) {
    data= data.explode(width* 3).reverse().join('');
  }
  args= [
    escape(creator), escape(title), date, width, height, width, height,
    width, height, string2hex(data).explode(width* 3* 2).join(''.CRLF)
  ];
  data= '';
  for(var i= 0; i< args.length; i++) {data= data+ raw_data.first()+ args[i];}
  data= data+ raw_data.pop();
  return data;
}//~rawrgb2eps()

/*
function foo() {
  var data, width, height;
  width= 16;
  height= 16;
  data= rawrgb(width, height, true);
  for(var i= 0; i< min(width, height); i++) {
    var x, y, color;
    x= i;
    y= i;
    color= stream2string([112, 160, 104]);//rgb color ('#70A068')
    data= rawrgb_putpixel(x, y, color, data, width, height);
  }
  var m, n;
  n= floor(min(width, height)/ 2);
  m= min(width, height)- 1;
  for(var i= 0; i< n; i++) {
    var x, y, color;
    x= m- i;
    y= i;
    color= stream2string([0, 0, 255]);//red
    data= rawrgb_putpixel(x, y, color, data, width, height);
  }
  data= rawrgb2eps(data, width, height, 'n/a');
  echo(data);//dbg
  file_put_contents('image.eps', data);
}//~foo()
*/
</SCRIPT><SCRIPT>
function math_reciprocal(x) {//"div(1.0, x)" a brute-force approach
  var MAX_STEPS= 128; //dbg  [guard aganist infinite-loops] arbitrary value (a influence on the output resolution)
  var steps= MAX_STEPS; //dbg
  if(!x){
    SetLastError(["math_reciprocal: Division by Zero!", ErrorMath.DivisionByZero, get_call_stack(arguments.callee)]);
    return NaN;
  }
  var bFractional= false;
  if((x<= 1.0)&& (x> 0)) {
    bFractional= true;
  }
  var bNegative= false;
  if(x< 0.0) {
    bNegative= true;
    x*= -1.0;
  }
  var sup, inf, t, y; //binary-search
  if(bFractional) {
    inf= 0.0;
    sup= Math.RESOLUTION- 1;
    y= 0.5* (inf+ sup);//first approximation
  } else {
    inf= 0.0;
    sup= 1.0;
    y= 0.5;//first approximation
  }
  t= x* y;
  while(t!= 1.0) {// "((x/ x)== 1.0)"
    if(t> 1.0) {
       if(sup== y) break;
       sup= y;
    } else {
       if(inf== y) break;
       inf= y;
    }
     y= 0.5* (sup+ inf);//next approximation
     t= x* y;
     if(!--steps) break;//dbg
     //echo(y);//dbg
  }
  if(bNegative) y*= -1.0;
  //echo('math_reciprocal: x: '+ x+ ' steps: '+ (MAX_STEPS- steps)+ ' reciprocal: '+ y);//dbg
  return y; //"(a/ b)== (a* math_reciprocal(b))"
}//~math_reciprocal() "Some of my finest work!"

function math_e() {//constanta lui Euler (baza logaritmului natural "e== exp(1.0)" )
  var prev_fact= 1;
  function _fact(x) {
    prev_fact*= x;
    return prev_fact;
  }
  var i= 1;
  var t;
  var e= 1.0; //0! (first term of the series)
  do {
    t= math_reciprocal(_fact(i++)); // 1.0/ i! (next term)
    e+=  t;
  } while(Math.DELTA< t);
  return e; //"(((Math.E- math_e())<= Math.DELTA)== true)"
}//~math_e()
</SCRIPT>
<SCRIPT>
/*
  PageLineAt return a String
  _p: page number [0..9] //a multiline String
  _n: line number [0..PageLineCount(_p)]
*/
function PageLineAt(_p,_n){
 var s=_txt_[_p];
 if(typeof(s)=='undefined') return "";
 s=s.split("\n");
 if(_n<=s.length-1){
   return s[_n];
 }else{
   return "";
 }
}
/*
  PageLineCount return a Number
  _p: page number [0..9] //a multiline String
*/
function PageLineCount(_p){
 var s=_txt_[_p];
 if(typeof(s)=='undefined') return 0;
 s=s.split("\n");
 return(s.length);
}

/*
  PageLines return an Array
  _p: page number [0..9] //actually the button number
*/
function PageLines(_p){
 var s=_txt_[_p];
 if(typeof(s)=='undefined') return new Array(0);
 s=s.split("\n");
 return s;
}
/*
alert("Lines: "+PageLineCount(1));
alert(PageLineAt(1,1));
alert(PageLines(1)[1]);
*/
</SCRIPT>
<SCRIPT>
function Matrix(m,n){
  if(!Matrix._default) Matrix._default=0;
  switch(Matrix.arguments.length){
    case 0:{
     return this;
    }
    case 1:{ //square
     n=m;
    }
    case 2:{ //bidimensional
     var _Matrix=new Array(m);
     var i,j;
     for(i=0;i<m;i++){
       _Matrix[i]=new Array(Matrix.arguments[1]);
       for(j=0;j<n;j++){
         _Matrix[i][j]=Matrix._default;//++;
       }
     }
     break;
    }
    default:{ //multidimensional
     var _Matrix=new Array(Matrix.arguments[0]);
     for(i=0;i<m;i++){
      aux="_Matrix["+i+"]=Matrix(";
      for(j=1;j<Matrix.arguments.length-1;j++){
        aux+=Matrix.arguments[j]+",";
      }
      aux+=Matrix.arguments[j];
      aux+=");";
      eval(aux);
     }
     break;
    }
  }
  delete i,j;
  return _Matrix;
}//~Matrix()
/*
var x= new Matrix(4); //same as: var x=new Matrix(4,4);

Matrix._default=13;
var m= new Matrix(2, 5, 4); //m[a][b][c]
for(a= 0; a< m.length; a++) {
  for(b= 0; b< m[0].length; b++) {
    for(c= 0;c< m[0][0].length; c++) {
      print(m[a][b][c]+ " ");
    }
    echo();
  }
  echo();
}
*/
</SCRIPT>
<SCRIPT>
function KeyboardBindings(vBindings) {
  var previousBindings= window.KeyState[1];
  if(vBindings) {
    window.KeyState[1]= vBindings;
  }
  return previousBindings;
}

function KeyboardBind(keyCode, fn, bIgnorePreviousFn) {
  var fnPrevious= getKeyFunc(keyCode);
  if(!bIgnorePreviousFn) {
    if(!fn._fnPrevious) {
      if(fnPrevious) {
        fn._fnPrevious= fnPrevious;
      }
    }
  }
  KeyboardBindings()[keyCode]= fn;
  return fnPrevious;
}//~KeyboardBind()

function KeyboardUnbind(keyCode, bIgnorePreviousFn) {
  var fnPrevious= getKeyFunc(keyCode);
  if(!bIgnorePreviousFn) {
    if(fnPrevious) {
      if(fnPrevious._fnPrevious) {
        KeyboardBindings()[keyCode]= fnPrevious._fnPrevious;
      }else {
        KeyboardBindings()[keyCode]= undefined;
      }
    }
  }else {
    KeyboardBindings()[keyCode]= undefined;
  }
  return fnPrevious;
}//~KeyboardUnbind()
function KeyboardState(keyCode, bState) {
  var bPreviousState= window.KeyState[0][keyCode];
  if(arguments.length>= 2) {
    window.KeyState[0][keyCode]=(bState==true);
  }
  return bPreviousState;
}//~KeyboardState()
function KeyboardIgnoreNext(keyCode) {arguments.callee._keyCode= keyCode;}
function setKeyState(keyCode,state){  window.KeyState[0][keyCode]=(state==true);}
function setKeyFunc(keyCode, fn){ window.KeyState[1][keyCode]=fn;}
function getKeyFunc(keyCode){  return window.KeyState[1][keyCode];}
function getKeyState(keyCode){  return window.KeyState[0][keyCode];}
function docOnKeyDown(event) {
  event= bugfix_event(event);
  var keyCode= event.keyCode;
  //panic('key down: to ignore: '+ KeyboardIgnoreNext._keyCode);//dbg
  if(KeyboardIgnoreNext._keyCode== keyCode) {
    //panic('Ignore keyboard input'+ keyCode);//dbg
    return;
  }else {
    delete KeyboardIgnoreNext._keyCode;
  }
  if(getKeyState(keyCode)== false) {
    setKeyState(keyCode, true);
    var fn= getKeyFunc(keyCode);
    if(typeof(fn)== 'function') fn(getKeyState(keyCode), keyCode, new Date(), event);
    //print("["+keyCode+"]");//dbg
  }
}
function docOnKeyUp(event) {
  event= bugfix_event(event);
  var keyCode= event.keyCode;
  if(KeyboardIgnoreNext._keyCode== keyCode) {
    delete KeyboardIgnoreNext._keyCode;
    return;
  }
  //panic('ignore: '+KeyboardIgnoreNext._keyCode+ ' key up: '+keyCode);//dbg
  delete KeyboardIgnoreNext._keyCode;
  setKeyState(keyCode, false);
  var fn= getKeyFunc(keyCode);
  if(typeof(fn)== 'function') fn(getKeyState(keyCode), keyCode, new Date(), event);
}
function InitKEYBOARD() {
   //window.KeyState=new Matrix(2,256);
   document.onkeydown=docOnKeyDown;
   document.onkeyup=docOnKeyUp;
}

/*
window.event.:
--------------
altKey, button, cancelBubble, clientX, clientY, ctrlKey,
fromElement, keyCode, offsetX, offsetY, reason, returnValue,
screenX, screenY, shiftKey, srcElement, srcFilter, toElement,
type, x, y
--------------
function test(state,keyCode,date,event)
{
     print("(");
     print(event.type)
     print(")");
}
KeyboardBind(9,test);//9=VK_TAB
*/
</SCRIPT>
<SCRIPT>
function VK_F12_OnEvent(state, keyCode, date, event) { // panic("F12"); setKeyFunc(VK_F12, VK_F12_OnEvent);
  if(!state) return;
   function strip_a_few_illegal_function_name_chars(s) {
      var b, i, j, n, v, v2;
      v= [
           '[', ']', '{', '}',
           '(', ')', '<', '>',
           '"', '\'', '\\', ',',
           '.', '/', ';', ':',
           '`', ' ', '~', '!',
           '@', '#', '$', '%',
           '^', '&', '*', '-',
           '+', '=', '|', '?',
           '\n'
         ];
      v2= ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
      s= s.split('');
      n= str.length;
      for(i= 0; i< n; i++) {
         for(j= 0; j< v.length; j++)
            if(s[i]== v[j]) {
               s[i]= '';
               break;
            }
      }
      b= true;
      for(i= 0; i< n; i++) {
         for(j= 0; j< v2.length; j++) {
            if(s[i]!= '')
               if(s[i]== v2[j])
                  s[i]= '';
               else if(j== v2.length- 1) {
                  b= false;
                  break;
               }
         }
         if(!b) break;
      }
      s= s.join('');
      return s;
   }
   var bIndex= buffer_active();
   if(!buffer_visible(bIndex)) { // do something else...
      return;
   }
   var str= prompt('Buffer ('+ bIndex+ ')\n Enter the name of the function to edit: ', 'foobar');
   if(isEmpty(str)) return; // nothing to do (operation cancelled by user)
   var str_type, cmd, foo;
   if(str!= '') {
      str= strip_a_few_illegal_function_name_chars(str);
      str_type= eval('typeof('+ str+ ')');
      if(str_type== 'function') {
         cmd= 'buffer_set(bIndex, "\\n"+'+ str+ '+"\\n\\n\\nwindow.'+ str+ '= '+ str+ ';")';
         eval(cmd);
      } else {
         if(str_type== 'undefined') { // create a new function
            foo= eval('new Function("'+ str+ '")');
            if(typeof(foo)== 'function') {
               cmd= 'buffer_set(bIndex, "\\nfunction '+ str+
                    '() {\\n   \\n}\\n\\n//window.'+ str+ '= '+ str+
                    ';\\n\\n//echo('+ str+ '());")';
               eval(cmd);
            }
         } else {
            panic('Error: Can\'t edit objects of this type [yet]: '+
               'typeof('+ str+ ')== \''+ eval('typeof('+ str+ ')') + '\'!');
         }
      }
   }
}//~VK_F12_OnEvent()

function VK_F11_OnEvent(state, keyCode, date, event) {//[Alt+ F11]
  //alert('F11 key pressed!');
  var obj;
  obj= event.target;
  if(!state|| !event.altKey) return;
  CloseAllWindows();// dbg
  ClearViewport();//for new drawings
}

function VK_F10_OnEvent() {
  prompt('mouse2point: ', mouse2point());
}

function VK_F7_OnEvent(state, keyCode, date, event) {
  var str, fnThis;
  fnThis= arguments.callee;
  if(fnThis._str) {
    str= fnThis._str;
  }else {
    str= '';
  }
  str= prompt('Find text:', str);
  if(str) {
    //alert(sprintf('Text to search: "%s"', str));
    fnThis._str= str;
    VK_F3_OnEvent(state, keyCode, date, event);
  }else {
    KeyboardIgnoreNext(VK_ESC);
  }
}//~VK_F7_OnEvent()
function VK_F3_OnEvent(state, keyCode, date, event) {
   var str, s, obj;
   obj = event.target;
   s= VK_F7_OnEvent._str;
   if(event.type!= 'keydown') return;
   if(obj.nodeName!= 'TEXTAREA') return;
   str= obj.value;
   if (s) {
      echo('VALUE: "'+ string2hex(str)+ '"');
      //for(var i in obj) echo(i+ ': '+ obj[i]);
   }
}//~VK_F3_OnEvent()

function VK_F1_OnEvent(state, keyCode, date, event) {
  var obj;
  obj= event.target;
  if(!state|| !event.altKey) return;
  var txt, r, height;
  r= GetClientRect();
  txt= ScriptX_getVersion().replace_all('\n', "<BR>");
  txt= "<CENTER>"+ txt+ "</CENTER>";
  height= 15* txt.lines("<BR>").length;
  if((r.bottom- r.top)< height) {
    r.bottom+= height- (r.bottom- r.top);
  }
  var wnd= CreateWindow(null, r.left, r.top, (r.right- r.left), (r.bottom- r.top), 'white', 'black', txt, true);
  wnd.onclick= new Function('this.Close()');
  wnd.onkeypress= wnd.onclick;
}

function VK_O_OnEvent(state, keyCode, date, event) {//[Alt+ O]
  var obj;
  obj= event.target;
  if(state|| !event.altKey) return;
  terminal("toggle");
}
function VK_T_OnEvent(state, keyCode, date, event) {//[Alt+ T]
  var obj;
  obj= event.target;
  if(state|| !event.altKey) return;
  but1_onclick(event);
}
function VK_S_OnEvent(state, keyCode, date, event) {//[Alt+ S]; [Alt+ X]
  var obj;
  obj= event.target;
  if(!state|| !event.altKey) return;
  but2_onclick(event);
}
function VK_H_OnEvent(state, keyCode, date, event) {//[Alt+ H]
  var obj;
  obj= event.target;
  if(state|| !event.altKey) return;
  but3_onclick(event);
}
function VK_C_OnEvent(state, keyCode, date, event) {//[Alt+ C]
  var obj;
  obj= event.target;
  if(!state|| !event.altKey) return;
  but4_onclick(event);
}
function DigitKey_OnEvent(state, keyCode, date, event) {
  var obj, BtnXOnClick;
  obj= event.target;
  if(!state|| !event.altKey) return;
  BtnXOnClick= document.getElementById("B1")._OnClick;
  BtnXOnClick(event);
}
</SCRIPT>
<SCRIPT>
function bugfix_document_body_scroll() {//bugfix:[FF4]
  if(window.document.body.scroll.toUpperCase()== 'NO') {
    DOM_setStyle(window.document.body, [['overflow', 'hidden']]);
  }else {
    //if(window.document.body.scroll.toUpperCase()!= 'YES') alert("body.scroll: assertion failed!");//dbg
    DOM_setStyle(window.document.body, [['overflow', 'scroll']]);//'visible'
  }
  return ((DOM_getStyle(window.document.body, 'overflow').toLowerCase()== 'hidden')? 'NO': 'YES');
}//~bugfix_document_body_scroll()

function toggleOptions(state, keyCode, date, event) {
  if(!event.ctrlKey) return;
  if(!state) return event.returnValue=false;
  toggle();
}
function toggle() {
  var index= buffer_active();
  if(buffer_visible(index))  buffer_refresh(index, true);
  else buffer_refresh(index);
  var layer_options= document.getElementById('layer_options');
  var layer_editor= document.getElementById('layer_editor');
  var CALC1= document.getElementById('CALC1');
  var CON1= document.getElementById('CON1');
  var BT1= document.getElementById('BT1');
  var textarea= document.getElementById('textarea');
  document.body.scroll= "NO";
  toggle.toggle=!toggle.toggle;
  if(!toggle.toggle){
    layer_editor.style.visibility='visible';
    layer_options.style.visibility='hidden';
    if(toggle.con){
        CON1.style.visibility='visible';
        textarea.style.visibility='hidden';
    }else{
        CON1.style.visibility='hidden';
        textarea.style.visibility='visible';
    }
    BT1.style.visibility='visible';

    if(textarea.style.visibility=='visible')textarea.focus();
    else CON1.focus();
  }else{
    layer_options.style.visibility='visible';
    layer_editor.style.visibility='hidden';
    if(CON1.style.visibility=='visible'){
        toggle.con= true;
    }else{
        toggle.con= false;
    }
    CON1.style.visibility='hidden';
    textarea.style.visibility='hidden';
    BT1.style.visibility='hidden';

    CALC1.focus();
    document.body.scroll= "YES";
 }
  bugfix_document_body_scroll();
  bugfix0001();//MaximizeBackgroundLayer();
}//~toggle()
</SCRIPT>
<SCRIPT>
function path_split(szPath) {
  var path;
  szPath= szPath.replace_all("\\", "/");
  while(szPath.indexOf("//", 0)!= -1) szPath= szPath.replace_all("//", '/');
  path= szPath.split('/');
  while(path[path.length- 1].length== 0) path.pop();
  return path;
}//~path_split()

function list_drives(bAvailable) { //echo(list_drives().join('\n'));
  var fso, e, d;
  fso= PObject("Transcendental", "Scripting.FileSystemObject");
  if(isNull(fso)) return [];
  e= PObject("Enumerator", fso.Drives);
  if(isNull(e)) return [];
  var l= new Array();
  var froot= new Array();
  for (;!e.atEnd();e.moveNext()) {
    d= e.item();
    var s= "";
    s= s + "[-"+ d.DriveLetter+ "-]";
    s+= "\t";
    var t;
    if(d.DriveType== DriveTypes.Network) {
      t= d.ShareName;
    }else {
      if(d.IsReady) {
        if(d.DriveType== DriveTypes.RAMDisk) {
          t= '['+ d.VolumeName+ '] (RAM Disk)';
        }else {
          t= d.VolumeName;
        }
        var free_space= ((d.TotalSize/ 1024))/((d.TotalSize/ 1024)/ (d.FreeSpace/ 1024));
        t+= "\t[FS:("+ d.FileSystem+ ")\t SIZE:("+ d.TotalSize/ 1024+" Kb)\tFREE:("+ d.FreeSpace/ 1024+ " Kb"+ ")\tSN:("+ hex(d.SerialNumber)+ ")]";
        froot[froot.length]= d.RootFolder;
      }else {
        if(d.DriveType== DriveTypes.CDROM) {
          t= "[CD-ROM]";
        }else {
          t= "[NOT Mounted]";
        }
      }
    }
    s+= t;
    l[l.length]= s;
  }
  l[l.length]= froot;
  if(bAvailable) return l[l.length - 1];
  return l;
}//~list_drives()

function list_folders(folder_name) {
  var list= new Object();
  list.folder= new Array();
  var f= TObject("Scripting.FileSystemObject");
  f= f.GetFolder(folder_name);
  list.parent= f;
  f= f.SubFolders;
  var e= PObject("Enumerator", f);
  for(var i= 0; i< f.Count; i++) {
     list.folder[i]= e.item();
     e.moveNext();
  };
  return list;
}

function list_files(folder_name) {
  var list= new Object();
  list.file= new Array();
  var f= TObject("Scripting.FileSystemObject");
  f= f.GetFolder(folder_name);
  list.folder= f;
  f= f.files;
  var e= PObject("Enumerator", f);
  var i;
  for(i= 0; i< f.Count; i++) {
     list.file[i]= e.item();
     e.moveNext()
  };
  return list;
}

function file_get_contents(file_name, bBase64) {//HOWTO:open the file 'a:\\new.b64' (a base64 encoded archive) "var s= file_get_contents('a:\\new', true);"
  var e, contents;
  try {
    //throw 0;//dbg
    if(bBase64) file_name+= '.b64';
    contents= file_block_read(file_name);
    if(contents== null) return null;
    if(bBase64) { // process mime header (UNDER CONSTRUCTION)
      contents= contents.split('\n');
      var n= contents.length;
      for(var i= 0; i< n; i++) {
        if(!strlen(trim(contents[i]))) break;
        contents[i]= '';
      }
      contents= contents.join('').replace_all(chr(13), '');
      contents= base642string(contents);
    }
    return contents;
  }catch(e){
    SetLastError(['Error: file_get_contents: '+ e.description, e.number& 0xFFFF, get_call_stack(arguments.callee), [file_name, bBase64]]);
    return null;
  }
}//~file_get_contents()

function file_put_contents(file_name, contents, bBase64) {
  var e;
  if(bBase64) { // save as a base64 encoded archive file
    var szFileName= path_split(file_name).pop();
    var szMimeHeader= 'MIME-Version: 1.0\n'+
      'Content-Type: application/octet-stream; name="'+ szFileName+ '"\n'+
      'Content-Transfer-Encoding: base64\,'+
      'Content-Disposition: attachment; filename="'+ szFileName+ '"\n\n';
    contents= string2base64(contents);
    contents= szMimeHeader+ contents;
    file_name+= '.b64';
  }
  try {
    return file_write(file_name, contents);
  } catch(e) {
    SetLastError(['Error: file_put_contents: '+ e.description, e.number& 0xFFFF, get_call_stack(arguments.callee), [file_name, contents, bBase64]]);
    return false;
  }
}//~file_put_contents()

/*
buf= file_get_contents("c:\\temp\\test.txt");
if (buf != null) {
    //..process data..
    file_put_contents("c:\\temp\\test-out.txt", buf);
}

f= list_files("temp");
echo(f.file[f.file.length- 1].Path, '[', f.file[f.file.length- 1].Name, ']');
echo(f.folder.Path);

*/
</SCRIPT><SCRIPT>
function file_split(strName, size, bEraseSource) {
  var i, n, offset, data;
  n= file_size(strName)/ size;
  if(n> floor(n)) n= floor(n)+ 1;
  for(i= 0; i< n; i++) {
    name= sprintf('%s.%06d', strName, i);
    if(file_exists(name)) return false;
    //echof('%d: %s: %s', i, name, file_exists(name));//dbg
  }
  offset= 0;
  for(i= 0; i< n; i++) {
    name= sprintf('%s.%06d', strName, i);
    data= '';
    data= file_block_read(strName, offset, offset+ size);
    file_put_contents(name, data);
    offset+= size;
  }
  if(bEraseSource) file_delete(strName);
  return n;
}//~file_split()

function file_join(strName, bEraseSources) {//file_combine
  var i, data, name;
  i= 0;
  name= sprintf('%s.%06d', strName, i++);
  file_put_contents(strName, '');
  while(file_exists(name)) {
    data= '';
    data= file_get_contents(name);
    file_append(strName, data);
    if(bEraseSources) file_delete(name);
    name= sprintf('%s.%06d', strName, i++);
  }
  return --i;
}//~file_join()

//file_split('help.htm', 100000, true); file_join('help.htm', true);

</SCRIPT><SCRIPT>
function html2string(strHTML) {//bug: Under construction!
  if(document.createRange) {
    var txt, strEmpty, bBug;
    txt= DOM_innerText(document.createRange().createContextualFragment(strHTML));
    strEmpty= DOM_innerText(document.createRange().createContextualFragment(''));
    bBug= ((strEmpty== '\x20')&& (txt.charAt(0)== '\x20'));
    if(bBug) {//bug-fix: [FF3]
      txt= txt.replace('\x20', '');
    }
    return txt;
  }else {//BUG [IE6]
    var obj= document.createElement('DIV');
    obj.innerHTML= strHTML;
    return obj.innerText;
  }
}//~html2string()

/*
function hex2stream(hex) {//BUG: [IE6]
   hex= hex.split('');
   var stream= new Array();
   var n= hex.length/ 2;
   var i;
   var hex_byte= new String();
   for(i= 0; i< n; i++) {
      hex_byte= "0x"+ hex[i* 2]+ hex[i* 2+ 1];
      stream[i]= ord(chr(hex_byte));
   };
   return stream;
}
function stream2hex(stream) {//BUG: [IE6]
  var cmd= 'v[i]= v[i].toString(16).toUpperCase();if(v[i].length< 2) v[i]= "0"+ v[i];';
  return vector_copy(stream).foreach(cmd).join('');
}
*/
function hex2stream(hex) {
   var i, n;
   n= hex.length/ 2;
   hex= hex.explode(2);
   for(i= 0; i< n; i++) {
      hex[i]= parseInt(hex[i], 16);
   };
   return hex;
}

function stream2hex(stream) {
  var i, n, hex;
  n= stream.length;
  hex= new Array(n);
  for(i= 0; i< n; i++) {
    hex[i]= String.fromCharCode((parseInt(stream[i])+ 256));
  }
  return escape(hex.join('')).split('%u01').join('');
}

function string2stream(str) {
   var stream= str.split('');
   var i;
   for(i= 0; i< stream.length; i++) stream[i]= ord(stream[i]);
   return stream;
}

function stream2string(stream) {
   var str= new Array(stream.length);
   var i;
   for(i= 0; i< stream.length; i++) str[i]= chr(stream[i]);
   return str.join('');
}

function string2hex(str) {return stream2hex(string2stream(str));}//BUG: [IE6]
function hex2string(hex) {return stream2string(hex2stream(hex));}

function _stream2string(stream) {
   var str, i;
   if(!stream.length) return '';
   str= stream.join(',')+ ',';
   for(i= 255; i>= 0; i--) str= str.split(i+ ',').join(String.fromCharCode(i+ (1<< 8)));
   for(i= 255; i>= 0; i--) str= str.split(String.fromCharCode(i+ (1<< 8))).join(String.fromCharCode(i));
   return str;
}
function _string2stream(str) {
   var stream, i;
   if(!str.length) return [];
   for(i= 0; i<= 255; i++) str= str.split(String.fromCharCode(i)).join(String.fromCharCode(i+ (1<< 8)));
   for(i= 0; i<= 255; i++) str= str.split(String.fromCharCode(i+ (1<< 8))).join(i.toString()+ ',');
   str= str.slice(0, str.length- 1);
   return eval('['+ str+ ']');//return str.split(',');// return str.split(',').foreach('v[i]>>>= 0');
}
function _hex2string(hex) {return unescape('%'+ hex.explode(2).join('%'));}
function _string2hex(str) {
  for(var i= 0; i<= 255; i++) {str= str.split(String.fromCharCode(i)).join(String.fromCharCode(i+ (1<< 8)));}
  return escape(str).split('%u01').join('');
}

function dwstream2hex(v) {  // Convert an array of little-endian dwords to a hex string.
  return v.foreach('v[i]= sprintf("%08X", v[i]).explode(2).reverse().join("")').join('').toLowerCase();
}

function string2dwstream(str, bLe) {  // Convert a string (ASCII) to an array of little-endian dwords
  //return string2hex(str).explode(8).foreach('v[i]= parseInt(v[i].explode(2).reverse().join(""), 16)');
  var t= str.length% 4;
  if(t) {str+= strdup('\x00', 3- t);}
  if(bLe) return string2hex(str).explode(8).foreach('v[i]= parseInt(v[i], 16)');
  return string2hex(strrev(str)).explode(8).reverse().foreach('v[i]= parseInt(v[i], 16)');
}//~string2dwstream()

if(!isFirefox()) {
  _stream2string.stream2string= stream2string;
  _string2stream.string2stream= string2stream;
  _hex2string.hex2string= hex2string;
  _string2hex.string2hex= string2hex;
  window.stream2string= _stream2string;//bug: not equivalent.
  window.string2stream= _string2stream;
  window.hex2string= _hex2string;
  window.string2hex= _string2hex;
}//~isFirefox()

function hex2unicode(str) {
  str= str.explode(4);
  str.foreach('v[i]= String.fromCharCode(parseInt(v[i], 16))');
  str= str.join('');
  return str;
}

function unicode2hex(str) {
  str= str.split('');//str.explode(1);
  str.foreach('v[i]= sprintf("%04X", v[i].charCodeAt(0))');
  str= str.join('');
  return str;
}

function hex2bin(hex, bStream) {
  //return hex.toUpperCase().split('').foreach('v[i]= lParam[parseInt(v[i], 16)]', range(0, 16).foreach('v[i]= sprintf("%04b", v[i])')).join('');
  var mask= range(0, 16).foreach('v[i]= sprintf("%04b", v[i]).split("").foreach("v[i]= chr(ord(v[i]<< 8))").join("")');
  hex= (hex.toUpperCase().split('').foreach('v[i]= lParam[parseInt(v[i], 16)]', mask).
    join('').replace_all(mask, vector_copy(mask).foreach("v[i]= chr(ord(v[i]>> 8))")));
  if(bStream) return hex.split('');
  return hex;
}

/*
function test_string_stream() {
   var s= "keep up the good work";
   var h= new Handle();
   echo("(original string):", s);
   s= string2stream(s);
   echo("(string2stream):", s);
   replace_all(ord(' '), 0, s); // replace spaces with nulls
   if(isHandle(h)) h.set(locate_all(0, s)); // locate nulls in stream
   echo("(modified):", s);
   echo('[', h.get().length, ' nulls found @ [', h, '] in stream]');
   s= stream2hex(s);
   echo("(stream2hex):", s);
   s= hex2stream(s);
   echo("[replaced with spaces the nulls previously found]");
   reposit(ord(' '), s, h.get()); // replace nulls with spaces
   echo("(hex2stream):", s);
   s= stream2string(s);
   echo("(stream2string):", s);
   s= string2hex(s);
   echo(("(string2hex):"), s);
   s= hex2string(s);
   echo("(hex2string):", s);
}
//test_string_stream();
*/

function this_get_filename() {
   var str= unescape(document.location);
   str= str.substring(8, str.length);
   for(i= 1; i<= str.length; i++)
      if(str.substring(i- 1, i)== '/')
         str= str.substring(0, i- 1)+ '\\'+ str.substring(i, str.length);
   return new String(str);
}
</SCRIPT><SCRIPT>
function bit_stream(data) {
  if(this.constructor!= arguments.callee) {
    if(arguments.length) return new arguments.callee(data);
    return new arguments.callee;
  }
  function bit(b) {
    if(b!= undefined) {//get bit
      if(b) this.byte|= this.mask1;
      if((this.mask1>>= 1)== 0) {
        this._buffer+= chr(this.byte);
        this.byte= 0;
        this.mask1= 128;
      }
    }else {//set bit
      if((this.mask2>>= 1)== 0) {
        this.byte= ord(substr(this._buffer, 0, 1));
        this._buffer= substr(this._buffer, 1);
        this.mask2= 128;
      }
      return ((((this.byte& this.mask2)!= 0)? 1: 0));
    }
  }
  function flush() {
    if(this.mask1== 128) return;
    for(var i= 0; i< 7; i++) this.bit(0);
  }
  function buffer(data) {
    if(arguments.length) {
      this.mask1= 128;
      this.mask2= 0;
      this.byte= 0;
      this._buffer= data;
    }
    return this._buffer;
  }
  this.mask1= 128;
  this.mask2= 0;
  this.byte= 0;
  this._buffer= '';
  this.bit= bit;
  this.flush= flush;
  this.buffer= buffer;
  if(arguments.length) this.buffer(data);
  return this;
}//~bit_stream()

/*
   Note:
     Original code "LZARI.C" (C) 1989 Haruhiko Okumura
*/


/**************************************************************
        LZARI.C -- A Data Compression Program
        (tab = 4 spaces)
***************************************************************
        4/7/1989 Haruhiko Okumura
        Use, distribute, and modify this program freely.
        Please send me your improved versions.
                PC-VAN          SCIENCE
                NIFTY-Serve     PAF01022
                CompuServe      74050,1022
**************************************************************/

/********** Arithmetic Compression **********/

/*  If you are not familiar with arithmetic compression, you should read
                I. E. Witten, R. M. Neal, and J. G. Cleary,
                        Communications of the ACM, Vol. 30, pp. 520-540 (1987),
        from which much have been borrowed.  */


function arithmetic_coder() {
  if(this.constructor!= arguments.callee) return new arguments.callee;
  function _output(bit) {//"Output 1 bit, followed by its complements"
    this.stream.bit(bit);
    for (bit= ((~bit)& 1);this.shifts> 0; this.shifts--) this.stream.bit(bit);
  }
  function _bsearch(x) {
    //"1      if x >= sym_cum[1],"
    //"N_CHAR if sym_cum[N_CHAR] > x,"
    //"i such that sym_cum[i - 1] > x >= sym_cum[i] otherwise"
    var i, j, k;
    i= 1; j= this.N_CHAR;
    while (i< j) {
      k= ((i+ j)/ 2)>>> 0;
      if(this.sym_cum[k]> x) {
        i= k+ 1;
      }else {
        j= k;
      }
    }
    return i;
  }//~_bsearch()
  function start(bDecode) {// initialize model
    var ch, sym, i;

    this.low= 0;
    this.high= this.Q4;
    this.value= 0;
    this.shifts= 0;//"counts for magnifying low and high around Q2"
    this.char_to_sym= new Matrix(this.N_CHAR);
    this.sym_to_char= new Matrix(this.N_CHAR+ 1);
    this.sym_freq= new Matrix(this.N_CHAR+ 1);//"frequency for symbols"
    this.sym_cum= new Matrix(this.N_CHAR+ 1);//"cumulative freq for symbols"

    if(bDecode) {
      for (i= 0; i< this.M+ 2; i++) this.value= 2* this.value+ this.stream.bit();
    }else {
      this.stream= new bit_stream;
    }
    this.sym_cum[this.N_CHAR]= 0;
    for (sym= this.N_CHAR; sym>= 1; sym--) {
      ch= sym- 1;
      this.char_to_sym[ch]= sym; this.sym_to_char[sym]= ch;
      this.sym_freq[sym]= 1;
      this.sym_cum[sym- 1]= this.sym_cum[sym]+ this.sym_freq[sym];
    }
    this.sym_freq[0]= 0;//"sentinel (!= sym_freq[1])"
  }//~start()
  function update(sym) {//update model
    var i, c, ch_i, ch_sym;
    if (this.sym_cum[0]>= this.MAX_CUM) {
      c= 0;
      for (i= this.N_CHAR; i> 0; i--) {
        this.sym_cum[i]= c;
        c+= (this.sym_freq[i]= (this.sym_freq[i]+ 1)>>> 1);
      }
      this.sym_cum[0]= c;
    }
    for(i= sym; this.sym_freq[i]== this.sym_freq[i- 1]; i--) ;
    if(i< sym) {
      ch_i= this.sym_to_char[i]; ch_sym= this.sym_to_char[sym];
      this.sym_to_char[i]= ch_sym; this.sym_to_char[sym]= ch_i;
      this.char_to_sym[ch_i]= sym; this.char_to_sym[ch_sym]= i;
    }
    this.sym_freq[i]++;
    while(--i>= 0) this.sym_cum[i]++;
  }//~update()
  function stop(bEncode) {//discard model
    if(bEncode) {
      this.shifts++;
      if(this.low< this.Q1) {
        this._output(0);
      }else {
        this._output(1);
      }
      this.stream.flush();//"flush bits remaining in buffer"
    }
  }//~stop()
  function encode_byte(ch) {
    var sym, range;
    sym= this.char_to_sym[ch];
    range= this.high- this.low;
    this.high= (this.low+ (range* this.sym_cum[sym- 1])/ this.sym_cum[0])>>> 0;
    this.low+= ((range* this.sym_cum[sym])/ this.sym_cum[0])>>> 0;
    for (;;) {
      if (this.high<= this.Q2) this._output(0);
      else if (this.low>= this.Q2) {
        this._output(1); this.low-= this.Q2; this.high-= this.Q2;
      } else if (this.low>= this.Q1&& this.high<= this.Q3) {
        this.shifts++; this.low-= this.Q1; this.high-= this.Q1;
      } else break;
      this.low+= this.low; this.high+= this.high;
    }
    this.update(sym);
  }//~encode_byte()
  function decode_byte() {
    var sym, ch,  range;

    range= this.high- this.low;
    sym= this._bsearch((((this.value- this.low+ 1)* this.sym_cum[0]- 1)/ range)>>> 0);
    this.high= (this.low+ (range* this.sym_cum[sym- 1])/ this.sym_cum[0])>>> 0;
    this.low+= ((range* this.sym_cum[sym])/ this.sym_cum[0])>>> 0;
    for (;;) {
      if (this.low>= this.Q2) {
        this.value-= this.Q2; this.low-= this.Q2; this.high-= this.Q2;
      }else if (this.low>= this.Q1&& this.high<= this.Q3) {
        this.value-= this.Q1; this.low-= this.Q1; this.high-= this.Q1;
      }else if (this.high> this.Q2) break;
      this.low+= this.low; this.high+= this.high;
      this.value= 2* this.value+ this.stream.bit();
    }
    ch= this.sym_to_char[sym];
    this.update(sym);
    return ch;
  }//~decode_byte()
  function encode(data) {
    var i, ch, n;
    this.start();
    n= data.length;
    this.stream.buffer(DWORD2string(n));
    for(i= 0; i< n; i++) {
      ch= ord(substr(data, i, 1));
      this.encode_byte(ch);
    }
    this.stop(true);
    return this.stream.buffer();
  }//~encode()
  function decode(data) {
    var i, n;
    n= string2DWORD(data);
    data= substr(data, 4);
    this.stream.buffer([data, data= ''][0]);
    this.start(true);
    for(i= 0; i< n; i++) {
      data+= chr(this.decode_byte());
    }
    this.stop();
    return data;
  }//~decode()
  this.M= 15;
  //"Q1 (= 2 to the M) must be sufficiently large, but not so"
  //"large as the unsigned long 4 * Q1 * (Q1 - 1) overflows."
  this.Q1= (1<< this.M);
  this.Q2= (2* this.Q1);
  this.Q3= (3* this.Q1);
  this.Q4= (4* this.Q1);
  this.MAX_CUM= (this.Q1- 1);
  this.N_CHAR= 256;//"character code = 0, 1, ..., N_CHAR - 1"

  this.stream= new bit_stream;

  this._output= _output;
  this._bsearch= _bsearch;
  this.start= start;
  this.update= update;
  this.stop= stop;
  this.encode_byte= encode_byte;
  this.decode_byte= decode_byte;
  this.encode= encode;
  this.decode= decode;
  return this;
}//~arithmetic_coder()

/*
function foo() {
  var a, x;
  a= arithmetic_coder();
  x= a.encode('Hello world!');
  echo(string2hex(x));
  echo(x.length);
  y= a.decode(x);
  echo(string2hex(y));
  echo(y.length);
  echo(y);
}//~foo()
foo();
*/
</SCRIPT><SCRIPT>
function buffer_buffers(n, textarea) { // UNDER CONSTRUCTION
   var b= syscall('buffers');
   if(b.constructor== Handle) {
     if(isNaN(parseInt(n))) n= 10;
     if(!textarea) textarea= document.getElementsById('textarea');
     var _b, i, widget;
     _b= new Array(n);
     _b.dirty= new Array(n);
     _b.textarea= new Array(n);
     _b.file= new Array(n);
     _b.widget= new Array(n);
     for(i= 0; i< n; i++) {
        _b[i]= '';
        _b.dirty[i]= false;
        _b.textarea[i]= textarea;
        _b.file[i]= '';
      }
      _b.active= new Number(1);
      syscall('buffers', _b).readonly= true;
      buffer_widgets_init();
      return syscall('buffers');
   }else return b;
}//~buffer_buffers()

function buffer_widget(index, widget) {
  var b= syscall('buffers');
  if(arguments.length== 2)
    b.widget[index]= widget;
  else widget= b.widget[index];
  return widget;
}

function buffer_widgets_init() {
  function BtnXOnClick(event){
    event= bugfix_event(event);
    var obj, index, new_index;
    obj= event.srcElement;
    index= buffer_active();
    new_index= parseInt(obj.name);
    if(isNaN(new_index)) {
      new_index= event.keyCode- 48;
      if((new_index< 0)|| (new_index> 9)) new_index= 1;
    }
    if(buffer_visible(index))  buffer_refresh(index, true);
    else buffer_refresh(index);
    buffer_activate(new_index, true);
  }
  var i, n, str, btn;
  n= buffer_count();
  for(i= 0; i< n; i++) {
    btn= document.getElementById('B'+ i);
    btn.style.cssText= 'text-decoration: underline; font-weight: bold';
    btn.style['color']= 'blue';
    btn.innerHTML= i;
    btn.onclick= BtnXOnClick;
    btn.name= i;
    btn.OnActive= new Function('arguments[0].style.color= "black";');
    btn.OnInactive= new Function('arguments[0].style.color="blue"');
    buffer_widget(i, btn);
  }
  btn= document.getElementById('B'+ buffer_active());
  btn.style['color']= 'black';
}//~buffer_widgets_init()

function buffer_count() {
  var b= buffer_buffers();
  if(b) return b.length;
  else return 0;
}

function buffer_focus(index) {
   if(typeof(index)== 'undefined') index= buffer_active();
   if(buffer_visible(index))
     return buffer_visible(index, true, true);
   return false;
}

function buffer_dirty(index, bSet, bClear) {
   if(typeof(index)== 'undefined') index= buffer_active();
   var b= buffer_buffers();
   if(bSet) b.dirty[index]= (bClear)? false: true;
   return b.dirty[index];
}

function buffer_active(index, bSet, bActivate) {
   var b= buffer_buffers();
   if(typeof(index)== 'undefined') return b.active;
   if(bSet) {
     if(bActivate) buffer_activate(index);
     b.active= index;
   }
   return (index== b.active)? true: false;
}

function buffer_activate(index, bFocus) {
   if(index== undefined) index= 1;
   var pactv= buffer_active();
   var b= buffer_buffers();
   if(index!= pactv) {
         var _widget= b.widget[pactv];
     if(_widget) if(typeof(_widget.OnInactive)== 'function')
        _widget.OnInactive(_widget);
     _widget= b.widget[index];
     if(_widget) if(typeof(_widget.OnActive)== 'function')
        _widget.OnActive(_widget);
     buffer_active(index, true);
   }
   buffer_refresh(index);
   if(bFocus) buffer_focus(index);
   return index;
}

function buffer_visible(index, bVisible, bFocus) {
   if(typeof(index)== 'undefined') index= buffer_active();
   var b= buffer_buffers();
   if(bVisible) {
           b.textarea[index].style.visibility= 'visible';
           buffer_refresh(index);
           if(bFocus&& (!isEmpty(b.textarea[index].focus))){
              b.textarea[index].focus();
        }
        return true;
   }else if(bVisible== false) {
           buffer_refresh(index, true);
       b.textarea[index].style.visibility= 'hidden';
       return false;
   }
   if(buffer_active()== index)
      if(b.textarea[index].style.visibility== 'visible')
         return true;
   return false;
}

function buffer_processor(index, foo_processor) {
   buffer_refresh(index);
   buffer_set(index, foo_processor(buffer_get(index)));
   buffer_refresh(index, true);
}

function buffer_indent(index, nTab) {
  if(isEmpty(index)) index= buffer_active();
  if(!nTab) nTab= 2;
  buffer_processor(index, new Function('x', 'return x.indent('+ nTab+ ')'));
}

function buffer_eval(index) { //UNDER CONSTRUCTION
   if(typeof(index)== 'undefined') index= buffer_active();
   return eval(buffer_get(index));
}

function buffer_get(index) {
   var b= buffer_buffers();
   if (typeof(index)== 'undefined') {
      index= buffer_active();
   };
   return b[index];
}

function buffer_refresh(index, bSet) {
   var b= buffer_buffers();
   var textarea= b.textarea[index];
   if(index== buffer_active())
     if(_strcmp(textarea.value, b[index]))
        if(!bSet) textarea.value= b[index];
        else {
                b[index]= textarea.value;
                buffer_dirty(index, true);
            }
}

function buffer_clear(index, bSkipRefresh) {
  var b= buffer_buffers();
  if(_strlen(b[index])) {
      b[index]= '';
      b.file[index]= '';
      buffer_dirty(index, true);
      if(!bSkipRefresh) buffer_refresh(index);
  }
}

function buffer_set(index, value, bSkipRefresh, bClean) {
   var b= buffer_buffers();
   if(arguments.length== 1) {
      value= index;
      index= buffer_active();
   };
   if(_strcmp(buffer_get(index), value)) {
      b[index]= value;
      if(bClean== true) buffer_dirty(index, true, true);
      else buffer_dirty(index, true);
      if(!bSkipRefresh) buffer_refresh(index);
   }
}

function buffer_append(index, value, bSkipRefresh, bClean) {
    var b = buffer_buffers();
    if (arguments.length == 1) {
        value = index;
        index = buffer_active();
    }
    if (_strcmp(buffer_get(index), value)) {
        b[index] += value;
        if (bClean == true) {
            buffer_dirty(index, true, true);
        } else {
            buffer_dirty(index, true);
        }
        if (!bSkipRefresh) {
            buffer_refresh(index);
        }
    }
}

function buffer_get_filename(index, bDefault) {
   var b= buffer_buffers();
   if(typeof(index)== 'undefined') index= buffer_active();
   if(bDefault) {
     var s, file_name;
     file_name= ('buffer'+parseInt(index, 10)+ '.txt');
     s= syscall('shell');
     if(!isNull(s)) file_name= s.pwd()+ file_name;
     return file_name;
   }
   return b.file[index];
}

function buffer_set_filename(index, filename) {
   var b= buffer_buffers();
   if(arguments.length== 1) {
      filename= index;
      index= buffer_active();
   };
   return b.file[index]= filename;
}

function buffer_load(index, filename) {
   if(!file_exists(filename)) {
      SetLastError(['buffer_load: File not found! ('+ filename+ ')',
            Errors.FileNotFound, get_call_stack(arguments.callee)]);
      return null;
   }
   var b= buffer_buffers();
   if(arguments.length== 1) {
      filename= index;
      index= buffer_active();
   }else {
           if(typeof(index)== 'undefined')
         index= buffer_active();
   };
   buffer_set_filename(index, '');
   var newText= file_get_contents(filename);
   if(isNull(newText)) newText= '';
   buffer_set(index, newText);
   buffer_dirty(index, true, true);
   buffer_set_filename(index, filename);
   return newText;
}

function buffer_save(index, bSilent) {
   var b= buffer_buffers();
   var filename= buffer_get_filename(index);
   if(!_strlen(filename)) {
      if(bSilent!= true) filename= prompt("File save as: ", '');
      if(!_strlen(filename)) {
          SetLastError(['buffer_save: Invalid file name! ('+ filename+ ')',
            Errors.InvalidTarget, get_call_stack(arguments.callee)]);
              return null;
          }
      buffer_set_filename(filename);
   }
   buffer_dirty(index, true, true);
   return file_put_contents(filename, buffer_get(index));
}

function buffer_saveas(index, filename, bClean) {
   buffer_set_filename(index, filename);
   if(bClean) buffer_dirty(index, true, true);
   return buffer_save(index);
}

function buffer_loadhex(index, filename) {
   var buf= file_get_contents(filename);
   buffer_set_filename(index, filename);
   buf= hex2string(buf);
   return buffer_set(index, buf, false, true);
}

function buffer_savehex(index) {
   buffer_set(index, string2hex(buffer_get(index)));
   return buffer_save(index);
}

function buffer_saveashex(index, filename) {
   buffer_set_filename(index, filename);
   return buffer_savehex(index);
}

function buffer_reload(index, bFromDisk, bAllEmpty) {
  var n= buffer_count();
  function _load_from_disk(index, filename, bDefault) {
    if(bDefault) if(!_strlen(filename)) {
            filename= 'buffer'+ index+ '.txt';
            var s;
            s= syscall('shell');
            if(!isNull(s)) filename= s.pwd()+ filename;
    }
    if(file_exists(filename)) buffer_load(index, filename);
  }
  if(bAllEmpty) {
    for(index= 0; index< n; index++) {
      if(!_strlen(buffer_get(index))) {
        if(bFromDisk) {
          _load_from_disk(index, buffer_get_filename(index), true);
          if(!file_exists(buffer_get_filename(index))) {
            buffer_ramdrive_load(index);
          }
        }
      }
    }
  }else {
    if(bFromDisk) _load_from_disk(index, buffer_get_filename(index), true);
  }
}

function buffer_ramdrive_save(index) {
  var file_name, data;
  file_name= buffer_get_filename(index);
  if(!file_name.length) file_name= buffer_get_filename(index, true);
  data= buffer_get(index);
  return ramdrive_put_contents(file_name, data);
}

function buffer_ramdrive_load(index) {
  var file_name, data;
  file_name= buffer_get_filename(index);
  if(!file_name.length) file_name= buffer_get_filename(index, true);
  data= ramdrive_get_contents(file_name);
  buffer_set(index, data);
}

window.buffer_get_contents= buffer_get;
window.buffer_set_contents= buffer_set;
window.buffer_put_contents= buffer_set;
window.buffer_append_contents= buffer_append;

</SCRIPT>
<SCRIPT>
function OnMouseMove(event) {
  event= bugfix_event(event);
  var x, y, t;
  t= new Date();
  if(typeof(event)!= 'undefined') {
    x= event.clientX;
    y= event.clientY;
    window.mouse.x= x;
    window.mouse.y= y;
    window.mouse.timestamp= t;
    if(window.drag.in_progress()) {
      window.drag.delta.x= x- window.drag.delta.x;
      window.drag.delta.y= y- window.drag.delta.y;
      window.drag.bMove= true;
      if((window.drag.start.x!= x)|| (window.drag.start.y!= y))
        window.drag.bMoved= true;
      else window.drag.bMoved= false;
    }else {
      if(window.drag.bMove) window.drag.bMove= false;
    }
  }else {
    window.mouse.x= -1;
    window.mouse.y= -1;
  }
  if(window.drag.in_progress()&& window.drag.widget&& (!window.drag.ignore_moves())) {
    //panic('widget.drag_move('+ window.mouse.x+ ', '+ window.mouse.y+ ')');//dbg
    if(window.drag.widget.drag_move) {
      var th= 'window.drag.widget.drag_move(';
      th+= window.mouse.x+ ',';
      th+= window.mouse.y+ ',';
      th+= window.drag.delta.x+ ',';
      th+= window.drag.delta.y+ ')';
      schedule(th);
    }
  }
}//~OnMouseMove()

function OnMouseClick(event) {
  event= bugfix_event(event);
  var t= new Date();
  if(typeof(event)!= 'undefined') {
    window.click.x= event.clientX;
    window.click.y= event.clientY;
    window.click.timestamp= t;
  }else {
    window.click.x= -1;
    window.click.y= -1;
  }
}//~OnMouseClick()

function OnMouseDown(event) {
  event= bugfix_event(event);
  var x, y, t;
  t= new Date();
  if(!window.drag.in_progress()) {
    window.drag.bDrag= false;
    window.drag.bMove= false;
    window.drag.bMoved= false;
    window.drag.start.timestamp= t;
    window.drag.stop.timestamp= t;
    if(typeof(event)!= 'undefined') {
      x= event.clientX;
      y= event.clientY;
      window.drag.delta.x= 0;
      window.drag.delta.y= 0;
      window.drag.start.x= x;
      window.drag.start.y= y;
    }
    window.drag.ignore_moves(true);
    if(window.drag.autoselect()) window.drag.set_widget(event.target);
    window.drag.in_progress(true);
    if(window.drag.widget) {
      //panic('widget.drag_start('+ window.drag.start.x+ ', '+ window.drag.start.y+ ')');//dbg
      if(window.drag.widget.drag_start) {
        var th= 'window.drag.widget.drag_start(';
        th+= window.drag.start.x+ ',';
        th+= window.drag.start.y+ ',';
        th+= window.drag.delta.x+ ',';
        th+= window.drag.delta.y+ ')';
        schedule(th);
        window.drag.ignore_moves(false);
      }
    }
  }
}//~OnMouseDown()

function OnMouseUp(event) {
  event= bugfix_event(event);
  var x, y, t;
  t= new Date();
  if(window.drag.in_progress()) {
    window.drag.stop.timestamp= t;
    if(typeof(event)!= 'undefined') {
      x= event.clientX;
      y= event.clientY;
      window.drag.stop.x= x;
      window.drag.stop.y= y;
      window.drag.delta.x= x- window.drag.start.x;
      window.drag.delta.y= y- window.drag.start.y;
      //panic(window.drag.start.y+ ' '+ y+ ' '+ window.drag.delta.y);//dbg
      if((window.drag.start.x!= x)|| (window.drag.start.y!= y))
         window.drag.bDrag= true;
    }
    if(window.drag.widget) {
      //panic('widget.drag_stop('+ window.drag.stop.x+ ', '+ window.drag.stop.y+ ')');//dbg
      if(window.drag.widget.drag_stop) {
        window.drag.ignore_moves(true);
        var th= 'window.drag.widget.drag_stop(';
        th+= window.drag.stop.x+ ',';
        th+= window.drag.stop.y+ ',';
        th+= window.drag.delta.x+ ',';
        th+= window.drag.delta.y+ ')';
        schedule(th);
        schedule('window.drag.in_progress(false)'); // hmm..
      }else window.drag.in_progress(false);
    }else  window.drag.in_progress(false);
  }
}//~OnMouseUp()

function OnMouseInit() {
  function _set_widget(widget) {
    if(!window.drag.in_progress()) {
      window.drag.widget= widget;
      return true;
    }else {
      return false;
    }
  }
  function _autoselect(bAutoselect) {
    if(bAutoselect!= undefined)
      window.drag.bWidgetAutoselect= bAutoselect;
    return window.drag.bWidgetAutoselect;
  }
  function _in_progress(bSet) {
    if(bSet!= undefined) window.drag.bInprogress= bSet;
    return window.drag.bInprogress;
  }
  function _ignore_moves(bSet) {
    if(bSet!= undefined) window.drag.bIgnoreMoves= bSet;
    return window.drag.bIgnoreMoves;
  }
  window.mouse= new Point();
  window.mouse.timestamp= null;
  window.document.onmousemove= OnMouseMove;
  window.click= new Point();
  window.click.timestamp= null;
  window.document.onclick= OnMouseClick;
  window.drag= new Object();
  window.drag.start= new Point();
  window.drag.stop= new Point();
  window.drag.delta= new Point();
  window.drag.start.timestamp= null;
  window.drag.stop.timestamp= null;
  window.drag.bDrag= false;
  window.drag.bMove= false;
  window.drag.bMoved= false;
  window.drag.widget= null;
  window.drag.autoselect= _autoselect;
  window.drag.set_widget= _set_widget;
  window.drag.in_progress= _in_progress;
  window.drag.ignore_moves= _ignore_moves;
  window.document.onmousedown= OnMouseDown;
  window.document.onmouseup= OnMouseUp;
  window.drag.in_progress(false);
  window.drag.autoselect(false);
}//~OnMouseInit()

/*
var w= CreateWindow(null, 500, 500, 10, 10, 'green', 'blue', '', true);
window.w= w;
w.drag_start= new Function ('panic("drag_start")');
w.drag_move= new Function('panic("drag_move")');
w.drag_stop= new Function('panic("drag_stop")');
window.drag.autoselect(false);
window.drag.set_widget(w);

//window.drag.set_widget(null)
//window.drag.autoselect(true)

*/
</SCRIPT>
<SCRIPT>
function GetDesktopWindow() {return window.document.body;}
function GetActiveWindow() {return window.hwnd;}
function SetActiveWindow(hwnd) {window.hwnd= hwnd;}

function CreateWindow(parent, x, y, width, height, background, color, title, visible, alpha) {
   var type= "DIV";
   var hwnd_parent= (parent === null)? window.GetDesktopWindow(): parent;
   var id= 'wnd_id'+ syscall('ID'); //"wnd"+ new_ID();

   //var window_data= "<"+ type+ " style='display:none' id='"+ id+ "'></"+ type+ ">"; hwnd_parent.insertAdjacentHTML("BeforeEnd", window_data);
   var window_data= document.createElement(type);
   window_data.style.display= 'none';
   window_data.setAttribute('id', id);
   hwnd_parent.appendChild(window_data);
   //
   var obj= hwnd_parent.childNodes[hwnd_parent.childNodes.length- 1];//var hwnd= hwnd_parent.children(id);
   var hwnd= DOM_element2window(obj);

   hwnd.hwnd_parent= hwnd_parent;
   hwnd.style.position= "absolute"; // "relative"
   hwnd.style.zIndex= 0;
   hwnd.event_handler= new Array();
   hwnd_parent.hwnd_child.append(hwnd);
   hwnd.MoveWindow(x, y, width, height);
   hwnd.TextColor(color);
   hwnd.TextBackground(background);
   if(isNull(title)) {
      hwnd.FontSize(1);
      hwnd.style.overflow= "hidden";
   }else {
      hwnd.FontSize(13);
      hwnd.SetWindowText(title);
      hwnd.style.overflow= "visible";
   }
   hwnd.opacity(alpha);
   if(visible) hwnd.ShowWindow(true);
   return hwnd;
}//~CreateWindow()

function DestroyWindow(hwnd) {
   if(hwnd !== window.GetDesktopWindow())   hwnd.CloseWindow();
}

function CloseAllWindows() {
   var hwnd= window.GetDesktopWindow();
   for (var i in hwnd.hwnd_child) {
      try {hwnd.hwnd_child[i].CloseWindow(); } catch(e) {};
   }
   hwnd.hwnd_child= new Array();
}

function SVGCreateWindow(x, y, width, height, strData, bShow) {//[FF3]
  var strFrm, wnd;
  strData= 'data:image/svg+xml;base64,'+ string2base64(strData);
  //window.open(strData);//dbg
  strFrm= "<IFRAME ID=ihtml SRC='about:blank' WIDTH=100% HEIGHT=100% MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no BORDERCOLOR='#000000'></IFRAME>";
  wnd= CreateWindow(null, x, y, width, height, "white", "black");
  wnd.innerHTML= strFrm;
  wnd.childNodes[0].src= strData;
  wnd.ShowWindow(bShow);
  return wnd;
}//~SVGCreateWindow()

function LoadSprite(url, x, y, width, height, bVisible, xy) {
  function frame(i) {
    if(arguments.length) {
      var xy, prev_idx;
      prev_idx= this.frame();
      xy= '0px '+ (parseInt(this.style.height)* -i)+ 'px';
      this.style.backgroundPosition= xy;
      return prev_idx;
    }else {
      var y, height;
      y= parseInt(wnd.style.backgroundPosition.split('px')[1]);
      height= parseInt(this.style.height);
      i= -y/ height;
      return i;
    }
  }
  function frames() {
    var r= GetImageRect(wnd.style.backgroundImage.split('(')[1].split(')')[0]);
    if(r) {
      return parseInt((r.bottom- r.top)/ parseInt(this.style.height));
    }else return null;
  }
  var wnd;
  wnd= CreateWindow(null, x, y, width, height, '', '', undefined, bVisible);
  wnd.frame= frame;
  wnd.frames= frames;
  url= escape(unescape(url));
  wnd.style.backgroundImage= 'url('+ url+ ')';
  if((typeof(xy)!= 'undefined')&& (xy.constructor== Array)) {
    wnd.style.backgroundPosition= xy[0]+ 'px '+ xy[1]+ 'px';
  }else {
    if(xy) wnd.frame(parseInt(xy));
  }
  return wnd;//"LoadSprite('0000.jpg', 500, 500, 128, 128, true, [0, 2* 128]);"
}//~LoadSprite()

//"LoadSprite('0000.jpg', 500, 500, 128, 128, true, 3);"

window.GetDesktopWindow= GetDesktopWindow;
window.GetActiveWindow= GetActiveWindow;
window.SetActiveWindow= SetActiveWindow;
window.CreateWindow= CreateWindow;
window.DestroyWindow= DestroyWindow;
window.CloseAllWindows= CloseAllWindows;
window.CloseAll= CloseAllWindows;
window.SVGCreateWindow= SVGCreateWindow;
window.hwnd= GetDesktopWindow();
window.hwnd.hwnd_child= new Array();
/*
function TestWindows() {
  window.a= CreateWindow(null, 300, 100, 100, 100, "black", "yellow", "a", true);
  window.b= CreateWindow(null, 400, 100, 100, 100, "yellow", "black", "b", true);
  window.c= CreateWindow(a, 0, 25, 50, 50, "green", "blue", "c", true);
  window.d= CreateWindow(a, 50, 25, 50, 50, "blue", "green", "d", true);
  window.e= CreateWindow(b, 0, 25, 50, 50, "cyan", "magenta", "e", true);
  window.f= CreateWindow(b, 50, 25, 50, 50, "magenta", "cyan", "f", true);
  SetActiveWindow(window.a);
}
window.TestWindows= TestWindows;
TestWindows();
*/
function Tooltip(msg) {
   var e;
   try{
       unschedule(window.tooltip.user.prorogation);
       window.tooltip.Close();
   }catch(e){};
   var left= window.mouse.x;
   var top= window.mouse.y;
   var width= 200;
   var height= 13;
   var hwnd= CreateWindow(null, left, top, width, height, "yellow", "black", msg, true);
   hwnd.ondblclick= new Function("this.Close()");
   window.tooltip= hwnd;
   window.tooltip.user.prorogation=  schedule("{var e; try{window.tooltip.Close()} catch(e){}}", 3000);
} //Tooltip(Date());
window.Tooltip= Tooltip;
</SCRIPT>
<SCRIPT>
function Line(a, b, c) { // the carthesian general linear equation: "a* x+ b* y+ c= 0"
  function isValid() {
    if((this.a== this.b)&& (this.a== 0.0)) return false;//degenerate line
    else return true;
  }
  function isHorizontal() {
    if(this.isValid()) {
      if(this.a== 0.0) return true;
    }
    return false;
  }
  function isVertical() {
    if(this.isValid()) {
      if(this.b== 0.0) return true;
    }
    return false;
  }
  function isOblique() {
    if(!this.isValid()) return false;
    if(this.isHorizontal()|| this.isVertical()) return false;
    return true;
  }
  function isParallel(d1) {
    if(!this.isValid()) return false;
    if(!d1.isValid()) return false;
    var a1, b1, c1, a2, b2, c2, t1, t2, t3;
    a1= this.a; b1= this.b; c1= this.c;
    a2= d1.a; b2= d1.b; c2= d1.c;
    if(fabs((a1* b2)- (a2* b1))<= Math.DELTA) {//if((a1* b2)== (a2* b1)) {
        return true;
    }else return false;
  }
  function isCoincident(d1) { // coincid daca au coeficienti corespondenti proportionali
    if(!this.isValid()) return false;
    if(!d1.isValid()) return false;
    var a1, b1, c1, a2, b2, c2, t1, t2, t3;
    a1= this.a; b1= this.b; c1= this.c;
    a2= d1.a; b2= d1.b; c2= d1.c;
    if(fabs((a1* b2)- (a2* b1))<= Math.DELTA) {//if((a1* b2)== (a2* b1)) {
      if(fabs((a1* c2)- (a2* c1))<= Math.DELTA) {//if((a1* c2)== (a2* c1)) {
        return true;//dreptele se confunda
      }else return false; // drepte paralele
    }else return false;//sunt concurente (se intersecteaza)
  }
  function set(x1, y1, x2, y2) {
    if(!arguments.length) return;
    if(arguments.length== 3) {
      this.a= arguments[0];
      this.b= arguments[1];
      this.c= arguments[2];
      return this.get();
    }else // get coefficients from a segment
      return this.from_segment(x1, y1, x2, y2);
  }
  function get() {return this.coefficients();}
  function coefficients(a, b, c) {
    if(arguments.length== 3) return this.set(a, b, c);
    return [this.a, this.b, this.c];
  }
  function explicit_coefficients() { // y= m* x+ n
    var m, n;
    if(this.isVertical()) return NaN;
     m= -1.0* this.a/ this.b;
     n= -1.0* this.c/ this.b;
    return [m, n];
  }
  function slope() { // y= m* x+ n;
    if(this.isVertical()) return NaN;
    var m= -1.0* this.a/ this.b;
    //var n= -1.0* this.c/ this.b;
    return m;
  }
  function from_segment(x1, y1, x2, y2) {
    this.a= y2- y1;
    this.b= x1- x2;
    this.c= x2* y1- x1* y2;
    return this.get();
  }
  function from_origin(x, y) { // P(x, y) este piciorul perpendicularei din origine pe dreapta d
    this.a= x;
    this.b= y;
    this.c= -1.0* (x* x+ y* y);
    return this.get();
  }
  function Xintercept(x) { // a new vertical line
    return new Line(x, 0.0, x, 1.0);
  }
  function Yintercept(y) {// a wew horizontal line
    return new Line(0.0, y, 1.0, y);
  }
  function XYintercept(x, y, bVariant) { // ecuatia dreptei prin taieturi
    var a1, b1, c1;
    if(x!= 0&& y!= 0&& !bVariant) {
      a1= 1.0/ x;
      b1= 1.0/ y;
      c1= -1.0;
      return new Line(a1, b1, c1);
    }else return new Line(0.0, y, x, 0.0);
  }
  function intersect(line) {  // return the point of intersection between two lines
    var x, y, coef, a1, b1, c1, a2, b2, c2;
    if(!line.isValid()|| !this.isValid()) return null;
    if(this.isParallel(line)) return null;
    coef= line.get();
    a1= this.a;
    b1= this.b;
    c1= this.c;
    a2= coef[0];
    b2= coef[1];
    c2= coef[2];
    x= (b1* c2- b2* c1)/ (b2* a1- b1* a2);
    y= (a1* c2- a2* c1)/ (a2* b1- a1* b2);
    return new Point(x, y);
  }
  function getX(t) {
    var vl= this.Yintercept(t);
    var pt= this.intersect(vl);
    if(pt) return pt.x;
    else return null;
  }
  function getY(t) {
    var hl= this.Xintercept(t);
    var pt= this.intersect(hl);
    if(pt) return pt.y;
    else return null;
  }
  function isOn(x, y, bAccurate) {//TODO: more cleanup & tests
    var itolerance; //BUGFIX
    //var _y;
    if(this.isValid()) {
    //   _y= this.getY(x);
    //   if(!isNull(_y)&& (y== _y)) return true
      if(!bAccurate) itolerance= 10000;
      if(!bAccurate) {if((fabs(this.a* x+ this.b* y+ this.c)<= Math.DELTA* itolerance)) return true;} else
      if((this.a* x+ this.b* y+ this.c)== 0.0) return true;
    }
    return false;
  }
  function project(x, y) {// proiectia lui P(x, y) pe dreapta
    var px, py, a, b, c, t;
    if(!this.isValid()) return null;
    a= this.a;
    b= this.b;
    c= this.c;
    t= (a* x+ b* y+ c)/ (a* a+ b* b);
    px= x- t* a;
    py= y- t* b;
    return new Point(px, py);
  }
  function normal(x, y) {//TODO: more cleanup & tests (is still UNDER CONSTRUCTION)
    if(this.isValid()) {
        var Mp= this.project(x, y); // piciorul perpendicularei din P(x, y) pe d: punctul M
         x= Mp.x;
         y= Mp.y;
        var a1, b1, c1;
         a1= this.b;
         b1= -1.0* this.a;
         c1= this.a* y- this.b* x;
         return new Line(a1, b1, c1);
//
//       if(this.isOn(x, y)) {
//        var a1, b1, c1;
//         a1= this.b;
//        b1= -1.0* this.a;
//         c1= this.a* y- this.b* x;
//         return new Line(a1, b1, c1);
//       }else { // perpendiculara din M pe d (punctul M exterior dreptei d)
////       if(this.isVertical()) return this.Yintercept(y);//UNDER CONSTRUCTION
////       if(this.isHorizontal()) return this.Xintercept(x);//UNDER CONSTRUCTION
//         var Mp= this.project(x, y); // piciorul perpendicularei din P(x, y) pe d: punctul M
//         return new Line(Mp.x, Mp.y, x, y);
//       }
    }
    return new Line(0, 0, 0); // invalid
  }
  function perpendicular(x, y) {return this.normal(x, y);}
  function parallel(x, y) { // a new line parallel with d
    if(this.isOn(x, y)) return this.clone();
    var M, N, xi, yi, dx;
    xi= this.Xintercept(x);
    M= this.intersect(xi);
    if(isNull(M)) return xi; // isVertical
    yi= this.Yintercept(y);
    N= this.intersect(yi);
    if(isNull(N)) return yi; // isHorizontal
    dx= M.x- N.x; // UNDER CONSTRUCTION
    return new Line(M.x+ dx, M.y, x, y);
  }
  function clone() {
    return new Line(this.a, this.b, this.c);
  }
  function evaluate(x, y) {
    if(arguments.length== 1) {
      var P= arguments[0];
      return (this.a* P.x+ this.b* P.y+ this.c);
    }
    return (this.a* x+ this.b* y+ this.c);
  }
  function interpolate(x1, y1, x2, y2, t) {
    if(arguments.length== 3) {
      var P, Q, t, x, y;
      P= arguments[0];
      Q= arguments[1];
      t= arguments[2];
      x= interpolate_linear(P.x, Q.x, t);
      y= interpolate_linear(P.y, Q.y, t);
      return new Point(x, y);
    }else {
      var x, y;
      x= interpolate_linear(x1, x2, t);
      y= interpolate_linear(y1, y2, t);
      return new Point(x, y);
    }
  }
  function line2segment(min_x, min_y, max_x, max_y) {//get the segment inside the rectangle
    if(arguments.length== 0) {
      min_x= 0;
      min_y= 0;
      max_x= getmaxx();
      max_y= getmaxy();
    }
    var c0, c1, c2, c3, r0, r1, r2, r3, P, count;
    if(!this.isValid()) return null;
    c0= new Point(min_x, min_y);
    c1= new Point(max_x, min_y);
    c2= new Point(max_x, max_y);
    c3= new Point(min_x, max_y);
    r0= this.evaluate(c0);
    r1= this.evaluate(c1);
    r2= this.evaluate(c2);
    r3= this.evaluate(c3);
    P= [];
    count= 0;
    if ((r0< 0.0&& r1>= 0.0)|| (r0>= 0.0&& r1< 0.0)) {// on top
      if (r1!= r0)
        P[count++]= this.interpolate(c0, c1, -r0/ (r1- r0));
    }
    if ((r1< 0.0&& r2>= 0.0)|| (r1>= 0.0&& r2< 0.0)) {// on right
      if (r2!= r1)
        P[count++]= this.interpolate(c1, c2, -r1/ (r2- r1));
    }
    if ((r2< 0.0&& r3>= 0.0)|| (r2>= 0.0&& r3< 0.0)) {// on bottom
      if (r3!= r2)
        P[count++]= this.interpolate(c2, c3, -r2/ (r3- r2));
    }
    if ((r3< 0.0&& r0>= 0.0)|| (r3>= 0.0&& r0< 0.0)) {// on left
      if (r3!= r0)
        P[count++]= this.interpolate(c3, c0, -r3/ (r0- r3));
    }
    if (count== 0) {
      return (null);
    }else if (count== 1) {
      return [P[0].x, P[0].y, P[0].x, P[0].y];
    } else {
      return [P[0].x, P[0].y, P[1].x, P[1].y];
    }
  }//~Line.line2segment()
  function toString() {return this.get().toString()}
  this.set= set;
  this.get= get;
  this.isValid= isValid;
  this.isHorizontal= isHorizontal;
  this.isVertical= isVertical;
  this.isOblique= isOblique;
  this.isParallel= isParallel;
  this.isCoincident= isCoincident;
  this.isOn= isOn;
  this.project= project;
  this.normal= normal;
  this.perpendicular= perpendicular;
  this.parallel= parallel;
  this.coefficients= coefficients;
  this.explicit_coefficients= explicit_coefficients;
  this.slope= slope;
  this.from_segment= from_segment;
  this.from_origin= from_origin;
  this.Xintercept= Xintercept;
  this.Yintercept= Yintercept;
  this.XYintercept= XYintercept;
  this.intersect= intersect;
  this.getX= getX;
  this.getY= getY;
  this.clone= clone;
  this.evaluate= evaluate;
  this.interpolate= interpolate;
  this.line2segment= line2segment;
  if(arguments.length== 3) {
    this.a= a;
    this.b= b;
    this.c= c;
  }else if(arguments.length== 4) {// get coefficients from a segment
      var x1, y1, x2, y2;
      x1= arguments[0];
      y1= arguments[1];
      x2= arguments[2];
      y2= arguments[3];
      this.a= y2- y1;
      this.b= x1- x2;
      this.c= x2* y1- x1* y2;
  }else {
    this.a= 0.0;
    this.b= 0.0;
    this.c= 0.0;
  }
  this.toString= toString;
  return this; // Geometrie Analitica Manual clasa a XI-a
}//~Line()
</SCRIPT>
<SCRIPT>
function matrix3x3_quad2rect (q, w, h) { // "Keystone Correction": Find the 2D transform matrix that maps a quad to a rectangle in the first quadrant with given width and height.
    var  m00, m01, m02, m10, m11, m12, m20, m21, m22;
    var a, b, q0x, q0y, q1x, q1y, q2x, q2y, q3x, q3y;

    q0x = q[0].x; q0y = q[0].y;
    q1x = q[1].x; q1y = q[1].y;
    q2x = q[2].x; q2y = q[2].y;
    q3x = q[3].x; q3y = q[3].y;

    m02= q0x;
    m12= q0y;
    m22= 1.0;

    a= ((q2x- q3x)* (q1y- q2y)- (q2y- q3y)* (q1x- q2x))* h;
    b= (q2x- q1x- q3x+ q0x)* (q1y- q2y)- (q2y- q1y- q3y+ q0y)* (q1x- q2x);
    m21= -b/ a;

    if (q1x!= q2x)
    m20= (m21* (q2x- q3x)* h+ q2x- q1x- q3x+ q0x)/ ((q1x- q2x)* w);
    else
    m20= (m21* (q2y- q3y)* h+ q2y- q1y- q3y+ q0y)/ ((q1y- q2y)* w);

    m00= m20* q1x+ (q1x- q0x)/ w;
    m10= m20* q1y+ (q1y- q0y)/ w;

    m01= m21* q3x+ (q3x- q0x)/ h;
    m11= m21* q3y+ (q3y- q0y)/ h;

    return [
      [ m00, m01, m02 ],
      [ m10, m11, m12 ],
      [ m20, m21, m22 ]
    ];
}//~matrix3x3_quad2rect()

function matrix3x3_invert (m) {
    var  det, i, j, r, a, b;
    a= [2, 2, 1 ];
    b= [1, 0, 0 ];
    det= 0;
    r= [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]];
    for (i= 0; i< 3; i++) {
    var p, ai, bi;
        ai= a[i];
    bi= b[i];
    p= m[i][0]* (m[ai][2]* m[bi][1]- m[ai][1]* m[bi][2]);
    if (i== 1) p= -p;
    det+= p;
    }
    det = 1.0/ det;
    for (j= 0; j< 3; j++) {
    for (i= 0; i< 3; i++) {
        var  p, ai, aj, bi, bj;
        ai= a[i];
        aj= a[j];
        bi= b[i];
        bj= b[j];
        p= m[ai][aj]* m[bi][bj]- m[ai][bj]* m[bi][aj];
        if (((i+ j)& 1)!= 0) p= -p;
        r[j][i]= det* p;
    }
    }
    return r;
}//~matrix3x3_invert()

function transform2D_getKeystoneCorrection(quad, width, height) {//TODO: Test more.
  var m= matrix3x3_invert(matrix3x3_quad2rect(quad, width, height));
  return [m[0][0], m[0][1], m[0][2], m[1][0], m[1][1], m[1][2], m[2][0], m[2][1], m[2][2]];
}//~transform2D_getKeystoneCorrection()

function transform2D_inverse(m) {
  var r= matrix3x3_invert([
    [m[0], m[1], m[2]],
    [m[3], m[4], m[5]],
    [m[6], m[7], m[8]]
  ]);
  return [r[0][0], r[0][1], r[0][2], r[1][0], r[1][1], r[1][2], r[2][0], r[2][1], r[2][2]];
}//~function transform2D_inverse()

function transform2D_matrix(x, y, m) {
  var a, b, c, d, e, f, g, h, i, w, nx, ny;
  a= parseFloat(m[0]);
  b= parseFloat(m[1]);
  c= parseFloat(m[2]);
  d= parseFloat(m[3]);
  e= parseFloat(m[4]);
  f= parseFloat(m[5]);
  g= parseFloat(m[6]);
  h= parseFloat(m[7]);
  i= parseFloat(m[8]);
  w= (g* x+ h* y+ i); // use homogeneous coordinates
  w= ((w!= 0.0)? (1.0/ w): NaN);//w= ((w!= 0.0)? (1.0/ w): 0.0);//use "homogenic division"
  nx= w* (a* x+ b* y+ c);
  ny= w* (d* x+ e* y+ f);
  return [nx, ny];
}//~transform2D_matrix()

function transform2D_matrixSVG(x, y, SVG_matrix) {
  var m= SVG_matrix;
  return transform2D_matrix(x, y, [m[0], m[2], m[4], m[1], m[3], m[5], 0.0, 0.0, 1.0]);
}//~transform2D_matrixSVG()

function transform2D_rotate(x, y, alpha) {//rotate against origin
  var s, c;
  alpha= deg2rad(alpha);
  s= sin(alpha);
  c= cos(alpha);
  return transform2D_matrix(x, y, [c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0]);
  //return transform2D_matrix(x, y, [s, -c, 0.0, c, s, 0.0, 0.0, 0.0, 1.0]);//dbg
}//~transform2D_rotate()

function transform2D_translate(x, y, tx, ty) {
  return transform2D_matrix(x, y, [1.0, 0.0, tx, 0.0, 1.0, ty, 0.0, 0.0, 1.0]);
}//~transform2D_translate()

function transform2D_scale(x, y, sxy) {
  return transform2D_matrix(x, y, [sxy, 0.0, 0.0, 0.0, sxy, 0.0, 0.0, 0.0, 1.0]);
}//~transform2D_scale()

function transform2D_scaleNonUniform(x, y, sx, sy) {
  return transform2D_matrix(x, y, [sx, 0.0, 0.0, 0.0, sy, 0.0, 0.0, 0.0, 1.0]);
}//~transform2D_scaleNonUniform()

function transform2D_skewX(x, y, sqx) {
  return transform2D_matrix(x, y, [1.0, tan(deg2rad(sqx)), 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]);
}//~transform2D_skewX()

function transform2D_skewY(x, y, sqy) {
  return transform2D_matrix(x, y, [1.0, 0.0, 0.0, tan(deg2rad(sqy)), 1.0, 0.0, 0.0, 0.0, 1.0]);
}//~transform2D_skewY()

function transform2D_skew(x, y, sqx, sqy) {
  return transform2D_matrix(x, y, [1.0, tan(deg2rad(sqx)), 0.0, tan(deg2rad(sqy)), 1.0, 0.0, 0.0, 0.0, 1.0]);
}//~transform2D_skew()

function transform2D_flipX(x, y) {
  return transform2D_matrixSVG(x, y, [-1.0, 0.0, 0.0, 1.0, 0.0, 0.0]);
}//~transform2D_flipX()

function transform2D_flipY(x, y) {
  return transform2D_matrixSVG(x, y, [1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);
}//~transform2D_flipY()

function transform2D_rotateFromVector(x, y, rvx, rvy) {// The angle is determined by the 2D vector (rvx, rvy).
  var alpha= atan2(rvy, rvx);
  return transform2D_rotate(x, y, rad2deg(alpha));
}//~transform2D_rotateFromVector()

function transform2D_viewport(x, y, xmin, ymin, xmax, ymax) {// Move the point (x, y) to the new coordinate system [left, top, right, bottom ]: from [ 0.0, 0.0, 1.0, 1.0] to [xmin, ymin, xmax, ymax].
  return transform2D_matrixSVG(x, y, [(xmax- xmin), 0.0, 0.0, (ymax- ymin), xmin, ymin]);
}//~transform2D_viewport()
</SCRIPT>
<SCRIPT>
function getViewport() {
  var rt= new Rect();
  rt.copy(window._PIXELS.viewport);
  rt.width= rt.right- rt.left;
  rt.height= rt.bottom- rt.top;
  return rt;
  //return vector_copy(window._PIXELS.viewport.valueOf());
}

function setViewport(rt) {
  var r= window._PIXELS.viewport;
  if(!arguments.length) {//reset
    r.reshape(0, 0, window.screen.width- 1, window.screen.height- 1);
  } else {
    if(rt.constructor== Rect) {
      r.copy(rt);
    }else {
      r.reshape(rt[0], rt[1], rt[2], rt[3]);
    }
  }
  r.width= r.right- r.left;
  r.height= r.bottom- r.top;
}//~setViewport()

function ClearViewport(bErase) {
  var pixels= window._PIXELS;
  var pool= window._PIXEL_POOL;
  while(pixels.length) {
    var px= pixels.pop();
    px.style.display= 'none';
    pool.push(px);
  }
  if(bErase) {
    while(pool.length) {
      var obj= pool.pop();
      obj.parentNode.removeChild(obj);
    }
  }
}//~ClearViewport()

function InitGRAPHICS() {
  window._PIXEL_POOL= [];
  window._PIXELS= [];
  window._PIXELS.viewport= new Rect(0, 0, window.screen.width- 1, window.screen.height- 1);
  //window._PIXELS.viewport.scale(0.5);
  //window._PIXELS.viewport.translate(100, 100);
  //setViewport();
  window.clearViewport= ClearViewport;
  initg();
}//~InitGRAPHICS;

function initg() {
/*
   var r= document.body.getClientRects();
   r= r[0]; // if (r.length== 1)
   var left, top, right, bottom;
   left= r.left; top= r.top; right= r.right; bottom= r.bottom;
*/
   var b= document.body;
   b.scroll= "no";
   if((window.width== undefined)|| (window.width== 0)) window.width= document.body.scrollWidth;
   if((window.height== undefined)|| (window.height== 0)) window.height= document.body.scrollHeight;
   return true;
}

function closegraph() {return true;}
function getmaxx() {return window.width;}
function getmaxy() {return window.height;}

function ShowGrid(bShow) {
  var o= arguments.callee;
  if(o.l== undefined) {
    o.l= [];
  }
  if(bShow) {
    var w, h, i, c;
    w= getmaxx();
    h= getmaxy();
    c= rgb2hex(128, 128, 128);
    for(i= 1; i< w; i+= 4) {
      o.l.push(vline(i, 0, h, c));
    }
    for(i= 1; i< h; i+= 4) {
      o.l.push(hline(0, i, w, c));
    }
  }else {
    var n= o.l.length;
    for(i= 0; i< n; i++) o.l.pop().CloseWindow();
  }
}//~ShowGrid()

function Point2D(x, y) { // cartesian coordinates in 2D
   function move(x, y) {
      this.x= x; // abscissa
      this.y= y; // ordinate
   }
   function scale(x, y) {
      if(arguments.length== 1) y= x;
      this.x*= x;
      this.y*= y;
   }
   function translate(x, y) {
      if(arguments.length== 1) y= x;
      this.x+= x;
      this.y+= y;
   }
   function rotate(c, alpha) {
      if(arguments.length== 1) {//"rotate around Origin"
        alpha= arguments[0];
        c= new Point2D(0, 0);
      }
      this.copy(rotplan(c, this, alpha));
   }
   function skew(sx, sy) {//TODO
     SetLastError(['Point2D.skew not Implemented!', Errors.NotImplemented, get_call_stack(arguments.callee)]);

   }
   function transform(a, b, c, d, e, f, g, h, i) {
     var w, x, y;
     x= this.x;
     y= this.y;
     w= (g* x+ h* y+ i);
     w= ((w!= 0.0)? (1.0/ w): NaN);//w= ((w!= 0.0)? (1.0/ w): 0.0);
     this.x= w* (a* x+ b* y+ c);
     this.y= w* (d* x+ e* y+ f);
   }
   function normalize() {
     var r= sqrt(this.x* this.x+ this.y* this.y);
     if(r!= 0.0) this.scale(1/ r);
   }
   function angle(c) {
     if(!arguments.length) return atan2(this.y, this.x);//"return angle in radians; relative to Origin"
     return atan2(this.y- c.y, this.x- c.x); //"relative to Center (c.x, c.y)"
   }
   function angleTo(p) {
     return p.angle(this);
   }
   function sector(n, bOblique) {
     //return this.sectorAt(new Point2D(0, 0), n, bOblique);
     var x, y;
     x= this.x;
     y= this.y;
     n= parseInt(n);
     n= ((!n)? 0x100000000: abs(n));//"resolution"
     if (bOblique) return floor(
      n* revolve(u2t((1.0/ Math.PI)* atan2(-y, -x)), 1.0/ (2.0* n))
     );
     return floor(
      n* u2t((1.0/ Math.PI)* atan2(-y, -x))
     );
   }
   function sectorAt(p, n, bOblique) {
     //SetLastError(['Point2D.sectorAt not Implemented!', Errors.NotImplemented, get_call_stack(arguments.callee)]);
     var x, y;
     x= this.x- p.x;
     y= this.y- p.y;
     n= parseInt(n);
     n= ((!n)? 0x100000000: abs(n));//"resolution; number of sectors"
     if (bOblique) return floor(
      n* revolve(u2t((1.0/ Math.PI)* atan2(-y, -x)), 1.0/ (2.0* n))
     );
     return floor(
      n* u2t((1.0/ Math.PI)* atan2(-y, -x))
     );
   }
   function quadrant(bOblique) {
     if(bOblique) {
       var x, y, ax, ay;
       x= this.x;
       y= this.y;
       ax= ((x>= 0)? x: -x);//"abs()"
       ay= ((y>= 0)? y: -y);//"abs()"
       if(ax== ay) return [3, 0, 2, 1][(
         ((y> 0)<< 1)|
         (x> 0)
       )];
       return [1, 2, 0, 3][(
        ((y< x)<< 1)^
        (y< -x)
       )];
     }
     return (//TODO: Optimize.
       ((((((this.y< 0)+ 0)<< 1)+ ((this.x< 0)+ 0)))^ (1& (this.y< 0))) //return ([0, 1, 3, 2][((((this.y< 0)+ 0)<< 1)+ ((this.x< 0)+ 0))]);//TODO: Faster?
       +
       (((this.x== 0)&& (this.y> 0))| ((this.y== 0)&& (this.x< 0))) // (((this.x== 0)&& (this.y> 0))+ ((this.y== 0)&& (this.x< 0)))
     );//NOTE: "The first two bits (Most Significant Bits) of atan2()."
   }
   function quadrantAt(p, bOblique) {
     if(bOblique) {
       var x, y, ax, ay;
       x= this.x- p.x;
       y= this.y- p.y;
       ax= ((x>= 0)? x: -x);//"abs()"
       ay= ((y>= 0)? y: -y);//"abs()"
       if(ax== ay) return [3, 0, 2, 1][(
         ((y> 0)<< 1)|
         (x> 0)
       )];
       return [1, 2, 0, 3][(
        ((y< x)<< 1)^
        (y< -x)
       )];
     }
     return (//TODO: Optimize.
       ((((((this.y- p.y)< 0)+ 0)<< 1)+ (((this.x- p.x)< 0)+ 0))^ (1& ((this.y- p.y)< 0))) //return ([0, 1, 3, 2])[(((((this.y- p.y)< 0)+ 0)<< 1)+ (((this.x- p.x)< 0)+ 0))];//TODO: Faster?
       +
       ((((this.x- p.x)== 0)&& ((this.y- p.y)> 0))+ (((this.y- p.y)== 0)&& ((this.x- p.x)< 0)))
     );
   }
   function octant(bOblique) {
     if(bOblique) {//TODO: Test for consistency.
       return this.sector(8, true);
       //SetLastError(['Point2D.octant: bOblique= '+ bOblique+ ' not Implemented!', Errors.NotImplemented, get_call_stack(arguments.callee)]); return NaN;
     }
     var a, b;
     a= this.quadrant();
     b= this.quadrant(true);
     return ((a<< 1)| ((a^ b)& 1));
     //var p= this; return [5, 4, 6, 7, 2, 3, 1, 0][ ((p.y> 0)<< 2)| ((p.x> 0)<< 1)| ((p.y< p.x)^ (p.y< -p.x))];//BUG!
   }
   function octantAt(p, bOblique) {
     if(bOblique) {//TODO: Test for consistency.
       return this.sectorAt(p, 8, bOblique);
     }
     var a, b;
     a= this.quadrantAt(p);
     b= this.quadrantAt(p, true);
     return ((a<< 1)| ((a^ b)& 1));
     //var x, y; x= this.x- p.x; y= this.y- p.y; return [5, 4, 6, 7, 2, 3, 1, 0][((y> 0)<< 2)| ((x> 0)<< 1)| ((y< x)^ (y< -x))];//BUG: Fast but incomplete or inconsistent!
   }
   function equals(p) {
      if(arguments.length== 1 && typeof(p)== "object" && p.constructor=== Point2D) {
         return (this.x== p.x)&& (this.y== p.y);
      }else return false;
   }
   function copy(p) {
      if(arguments.length== 0) return new Point2D(this.x, this.y);
      if(arguments.length== 1 && typeof(p)== "object" && p.constructor=== Point2D) {
         this.x= p.x;
         this.y= p.y;
      }
   }
   function distanceTo(p) {
      if(arguments.length== 0) return sqrt(this.x* this.x+ this.y* this.y);
      if(arguments.length== 1 && typeof(p)== "object" && p.constructor=== Point2D) {
         return sqrt(sqr(this.x- p.x)+ sqr(this.y- p.y));
      }
   }
   function valueOf() {return [this.x, this.y];}
   function toString() {return this.valueOf().toString()}
   this.move= move;
   this.scale= scale;
   this.translate= translate;
   this.rotate= rotate;
   this.skew= skew;
   this.transform= transform;
   this.normalize= normalize;
   this.angle= angle;
   this.angleTo= angleTo;
   this.angleAt= angleTo;
   this.sector= sector;
   this.sectorAt= sectorAt;
   this.quadrant= quadrant;
   this.quadrantAt= quadrantAt;
   this.octant= octant;
   this.octantAt= octantAt;
   this.equals= equals;
   this.copy= copy;
   this.distanceTo= distanceTo;
   this.valueOf= valueOf;
   this.toString= toString;
   this.move(x, y);
   return this;
}//~Pont2D.
function Point3D(x, y, z) { // cartesian coordinates in 3D
   function equal(P) {
     var tolerance= 0.000000001;//error tolerance
     return (
       (fabs(this.x- P.x)<= tolerance)&&
       (fabs(this.y- P.y)<= tolerance)&&
       (fabs(this.z- P.z)<= tolerance)
     );
   }//~Point3D.equal()
   function move(x, y, z) {
      this.x= x; // abscissa
      this.y= y; // ordinate
      this.z= z; // elevation (pitch?..)
   }
   function scale(x, y, z) {
      if(arguments.length== 1) {y= x; z= x;}
      if(arguments.length== 2) z= 1.0;
      this.x*= x;
      this.y*= y;
      this.z*= z;
   }
   function translate(x, y, z) {
      if(arguments.length== 1) {y= x; z= x;}
      if(arguments.length== 2) z= 0.0;
      this.x+= x;
      this.y+= y;
      this.z+= z;
   }
   function CrossProduct(P1, P2) {//P= P1 x P2 (Cross product of two vectors)
      if(arguments.length== 2) {//store result in current point (as vector)
        this.x= P1.y* P2.z- P1.z* P2.y;
        this.y= P1.z* P2.x- P1.x* P2.z;
        this.z= P1.x* P2.y- P1.y* P2.x;
        return this;
      }else {//create a new vector from information in this point and P1
	    var P3= new Point3D(
          this.y* P1.z- this.z* P1.y,
          this.z* P1.x- this.x* P1.z,
          this.x* P1.y- this.y* P1.x
	    );
	    return P3;//return new vector (as 3D point)
	  }
   }//~Point3D.CrossProduct()
   function DotProduct(P1, P2) {
	  if(arguments.length== 2)
        return (P1.x* P2.x+ P1.y* P2.y+ P1.z* P2.z);
      else
        return (P1.x* this.x+ P1.y* this.y+ P1.z* this.z);
   }
   function distance(P1, P2) {
     if(arguments.length== 0) return this.length();
     if(arguments.length== 1) return this.length(P1);
     if(arguments.length== 2) return this.length(P1, P2);
   }
   function length(P1, P2) {
     if(arguments.length== 0) return Math.sqrt(this.x* this.x+ this.y* this.y+ this.z* this.z);
     if(arguments.length== 1) return Math.sqrt(sqr(P1.x- this.x)+ sqr(P1.y- this.y)+ sqr(P1.z- this.z));
     if(arguments.length== 2) return Math.sqrt(sqr(P2.x- P1.x)+ sqr(P2.y- P1.y)+ sqr(P2.z- P1.z));
   }
   function normalize() {//as a vector
     var length;
     length= this.length();//Math.sqrt(this.x* this.x+ this.y* this.y+ this.z* this.z);
     if(length!= 0.0) {
	   this.x/= length;
	   this.y/= length;
	   this.z/= length;
	 }else this.move(0, 0, 0);
   }
   function valueOf() {return [this.x, this.y, this.z];}
   function toString() {return this.valueOf().toString();}
   this.valueOf= valueOf;
   this.toString= toString;
   this.equal= equal;
   this.move= move;
   this.scale= scale;
   this.translate= translate;
   
   //TODO:rotate:PITCH,ROLL,YAW;
   //TODO:rotateX, rotateY, rotateZ;
   //TODO:projection:PERSPECTIVE,ORTHOGRAPHIC;
   //TODO:byMatrix3D(m): SEE:Matrix3D.
   
   this.CrossProduct= CrossProduct;
   this.DotProduct= DotProduct;
   this.length= length;
   this.distance= distance;
   this.normalize= normalize;
   this.move(x, y, z);
}//~Point3D.

function Vector3D(x, y, z, w) {// define a vector in homogeneous space
  if(this.constructor!= arguments.callee)//object always
    switch(arguments.length) {
      case 0: return new arguments.callee();
      case 1: return new arguments.callee(x);
      case 2: return new arguments.callee(x, y);
      case 3: return new arguments.callee(x, y, z);
      case 4: return new arguments.callee(x, y, z, w);
      default: return new arguments.callee(x, y, z, w);
    };

  function set(x, y, z, w) {
    if(arguments.length== 1) {
      var v1= arguments[0];
      this.x= v1.x;
      this.y= v1.y;
      this.z= v1.z;
      this.w= v1.w;
      return this;
    }
    this.x= x;
    this.y= y;
    this.z= z;
    this.w= ((arguments.length>= 4)? w: 0);
    return this;
  }//~Vector3D.set()
  function copy(v1) {//create a new vector with same info as v1 (or this if not v1)
    if(!arguments.length) return new Vector3D(this.x, this.y, this.z, this.w);
    return new Vector3D(v1.x, v1.y, v1.z, v1.w);
  }//~Vector3D.copy()
  function equal(v1) {
    var tolerance= 0.000000001;//error tolerance
    return (
      (fabs(this.x- v1.x)<= tolerance)&&
      (fabs(this.y- v1.y)<= tolerance)&&
      (fabs(this.z- v1.z)<= tolerance)
    );
  }//~Vector3D.equal()
  function magnitudeSquared() {
    return (sqr(this.x)+ sqr(this.y)+ sqr(this.z));
  }//~Vector3D.magnitudeSquared()
  function magnitude() {
    return sqrt(this.magnitudeSquared());
  }//~Vector3D.magnitude()
  function normalize() {
    if(this.isOrigin()) {// The null vector does not have magnitude because it does not point to anywhere specific.
      var rn= this.random_normal(); //So, we choose a random direction to point to, explicitly. We definitely need a direction here. And any valid one will do.
      return this.set(rn.x, rn.y, rn.z, 0);
    }
    return this.multiply(1.0/ this.magnitude());
  }//~Vector3D.normalize()
  function normal() {
    return this.copy().normalize();
  }//~Vector3D.normal()
  function random_normal() {
    return (new Vector3D(
        (sgn(random()* 2.0- 1.0)* random()),
        (sgn(random()* 2.0- 1.0)* random()),
        (sgn(random()* 2.0- 1.0)* random()),
        0
      ).normalize()
    );
  }//~Vector3D.random_normal()
  function add(v1) {
    this.x+= v1.x;
    this.y+= v1.y;
    this.z+= v1.z;
    this.w= 0;
    return this;
  }//~Vector3D.add()
  function subtract(v1) {
    this.x-= v1.x;
    this.y-= v1.y;
    this.z-= v1.z;
    this.w= 0;
    return this;
  }//~Vector3D.subtract()
  function multiply(t) {//by a scalar
    this.x*= t;
    this.y*= t;
    this.z*= t;
    this.w= 0;
    return this;
  }//~Vector3D.multiply()
  function divide(t) {//by a scalar
    return this.multiply(1.0/ t);
  }//~Vector3D.divide()
  function dot(v1) {//dot product
    return (this.x* v1.x+ this.y* v1.y+ this.z* v1.z);
  }//~Vector3D.dot()
  function cross(v1) {//cross product (is not commutative)
    return new Vector3D(
      (this.y* v1.z- this.z* v1.y),
      (this.z* v1.x- this.x* v1.z),
      (this.x* v1.y- this.y* v1.x),
      0
    );// Unless the v1 and v2 are not collinear, the resulting vector is orthogonal on them both.
  }//Vector3D.cross()
  function angleTo(v1) {//get the angle to v1
    var va, vb, alpha;
    va= ((this.isOrigin())? (new Vector3D(0, 0, 0)): (this.copy().normalize()));
    vb= ((v1.isOrigin())? (new Vector3D(0, 0, 0)): (v1.copy().normalize()));
    alpha= acos(clip(va.dot(vb), -1.0, 1.0));
    return alpha;
  }//Vector3D.angleTo()
  function distanceToSquared(v1) {
    return this.copy().subtract(v1).magnitudeSquared();
  }//~Vector3D.distanceToSquared()
  function distanceTo(v1) {//the Euclidean distance
    return this.copy().subtract(v1).magnitude();
  }//~Vector3D.distanceTo()
  function isOrigin() {
    return this.equal(new Vector3D(0, 0, 0));
  }//~Vector3D.isOrigin()
  function isOrthogonal(v1) {
    var tolerance= Math.DELTA;//error tolerance
    return ((fabs(0.5* Math.PI)- this.angleTo(v1))<= tolerance);
  }//~Vector3D.isOrthogonal()
  function orthogonal(v1) {// the resulting vector is orthogonal on the plane that contains the v1 vector and this vector.
    if(!arguments.length) v1= this.random_normal();
    var v2= this.cross(v1);// Unless the v1 and v2 are not collinear, the resulting vector is orthogonal on them both.
    if(v2.isOrigin()) {// Get a random vector in the plane perpendicular to the segment between the tail and the tip of vector v1.
      if(!v1.isOrigin()) {
        v2= v1.cross(this.random_normal()).normalize();
      }else {
        v2= this.cross(this.random_normal()).normalize();
      }
      return v2;
    }
    v2.normalize();
    return v2;// perpendicular (forms 90 degrees with 'this' vector and v1 vector, simultaneously) 
  }//~Vector3D.orthogonal()
  function transform(m4x4) {
    var m, v;
    m= m4x4.valueOf();
    v= [this.x, this.y, this.z, this.w];
    return new Vector3D(
      (m[0][0]* v[0]+ m[0][1]* v[1]+ m[0][2]* v[2]+ m[0][3]* v[3]),
      (m[1][0]* v[0]+ m[1][1]* v[1]+ m[1][2]* v[2]+ m[1][3]* v[3]),
      (m[2][0]* v[0]+ m[2][1]* v[1]+ m[2][2]* v[2]+ m[2][3]* v[3]),
      (m[3][0]* v[0]+ m[3][1]* v[1]+ m[3][2]* v[2]+ m[3][3]* v[3])
    );
  }//~Vector3D.transform()
  function normal_from_angles(phi, tau) {//SeeAlso: Spherical2Cartesian.
    var r, x, y, z
    r= 1.0;
    x= (r* sin(phi)* cos(tau));
    y= (r* sin(phi)* sin(tau));
    z= (r* cos(phi));
    return (new Vector3D(x, y, z, 0));
  }//~Vector3D.normal_from_angles()
  function angles_from_normal() {//SeeAlso: Cartesian2Spherical. NOTE: Euler angles?
    var P, r, phi, tau;
    P= this.normal();
    r= P.magnitude();//sqrt(sqr(P.x)+ sqr(P.y)+ sqr(P.z));//r= 1.0;
    phi= acos(P.z/ r);
    tau= atan2(P.y, P.x);
    return [phi, tau];
  }//~Vector3D.normal_from_angles()
  function valueOf() {
    return [this.x, this.y, this.z, this.w];
  }//~Vector3D.valueOf()
  function toString() {
    if(!this.w) return ("("+ this.x+ ", "+ this.y+ ", "+ this.z+ ")");
    return ("("+ this.x+ ", "+ this.y+ ", "+ this.z+ ", "+ this.w+ ")");
  }//~Vector3D.toString()
  this.set= set;
  this.copy= copy;
  this.equal= equal;
  this.magnitudeSquared= magnitudeSquared;
  this.magnitude= magnitude;
  this.normalize= normalize;
  this.normal= normal;
  this.random_normal= random_normal;
  this.add= add;
  this.sum= add;
  this.subtract= subtract;
  this.sub= subtract;
  this.multiply= multiply;
  this.mul= multiply;
  this.divide= divide;
  this.div= divide;
  this.dot= dot;
  this.cross= cross;
  this.angleTo= angleTo;
  this.distanceToSquared= distanceToSquared;
  this.distanceTo= distanceTo;
  this.isOrigin= isOrigin;
  this.isOrthogonal= isOrthogonal;
  this.orthogonal= orthogonal;
  this.perpendicular= orthogonal;
  this.transform= transform;
  this.normal_from_angles= normal_from_angles;
  this.angles_from_normal= angles_from_normal;
  this.valueOf= valueOf;
  this.toString= toString;
  this.x= x;
  this.y= y;
  this.z= z;
  this.w= w;
  if(arguments.length<= 3) this.w= 0;//vector
  return this;
}//~Vector3D()

function Matrix3D(m) {//a 4x4 matrix
  if(this.constructor!= arguments.callee)//object always
    if(arguments.length)
      return new arguments.callee(m)
    else return new arguments.callee();
  if(arguments.length) return this.set(m);
  this.m= this.create();
  this.setZero();
  return this;
}//~Matrix3D()
Matrix3D.prototype= {
  constructor:Matrix3D //BUG-FIX:[all?]
  ,precision: 1e-6
  ,create:function() {
    var m, i;
    m= [];
    for(i= 0; i< 4; i++) m[i]= [];
    return m;
  }//~Matrix3D.create()
  ,set:function(m) {
    var i, j;
    if(!this.m) this.m= this.create();
    if(!arguments.length) return this.setZero();
    m= m.valueOf();
    for(i= 0; i< 4; i++)
      for(j= 0; j< 4; j++) this.m[i][j]= m[i][j];
    return this;
  }//~Matrix3D.set()
  ,copy:function(m) {
    if(!arguments.length) return new this.constructor(this.m);
    return new this.constructor(m.valueOf());
  }//~Matrix3D.copy()
  ,setZero:function() {
     var i, j;
     for(i= 0; i< 4; i++)
       for(j= 0; j< 4; j++) this.m[i][j]= 0.0;
     return this;
   }//~Matrix3D.setZero()
   ,setIdentity:function() {
    var i;
    this.setZero();
    for(i= 0; i< 4; i++) this.m[i][i]= 1.0;
    return this;
  }//~Matrix3D.setIdentity()
  ,setRandom:function() {
    var i, j, x;
    for(i= 0; i< 4; i++)
      for(j= 0; j< 4; j++) {
        x= ((Math.random()>= 0.5)? Math.random(): -Math.random());
        this.m[i][j]= x;
      }
  }//~Matrix3D.setRandom()
  ,multiply:function(m) {
    var i, j, x;
    if(!m.valueOf().length) {//multiply a matrix by a scalar
      x= m.valueOf();
      for(i= 0; i< 4; i++) {
        for(j= 0; j< 4; j++) {
          this.m[i][j]*= x;
        }
      }
    }else {
      if(m.constructor== this.constructor) {//multiply two matrices
        //echo("TODO: Multiply a matrix by a matrix");//dbg
        var a, b, c;
        a= m.valueOf();
        b= this.m;
        c= [ [//TODO:TEST MORE!
          a[0][0]* b[0][0]+ a[0][1]* b[1][0]+ a[0][2]* b[2][0] + a[0][3]* b[3][0],
          a[0][0]* b[0][1]+ a[0][1]* b[1][1]+ a[0][2]* b[2][1] + a[0][3]* b[3][1],
          a[0][0]* b[0][2]+ a[0][1]* b[1][2]+ a[0][2]* b[2][2] + a[0][3]* b[3][2],
          a[0][0]* b[0][3]+ a[0][1]* b[1][3]+ a[0][2]* b[2][3] + a[0][3]* b[3][3]          //0.0
          ], [
          a[1][0]* b[0][0]+ a[1][1]* b[1][0]+ a[1][2]* b[2][0] + a[1][3]* b[3][0],
          a[1][0]* b[0][1]+ a[1][1]* b[1][1]+ a[1][2]* b[2][1] + a[1][3]* b[3][1],
          a[1][0]* b[0][2]+ a[1][1]* b[1][2]+ a[1][2]* b[2][2] + a[1][3]* b[3][2],
          a[1][0]* b[0][3]+ a[1][1]* b[1][3]+ a[1][2]* b[2][3] + a[1][3]* b[3][3]          //0.0
          ], [
          a[2][0]* b[0][0]+ a[2][1]* b[1][0]+ a[2][2]* b[2][0] + a[2][3]* b[3][0],
          a[2][0]* b[0][1]+ a[2][1]* b[1][1]+ a[2][2]* b[2][1] + a[2][3]* b[3][1],
          a[2][0]* b[0][2]+ a[2][1]* b[1][2]+ a[2][2]* b[2][2] + a[2][3]* b[3][2],
          a[2][0]* b[0][3]+ a[2][1]* b[1][3]+ a[2][2]* b[2][3] + a[2][3]* b[3][3]          //0.0
          ], [
          a[3][0]* b[0][0]+ a[3][1]* b[1][0]+ a[3][2]* b[2][0] + a[3][3]* b[3][0],
          a[3][0]* b[0][1]+ a[3][1]* b[1][1]+ a[3][2]* b[2][1] + a[3][3]* b[3][1],
          a[3][0]* b[0][2]+ a[3][1]* b[1][2]+ a[3][2]* b[2][2] + a[3][3]* b[3][2],
          a[3][0]* b[0][3]+ a[3][1]* b[1][3]+ a[3][2]* b[2][3] + a[3][3]* b[3][3]          //1.0
        ] ];
        this.m= c;
      }else {//multiply a matrix by a vector
        echo("TODO: Multiply a matrix by a vector");//dbg
        //:
        //.
      }
    }
    return this;
  }//~Matrix3D.multiply()
  ,setTranslate:function(tx, ty, tz) {
    this.m=[
    [1.0, 0.0, 0.0,  tx],
    [0.0, 1.0, 0.0,  ty],
    [0.0, 0.0, 1.0,  tz],
    [0.0, 0.0, 0.0, 1.0]
    ];
    return this; 
  }//~Matrix3D.setTranslate()
  ,setScale:function(sx, sy, sz) {
    this.m=[
    [ sx, 0.0, 0.0, 0.0],
    [0.0,  sy, 0.0, 0.0],
    [0.0, 0.0,  sz, 0.0],
    [0.0, 0.0, 0.0, 1.0]
    ];
    return this; 
  }//~Matrix3D.setScale()
  ,setRotateX:function(alpha) {//"x: pitch (up)"
    //return this.setRotate([1, 0, 0], alpha);
    var s, c;
    c= Math.cos(alpha);
    s= Math.sin(alpha);
    this.m= [
    [1.0, 0.0, 0.0, 0.0],
    [0.0,   c,   s, 0.0],
    [0.0,  -s,   c, 0.0],
    [0.0, 0.0, 0.0, 1.0]
    ];
    return this;
  }//~Matrix3D.setRotateX()
  ,setRotateY:function(alpha) {//"y: roll (clockwise)"
    //return this.setRotate([0, 1, 0], alpha);
    var s, c;
    c= Math.cos(alpha);
    s= Math.sin(alpha);
    this.m= [
    [  c, 0.0,  -s, 0.0],
    [0.0, 1.0, 0.0, 0.0],
    [  s, 0.0,   c, 0.0],
    [0.0, 0.0, 0.0, 1.0]
    ];
    return this;
  }//~Matrix3D.setRotateY()
  ,setRotateZ:function(alpha) {"z: yaw (left)"
    //return this.setRotate([0, 0, 1], alpha);
    var s, c;
    c= Math.cos(alpha);
    s= Math.sin(alpha);
    this.m= [
    [  c,   s, 0.0, 0.0],
    [ -s,   c, 0.0, 0.0],
    [0.0, 0.0, 1.0, 0.0],
    [0.0, 0.0, 0.0, 1.0]
    ];
    return this;
  }//~Matrix3D.setRotateZ()
  ,setRotate:function(v_axis, alpha, bNormalAxis) {
    var vx, vy, vz, vx2, vy2, vz2, s, c, c1;
    vx = v_axis[0];
    vy = v_axis[1];
    vz = v_axis[2];
    if(bNormalAxis) {
	  var p= new Point3D(vx, vy, vz);
	  p.normalize();
	  vx= p.x;
	  vy= p.y;
	  vz= p.z;
	}
    vx2= vx* vx;
    vy2= vy* vy;
    vz2= vz* vz;
    c = Math.cos(alpha);
    s = Math.sin(alpha);
    c1= 1.0- c;
    this.m= [
    [       vx2* c1+ c, vx* vy* c1+ vz* s, vz* vx* c1- vy* s, 0.0],
    [vx* vy* c1- vz* s,        vy2* c1+ c, vy* vz* c1+ vx* s, 0.0],
    [vz* vx* c1+ vy* s, vy* vz* c1- vx* s,        vz2* c1+ c, 0.0],
    [              0.0,               0.0,               0.0, 1.0]
    ];
    return this;
  }//~Matrix3D.setRotate()
  ,setLookAt:function(ex, ey, ez, cx, cy, cz, ux, uy, uz) {// gluLookAt
    var eye, center, up, vx, vy, vz, m;
    eye= new Point3D(ex, ey, ez);
    center= new Point3D(-cx, -cy, -cz);
    up= new Point3D(ux, uy, uz);
    eye.translate(center.x, center.y, center.z);
    vz= new Point3D(eye.x, eye.y, eye.z);
    vz.normalize();
    up.CrossProduct(vz);
    vx= new Point3D(up.x, up.y, up.z);
    vz.normalize();
    vz.CrossProduct(vx);
    vy= new Point3D(vz.x, vz.y, vz.z);
    vy.normalize();
    this.set([
      [vx.x, vx.y, vx.z, 0.0],
      [vy.x, vy.y, vy.z, 0.0],
      [vz.x, vz.y, vz.z, 0.0],
      [0.0, 0.0, 0.0, 1.0]
    ]);
    m= new Matrix3D([
      [1.0, 0.0, 0.0, -ex],
      [0.0, 1.0, 0.0, -ey],
      [0.0, 0.0, 1.0, -ez],
      [0.0, 0.0, 0.0, 1.0]
    ]);
    this.multiply(m);
    return this;
  }//~Matrix3D.setLookAt()
  ,setOrtho:function(left, right, bottom, top, znear, zfar) {// glOrtho
     return this.set([
       [2.0/ (right- left), 0, 0, -1.0* (right+ left)/ (right- left)],
       [0, 2.0/ (top- bottom), 0, -1.0* (top+ bottom)/ (top- bottom)],
       [0, 0, -2.0/ (zfar- znear), -1.0* (zfar+ znear)/ (zfar- znear)],
       [0, 0, 0, 1]
    ]);
  }//~Matrix3D.setOrtho()
  ,setPerspective:function(fovy, aspect, znear, zfar) {// gluPerspective
    var xmin, xmax, ymin, ymax;
    ymax= znear* Math.tan(fovy* Math.PI/ 360.0);
    ymin= -ymax;
    xmax= ymax* aspect;
    xmin= ymin* aspect;
    return this.setByFrustum(xmin, xmax, ymin, ymax, znear, zfar);
  }//~Matrix3D.setPerspective()
  ,setByFrustum:function(left, right, bottom, top, znear, zfar) {// glFrustum
     return this.set([
       [2.0* znear/ (right- left), 0, (right+ left)/ (right- left), 0],
       [0, 2.0* znear/ (top- bottom), (top+ bottom)/ (top- bottom), 0],
       [0, 0, -1.0* (zfar+ znear)/ (zfar- znear), -2.0* zfar* znear/ (zfar- znear)],
       [0, 0, -1, 0]
     ]);
  }//~Matrix3D.setByFrustum()
  ,translate:function(v) {
    var m= this.m;
    m[3][0]+= v[0];
    m[3][1]+= v[1];
    m[3][2]+= v[2];
    return this;
  }//~Matrix3D.translate()
  ,scale:function(v) {
    m[0][0]*= v[0];
    m[1][1]*= v[1];
    m[2][2]*= v[2];
    return this;
  }//~Matrix3D.scale()
  ,transform:function(v) {//transform a vector (3D) by a matrix (4x3) (vector multiplication)
    var r, m;
    m= this.m;
    r= [];
    if(v.length== 3) {
      r[0]= v[0]* m[0][0]+ v[1]* m[1][0]+ v[2]* m[2][0]+ m[3][0];
      r[1]= v[0]* m[0][1]+ v[1]* m[1][1]+ v[2]* m[2][1]+ m[3][1];
      r[2]= v[0]* m[0][2]+ v[1]* m[1][2]+ v[2]* m[2][2]+ m[3][2];
    }else if(v.length== 4){
      r[0]= v[0]* m[0][0]+ v[1]* m[1][0]+ v[2]* m[2][0]+ v[3]* m[3][0];
      r[1]= v[0]* m[0][1]+ v[1]* m[1][1]+ v[2]* m[2][1]+ v[3]* m[3][1];
      r[2]= v[0]* m[0][2]+ v[1]* m[1][2]+ v[2]* m[2][2]+ v[3]* m[3][2];
      r[3]= v[0]* m[0][3]+ v[1]* m[1][3]+ v[2]* m[2][3]+ v[3]* m[3][3];
    }
    return r;
  }//~Matrix3D.transform()
  ,fromSVG:function(a, b, c, d, e, f) {//Get a 3D transform matrix from a 2D SVG transform matrix.
    a = parseFloat(a);
    b = parseFloat(b);
    c = parseFloat(c);
    d = parseFloat(d);
    e = parseFloat(e);
    f = parseFloat(f);
    this.m= [[  a,   c, 0.0,   e],
             [  b,   d, 0.0,   f],
             [0.0, 0.0, 1.0, 0.0],
             [0.0, 0.0, 0.0, 1.0]];
    return this;
  }//~Matrix3D.fromSVG()
  ,valueOf:function() {return this.m;}
  ,toString:function() {return this.valueOf().toString();}
};//~Matrix3D.prototype
window.Matrix3D= Matrix3D;

function Polar(r, phi) { // polar coordinates
   this.r= r; // radius
   this.phi= phi; // angle
   function valueOf() {return [this.r, this.phi];}
   function toString() {return this.valueOf().toString();}
   this.valueOf= valueOf;
   this.toString= toString;
}

function Spherical(r, phi, tau) { // spherical coordinates
   this.r= r; // radius
   this.phi= phi; // angle1
   this.tau= tau; // angle2
   function valueOf() {return [this.r, this.phi, this.tau];}
   function toString() {return this.valueOf().toString();}
   this.valueOf= valueOf;
   this.toString= toString;
   return this;
}//~Spherical()

function Spherical2Cartesian(r, phi, tau) {
  var x, y, z;
  if(arguments.length== 1) {
    phi= r.phi;
    tau= r.tau;
    r= r.r;
  }
  x= r* sin(phi)* cos(tau);
  y= r* sin(phi)* sin(tau);
  z= r* cos(phi);
  return new Point3D(x, y, z);
}//~Spherical2Cartesian()

/*
function Cartesian2Spherical(P) {//BUG!!!
  var r, phi, tau;
  r= sqrt(sqr(P.x)+ sqr(P.y)+ sqr(P.z));
  phi= sign(P.y) * acos(P.x/ sqrt(sqr(P.x)+ sqr(P.y)));
  tau= acos(P.z/ r);
  return new Spherical(r, phi, tau);
}//~Cartesian2Spherical()
*/

function Cartesian2Spherical(P) {
  var r, phi, tau;
  r= sqrt(sqr(P.x)+ sqr(P.y)+ sqr(P.z));
  phi= acos(P.z/ r);
  tau= atan2(P.y, P.x);
  return new Spherical(r, phi, tau);
}//~Cartesian2Spherical()

//Cartesian= Point2D;
Cartesian= Point3D;

function polar(p) { // cartesian 2 polar
   var a= new Polar(hypot(p.x, p.y), atan2(p.x, p.y));
   if(a.r== 0.0) a.phi= 0.0;
   return a;
}
function cartesian(a) { // polar 2 cartesian
   var p= new Cartesian((a.r* sin(a.phi)), (a.r* cos(a.phi)));
   return p;
}

function rotplan(c, p, alpha) {
   var q= new Point2D(
      c.x+ (p.x- c.x)* cos(alpha)- (p.y- c.y)* sin(alpha)
   ,
      c.y+ (p.x- c.x)* sin(alpha)+ (p.y- c.y)* cos(alpha)
   );
   return q;
}

function _rotplan(cx, cy, px, py, alpha) {
  return [
      cx+ (px- cx)* cos(alpha)- (py- cy)* sin(alpha)
  ,
      cy+ (px- cx)* sin(alpha)+ (py- cy)* cos(alpha)
  ];
}//~_rotplan()

function d3d2g(p, alpha, beta, gamma) {
   var q= new Point2D(
      p.x* cos(alpha)+ p.y* cos(beta)+ p.z* cos(gamma)
   ,
      p.x* sin(alpha)+ p.y* sin(beta)+ p.z* cos(gamma)
   );
   return q;
}
function d3d2n(p) {
   var q= new Point2D(
      round(p.x+ sqrt(2)* p.z/ 4)
   ,
      round(p.y+ sqrt(2)* p.z/ 4)
   );
   return q;
}
function d3d2(p) { // pentru proiectia cabinet (alfa= 0, beta= 90, gama= 45)
   var q= new Point2D(
      getmaxx()/ 2+ round(p.x+ sqrt(2)* p.z/ 4)
   ,
      getmaxy()/ 2- round(p.y+ sqrt(2)* p.z/ 4)
   );
   return q;
}

function proiectie_cabinet(p) { return d3d2g(p, deg2rad(0), deg2rad(90), deg2rad(45));}
function proiectie_supraf(p) {return d3d2g(p, deg2rad(165), deg2rad(- 135), deg2rad(135));}

function setBigPixels(bBigPixels) {
  var bBigPixelsOld= window._bBigPixels;
  window._bBigPixels= bBigPixels;
  return bBigPixelsOld;
}
function putpixel(x, y, c, alpha) {//TODO:use getViewport()
  var pixels= window._PIXELS;
  x+= pixels.viewport.left;
  y+= pixels.viewport.top;
  if(!pixels.viewport.inside(x, y)) return null;//getViewport(), setViewport()
  function _new_pixel() {
    var px= document.createElement('DIV');
    var p= px.style;
    p.display= 'none';
    p.position= 'absolute';
    p.zIndex= window._PIXELS.length;
    p.width= '1px';
    p.height= '1px';
    p.fontSize= '1px';
    p.overflow= 'hidden';
    window.document.body.appendChild(px);
    return px;
  }
  function _pixel(x, y, c, alpha) {
    var px;
    var pool= window._PIXEL_POOL;
    if(pool.length) {
      px= pool.pop();
      var p= px.style;
      p.width= '1px';
      p.height= '1px';
    } else px= _new_pixel();
    window._PIXELS.push(px);
    var p= px.style;
    p.left= x+ 'px';
    p.top= y+ 'px';
    p.background= c;
    p.display=  'block';
    if(!isNaN(alpha)) {
      if(typeof(px.filters)== 'object') {//[IE6]
        p.filter= 'alpha';
        px.filters.alpha.opacity= ((alpha/ 255)* 100);
      }else {//[FF3]
        p.opacity= (alpha/ 255);
      }
    }
    return px;
  }
  if(window._bBigPixels) {//"setBigPixels(true)"
    var px= _pixel(x, y, c, parseInt(alpha));
    var p= px.style;
    p.left= (x- 1)+ 'px';
    p.top= (y- 1)+ 'px';
    p.width= '3px';
    p.height= '3px';
    return px;
  }else return _pixel(x, y, c, parseInt(alpha));
}//~putpixel()

/*//clip by viewport (test case)
setViewport([100, 130, 100+ 50, 130+ 50]);
bar(0, 0, 200, 200, 'yellow');//TODO:clip by viewport (NOTE: The yellow area should be 50x50(the size of the viewport).)
line(0, 0, 100, 100, 'red'); //clip by putpixel
rect(0, 0, 100, 100, 'blue');//TODO:sould clip (PENDING) (NOTE: Two artifacts are still here: one hline, and one vline.)
circle(50, 50, 30, 'red');   //clip by putpixel
hline(0, 0, 300, 'black');
*/

function hline(x, y, l, c) {//TODO:clip by viewport
   var viewport= getViewport();
   x+= viewport.left;
   y+= viewport.top;
   if(l> viewport.width) l-= l- viewport.width;
   //TODO:use a fast line clipper
   return CreateWindow(null, x, y, l, 1, c, null, null, true);
}
function vline(x, y, l, c) {//TODO:clip by viewport
   var vr= getViewport();
   x+= vr.left;
   y+= vr.top;
   if(l> vr.height) l-= l- vr.height;
   //TODO:use a fast line clipper
   return CreateWindow(null, x, y, 1, l, c, null, null, true);
}
function bar(x, y, w, h, c) {//TODO:clip by viewport
   var viewport= getViewport();
   x+= viewport.left;
   y+= viewport.top;
   //TODO:use a fast box clipper
   return CreateWindow(null, x, y, w, h, c, null, null, true);
}

function marker(x, y, c, bSnapToGrid) {
  if(bSnapToGrid) {
    x= floor(x)* 3+ 1;
    y= floor(y)* 3+ 1;
  }else {
    x-= 1;
    y-= 1;
  }
  bar(x, y, 3, 3, c);
}

function line (x0, y0, x1, y1, c) { // digital differential analyzer (DDA) algorithm
  var dx, dy, n, i;
  dx= x1- x0;
  dy= y1- y0;
  var xIncrement, yIncrement, x, y;
  x= x0;
  y= y0;
  if(abs(dx)> abs(dy)) {
    n= abs(dx);
  } else {
    n= abs(dy);
  }
  xIncrement= dx/ n;
  yIncrement= dy/ n;
  putpixel(x, y, c);
  for(i= 0; i< n; i++) {//BUG: a roundoff error can accumulate for long lines
    x+= xIncrement;
    y+= yIncrement;
    putpixel(x, y, c);
  }
}//~line()

//NOTE: line() clip by viewport would be faster?
function line(x1, y1, x2, y2, c) { // Draw a line (Bresenham method)
   var x, y, dx, dy, dx2, dy2, sx, sy, e, i;
   x= x1; y= y1;
   dx= abs(x2- x1); dy= abs(y2- y1);
   dx2= dx<< 1; dy2= dy<< 1;
   sx= sgn(x2- x1); sy= sgn(y2- y1);
   if(dx== dy) { // diagonal line
      if(sx== 1)
         if(sy== 1) for(i= 0; i<= dx; i++) putpixel(x++, y++, c);
         else for(i= 0; i<= dx; i++) putpixel(x++, y--, c);
      else
        if(sy== 1) for(i= 0; i<= dx; i++) putpixel(x--, y++, c);
        else for(i= 0; i<= dx; i++) putpixel(x--, y--, c);
   }else if(dy> dx) {
      if(dx== 0) { // vertical line
         (sy== 1)? vline(x1, y1, dy, c)
                 : vline(x2, y2, dy, c);
      }else { // oblique line
         e= dx2- dy;
         for(i= 0; i<= dy; i++) {
            putpixel(x, y, c);
            while(e>= 0) {
               x+= sx;
               e-= dy2;
            }
            y+= sy;
            e+= dx2;
         }
      }
   }else {
      if(dy== 0) { // horizontal line
         (sx== 1)? hline(x1, y1, dx, c)
                 : hline(x2, y2, dx, c);
      }else { // oblique line
         e= dy2- dx;
         for(i= 0; i<= dx; i++) {
            putpixel(x, y, c);
            while(e>= 0) {
               y+= sy;
               e-= dx2;
            }
            x+= sx;
            e+= dy2;
         }
      }
   }
}//~line()

function _curve(x0, y0, x1, y1, x2, y2, x3, y3, c) {//draw a Cubic Bezier Curve (DeCasteljau method)
  var threshold= 16; //0.25; //smaller -> smoother (16: lineto; 0.25: putpixel)
  var points= [];
  function dist(x0, y0, x1, y1) {// squared
    var dx, dy;
    dx= x0- x1;
    dy= y0- y1;
    return dx* dx+ dy* dy;
  }
  function _c(x0, y0, x1, y1, x2, y2, x3, y3) {
    var len, chord;
    len= dist(x0, y0, x1, y1)+ dist(x1, y1, x2, y2)+ dist(x2, y2, x3, y3);
    chord= dist(x0, y0, x3, y3);
    if(Math.abs(len- chord)< threshold) return;
    var p11_x, p11_y, tmp_x, tmp_y, p12_x, p12_y, p22_x, p22_y, p21_x, p21_y, p20_x, p20_y;
    p11_x= 0.5* (x0+ x1);// "(x0+ x1)>> 1" is faster but effective only in an AGG type rasterizer
    p11_y= 0.5* (y0+ y1);
    tmp_x= 0.5* (x1+ x2);
    tmp_y= 0.5* (y1+ y2);
    p12_x= 0.5* (p11_x+ tmp_x);
    p12_y= 0.5* (p11_y+ tmp_y);
    p22_x= 0.5* (x2+ x3);
    p22_y= 0.5* (y2+ y3);
    p21_x= 0.5* (p22_x+ tmp_x);
    p21_y= 0.5* (p22_y+ tmp_y);
    p20_x= 0.5* (p12_x+ p21_x);
    p20_y= 0.5* (p12_y+ p21_y);
    _c(x0, y0, p11_x, p11_y, p12_x, p12_y, p20_x, p20_y);//recursive calls are costly...
    points.push(round(p20_x), round(p20_y));//putpixel(round(p20_x), round(p20_y), c);
    _c(p20_x, p20_y, p21_x, p21_y, p22_x, p22_y, x3, y3);//...try implementing a local stack
  }//~_curve._c()
    points.push(round(x0), round(y0));
  _c(x0, y0, x1, y1, x2, y2, x3, y3);
    points.push(round(x3), round(y3));//putpixel(round(x3), round(y3), c);

    var n= points.length>> 1;
    var x0, y0;
    y0= points.pop();
    x0= points.pop();
    for(var i= 1; i< n; i++) {
      var x1, y1;
      y1= points.pop();
      x1= points.pop();
      line(x0, y0, x1, y1, c);
      y0= y1;
      x0= x1;
    }
}//~_curve()

function polygon(v, c, bMarkers) {//draw a polygon "polygon([25,228,51,27,176,248], 'red', true);"
  var i, n;
  n= v.length>> 1;
  for(i= 0; i< n; i++) {
    if(bMarkers) marker(v[2* i], v[2* i+ 1], c);
    line(v[2* i], v[2* i+ 1], v[2* i+ 2], v[2* i+ 3], c);
  }
  i--;
  line(v[2* i], v[2* i+ 1], v[0], v[1], c);
}//~polygon()


function _ellipse(x, y, w, h, c, alpha) {//PostScript style ellipse
  var x0, y0, xc, yc;
  function _m(x, y){//moveto
    x0= x;
    y0= y;
  }
  function _c(x1, y1, x2, y2, x3, y3) {//curveto
    _curve(x0, y0, x1, y1, x2, y2, x3, y3, c);
    x0= x3;
    y0= y3;
  }
  //function _s() {}//stroke
  var f, dx, dy;

  f= 0.5522847498307934; //f= 4/ 3* (sqrt(2)- 1);// 4/ 3* (1- cos(deg2rad(45)))/ sin(deg2rad(45))
  dx= 0.5* w* (1- f);
  dy= 0.5* h* (1- f);
  if(arguments.length== 6) {//rotate the ellipse by an angle (alpha)
    xc= (x+ (x+ w))/ 2;//center of ellipse
    yc= (y+ (y+ h))/ 2;//ditto
    var v1, v2, v3, v4;
    v1= _rotplan(xc, yc, x, y+ 0.5* h, alpha);
    _m(v1[0], v1[1]);
    v1= _rotplan(xc, yc, x, y+ h- dy, alpha);
    v2= _rotplan(xc, yc, x+ dx, y+ h, alpha);
    v3= _rotplan(xc, yc, x+ 0.5* w, y+ h, alpha);
    _c(v1[0], v1[1], v2[0], v2[1], v3[0], v3[1]);
    v1= _rotplan(xc, yc, x+ w- dx, y+ h, alpha);
    v2= _rotplan(xc, yc, x+ w, y+ h- dy, alpha);
    v3= _rotplan(xc, yc, x+ w, y+ 0.5* h, alpha);
    _c(v1[0], v1[1], v2[0], v2[1], v3[0], v3[1]);
    v1= _rotplan(xc, yc, x+ w, y+ dy, alpha);
    v2= _rotplan(xc, yc, x+ w- dx, y, alpha);
    v3= _rotplan(xc, yc, x+ 0.5* w, y, alpha);
    _c(v1[0], v1[1], v2[0], v2[1], v3[0], v3[1]);
    v1= _rotplan(xc, yc, x+ dx, y, alpha);
    v2= _rotplan(xc, yc, x, y+ dy, alpha);
    v3= _rotplan(xc, yc, x, y+ 0.5* h, alpha);
    _c(v1[0], v1[1], v2[0], v2[1], v3[0], v3[1]);
  }else {
    _m(x, y+ 0.5* h);
    _c(x, y+ h- dy, x+ dx, y+ h, x+ 0.5* w, y+ h);
    _c(x+ w- dx, y+ h, x+ w, y+ h- dy, x+ w, y+ 0.5* h);
    _c(x+ w, y+ dy, x+ w- dx, y, x+ 0.5* w, y);
    _c(x+ dx, y, x, y+ dy, x, y+ 0.5* h);
  }
  //_s();
}//~_ellipse()

//rectangle(150, 150, 50, 50, 'red');
//ellipse(150, 150, 50, 50, 'blue');
//_ellipse(100, 100, 100, 100, 'green');//x, y, width, height

function draw_some_ellipses() {
  _ellipse(100, 100, 200, 300, 'brown');//x, y, width, height
  _ellipse(150, 150, 20, 30, 'brown');
  _ellipse(250, 250, 20, 30, 'brown');
}

function circle_v0001(cx, cy, r, c) { // [BUG: skip some, write some twice or more, extremely inefficient, ugly]
  var d, dd, x, y, px, py;
  d= 0.0;
  dd= (Math.PI/ 3.0)* (1/ r); // hmm..
  x= round(r* cos(d));
  y= round(r* sin(d));
  px= x;
  py= y;
var _skip= 0; //dbg
  do {
    if(!((px== x)&& (py== y))) {
      putpixel(cx + x, cy+ y, c);
      //echo((cx+ x)+ '\t'+ (cy+ y));
      px= x;
      py= y;
    }else _skip++; // dbg
    d+= dd;
    x= round(r* cos(d));
    y= round(r* sin(d));
  } while(d<= 6.4);
  return _skip; // dbg
} //~circle_v0001() SOMETHING! :)

function circle_v0002(cx, cy, r, c) {//concise
  var t, i, n, x, y, d;
  n= round(4.0* Math.SQRT2* r);
  d= 2.0* Math.PI/ n;
  for(t= 0, i= 0; i< n; i++, t+= d) {
    x= round(r* cos(t));
    y= round(r* sin(t));
    marker(cx+ x, cy+ y, c, true);
  }
}//circle_v0002()

//circle_v0002(200, 200, 104, 'red');

function circle_v0003(cx, cy, r, color, bFast) {//concise
  var t, i, n, x, y, s, c, d, bNoGaps;
  bNoGaps= !bFast;             //try Bresenham if you want to be fast and have no gaps at the same time
  n= round(4.0* Math.SQRT2* r);//in theory we don't need more pixels (see Bresenham)
  if(bNoGaps) n+= round(n/ 16);//good for floodfills
  d= 1/ n;
  for(t= 0, i= 0; i< n; i++, t+= d) {
    sc= sincosT(t);
    s= sc[0];//sine
    c= sc[1];//cosine
    x= round(r* c);
    y= round(r* s);
    putpixel(cx+ x, cy+ y, color);
  }
}//circle_v0003()

function circle_v0004(cx, cy, r, color, bFast) {//concise
  var t, i, n, x, y, s, c, d, bNoGaps;
  bNoGaps= !bFast;             //try Bresenham if you want to be fast and have no gaps at the same time
  n= round(4.0* Math.SQRT2* r);//in theory we don't need more pixels (see Bresenham)
  if(bNoGaps) n+= round(n/ 16);//good for floodfills
  d= 1/ n;
  for(t= 0, i= 0; i< n; i++, t+= d) {
    sc= sincosT(t);
    s= integer(sc[0]* 0x7FFF, 0xFFFF)/ 0x8000;//sine
    c= integer(sc[1]* 0x7FFF, 0xFFFF)/ 0x8000;//cosine
    x= integer(r* c, 0xFFFF);
    y= integer(r* s, 0xFFFF);
    putpixel(cx+ x, cy+ y, color);
  }
}//~circle_v0004()

//circle_v0004(400, 400, 203, 'green');

function circle(cx, cy, r, c) { // Bresenham circle
  function _plot8() {
    putpixel(cx+ x, cy+ y, c); // point in octant 1
    putpixel(cx+ y, cy+ x, c); // in octant 2
    putpixel(cx- y, cy+ x, c); // octant 3
    putpixel(cx- x, cy+ y, c); // 4
    putpixel(cx- x, cy- y, c); // 5
    putpixel(cx- y, cy- x, c); // 6
    putpixel(cx+ y, cy- x, c); // 7
    putpixel(cx+ x, cy- y, c); // 8
  }
  var x, y, dx, dy, dr;
  x= r;
  y= 0;
  dx= 1- shl(r, 1); //1- 2* r;
  dy= 1;
  dr= 0;
  while (x>= y) {
    _plot8();
    y++;
    dr+= dy;
    dy+= 2;
    if ((shl(dr, 1)+ dx)> 0) { //if ((2* dr+ dx)> 0) {
      x--;
      dr+= dx;
      dx+= 2;
    }
  } //circle(400, 400, 60, 'red');
} //~circle()

function ellipse(cx, cy, rx, ry, c) { // Bresenham ellipse
 function _plot4() {
   putpixel(cx+ x, cy+ y, c); // point in quadrant 1
   putpixel(cx- x, cy+ y, c); // in quadrant 2
   putpixel(cx- x, cy- y, c); // 3
   putpixel(cx+ x, cy- y, c); // 4
 }
  var x, y, dx, dy, e, ax2, by2, sx, sy;
  ax2= 2* rx* rx;
  by2= 2* ry* ry;
  x= rx;
  y= 0;
  dx= ry* ry* (1- 2* rx);
  dy= rx* rx;
  e= 0;
  sx= by2* rx;
  sy= 0;
  while (sx>= sy) { // 1st set of points, y' > -1
    _plot4();
    y++;
    sy+= ax2;
    e+= dy;
    dy+= ax2;
    if ((2* e+ dx)> 0) {
      x--;
      sx-= by2;
      e+= dx;
      dx+= by2;
    }
  }  //1st point set is done; start the 2nd set of points
  x= 0;
  y= ry;
  dx= ry* ry;
  dy= rx* rx* (1- 2* ry);
  e= 0;
  sx= 0;
  sy= ax2* ry;
  while (sx<= sy) { // 2nd set of points, y' < -1
    _plot4();
    x++;
    sx+= by2;
    e+= dx;
    dx+= by2;
    if ((2* e+ dy)> 0) {
      y--;
      sy-= ax2;
      e+= dy;
      dy+= ax2;
    }
  }
}//~ellipse()

function square(cx, cy, r, c) {
  cx= floor(cx); cy= floor(cy); r= floor(r);
  line(cx+ r, cy+ r, cx- r, cy+ r, c);
  line(cx- r, cy+ r, cx- r, cy- r, c);
  line(cx- r, cy- r, cx+ r, cy- r, c);
  line(cx+ r, cy- r, cx+ r, cy+ r+ 1, c);
}

function rhomb(cx, cy, dx, dy, c) {
  cx= floor(cx); cy= floor(cy);
  dx= floor(dx); dy= floor(dy);
  line(cx+ dx, cy    , cx    , cy+ dy, c); // right -> top
  line(cx    , cy+ dy, cx- dx, cy    , c);
  line(cx- dx, cy    , cx    , cy- dy, c); // left -> bottom
  line(cx    , cy- dy, cx+ dx, cy    , c);
}

function rectangle(cx, cy, dx, dy, c) { // draw a rectangle with (cx, cy) as its center
  cx= floor(cx); cy= floor(cy);
  dx= floor(dx); dy= floor(dy);
  //echof("rectangle: %0.4f %0.4f %0.4f %0.4f %s", cx, cy, dx, dy, c);//dbg
  line(cx+ dx, cy+ dy, cx- dx, cy+ dy, c);
  line(cx- dx, cy+ dy, cx- dx, cy- dy, c);
  line(cx- dx, cy- dy, cx+ dx, cy- dy, c);
  line(cx+ dx, cy- dy, cx+ dx, cy+ dy+ 1, c);
  //putpixel(cx+ dx, cy+ dy+ 1, 'green');//dbg
}//~rectangle()

function arrow(tx, ty, hx, hy, l, c) {
  var dx= tx- hx;
  var dy= ty- hy;
  var angle = Math.atan2(dy, dx);
  line(tx, ty, hx, hy, c);
  var t= angle- deg2rad(12);
  line(hx, hy, round(hx+ l* Math.cos(t)), round(hy+ l* Math.sin(t)), c);
  t= angle+ deg2rad(12);
  line(hx, hy, round(hx+ l* Math.cos(t)), round(hy+ l* Math.sin(t)), c);
}

function rect(x0, y0, x1, y1, c, bMarkers) {
  x0= floor(x0); y0= floor(y0);
  x1= floor(x1); y1= floor(y1);
  line(x0, y0, x1, y0, c);
  line(x1, y0, x1, y1+ 1, c);
  line(x1, y1, x0, y1, c);
  line(x0, y1, x0, y0, c);
  if(bMarkers) {
    marker(x0, y0, c)//, x1, y0, c);
    marker(x1, y0, c)//, x1, y1, c);
    marker(x1, y1, c)//, x1, y0, c);
    marker(x0, y1, c)//, x0, y0, c);
  }
}//~rect()

//arrow(100, 100, 50, 50, 10, 'red');

/*
circle(150, 150, round(0.5* 100), 'blue');
circle(150, 150, round(0.5* hypot(100, 100)), 'green')
line(100, 100, 200, 200, 'red')
//CloseAllWindows()
*/

/*
  ellipse(500, 500, 13, 13, 'red');
  ellipse(500, 500, 13, 33, 'green');
  ellipse(500, 500, 33, 13, 'green');
  ellipse(500, 500, 33, 33, 'blue');
  rhomb(500, 500, 50, 50, 'black');
  rectangle(500, 300, 10, 17, 'red')
  rectangle(500, 300, 10, 13, 'green')
*/

</SCRIPT>
<SCRIPT>
function VGA(width, height, bClear) {
  function putpixel(x, y, c) {
     this[x+ (y* this.width)]= c;
  }
  function getpixel(x, y) {
    return this[x+ (y* this.width)];
  }
  function clear(c) {
    for(var i= 0; i< width; i++)
      for(var j= 0; j< height; j++)
        this.putpixel(i, j, c);
  }
  function cls(c) {
    for(var i= 0; i< this.length; i++)
      this[i]= c;
  }
  function line(x1, y1, x2, y2, c) {
     function sgn(a){
       if(a> 0)  return +1;
       if(a< 0)  return -1;
       if(a= 0)  return 0;
     }
     var i, u, s, v, d1x, d1y, d2x, d2y, m, n;
     u= x2- x1;
     v= y2- y1;
     d1x= sgn(u);
     d1y= sgn(v);
     d2x= sgn(u);
     d2y= 0;
     m= abs(u);
     n= abs(v);
     if(!(m> n)) {
       d2x= 0;
       d2y= sgn(v);
       m= abs(v);
       n= abs(u);
     }
     s= shr(m, 1);
     for (i= 0; i< m; i++) {
       this.putpixel(x1, y1, c);
       s+= n;
       if(!(s< m)) {
         s-= m;
         x1+= d1x;
         y1+= d1y;
       }else {
         x1+= d2x;
         y1+= d2y;
       }
     }
  }//~line()
  function circle(cx, cy, r, c) { // [Bresenham method]
    var x, y, dx, dy, dr;
    x= r;
    y= 0;
    dx= 1- shl(r, 1); //1- 2* r;
    dy= 1;
    dr= 0;
    while (x>= y) {
      this.putpixel(cx+ x, cy+ y, c); // point in octant 1
      this.putpixel(cx+ y, cy+ x, c); // in octant 2
      this.putpixel(cx- y, cy+ x, c); // octant 3
      this.putpixel(cx- x, cy+ y, c); // 4
      this.putpixel(cx- x, cy- y, c); // 5
      this.putpixel(cx- y, cy- x, c); // 6
      this.putpixel(cx+ y, cy- x, c); // 7
      this.putpixel(cx+ x, cy- y, c); // 8
      y++;
      dr+= dy;
      dy+= 2;
      if ((shl(dr, 1)+ dx)> 0) { //if ((2* dr+ dx)> 0) {
        x--;
        dr+= dx;
        dx+= 2;
      }
    }
  } //~circle()
  function ellipse(cx, cy, rx, ry, c) { // Bresenham ellipse
    var x, y, dx, dy, e, ax2, by2, sx, sy;
    ax2= 2* rx* rx;
    by2= 2* ry* ry;
    x= rx;
    y= 0;
    dx= ry* ry* (1- 2* rx);
    dy= rx* rx;
    e= 0;
    sx= by2* rx;
    sy= 0;
    while (sx>= sy) { // 1st set of points, y' > -1
      this.putpixel(cx+ x, cy+ y, c); // point in quadrant 1
      this.putpixel(cx- x, cy+ y, c); // in quadrant 2
      this.putpixel(cx- x, cy- y, c); // 3
      this.putpixel(cx+ x, cy- y, c); // 4
      y++;
      sy+= ax2;
      e+= dy;
      dy+= ax2;
      if ((2* e+ dx)> 0) {
        x--;
        sx-= by2;
        e+= dx;
        dx+= by2;
      }
    }  //1st point set is done; start the 2nd set of points
    x= 0;
    y= ry;
    dx= ry* ry;
    dy= rx* rx* (1- 2* ry);
    e= 0;
    sx= 0;
    sy= ax2* ry;
    while (sx<= sy) { // 2nd set of points, y' < -1
      this.putpixel(cx+ x, cy+ y, c); // point in quadrant 1
      this.putpixel(cx- x, cy+ y, c); // in quadrant 2
      this.putpixel(cx- x, cy- y, c); // 3
      this.putpixel(cx+ x, cy- y, c); // 4
      x++;
      sx+= by2;
      e+= dx;
      dx+= by2;
      if ((2* e+ dy)> 0) {
        y--;
        sy-= ax2;
        e+= dy;
        dy+= ax2;
      }
    }
  }//~ellipse()
  function square(cx, cy, r, c) {
    cx= floor(cx); cy= floor(cy); r= floor(r);
    this.line(cx+ r, cy+ r, cx- r, cy+ r, c);
    this.line(cx- r, cy+ r, cx- r, cy- r, c);
    this.line(cx- r, cy- r, cx+ r, cy- r, c);
    this.line(cx+ r, cy- r, cx+ r, cy+ r+ 1, c);
  }
  function rhomb(cx, cy, dx, dy, c) {
    cx= floor(cx); cy= floor(cy);
    dx= floor(dx); dy= floor(dy);
    this.line(cx+ dx, cy    , cx    , cy+ dy, c); // right -> top
    this.line(cx    , cy+ dy, cx- dx, cy    , c);
    this.line(cx- dx, cy    , cx    , cy- dy, c); // left -> bottom
    this.line(cx    , cy- dy, cx+ dx, cy    , c);
  }
  function rectangle(cx, cy, dx, dy, c) { // draw a rectangle with (cx, cy) as its center
    cx= floor(cx); cy= floor(cy);
    dx= floor(dx); dy= floor(dy);
    this.line(cx+ dx, cy+ dy, cx- dx, cy+ dy, c);
    this.line(cx- dx, cy+ dy, cx- dx, cy- dy, c);
    this.line(cx- dx, cy- dy, cx+ dx, cy- dy, c);
    this.line(cx+ dx, cy- dy, cx+ dx, cy+ dy+ 1, c);
  }
  function rect(x0, y0, x1, y1, c, bMarkers) {
    x0= floor(x0); y0= floor(y0);
    x1= floor(x1); y1= floor(y1);
    this.line(x0, y0, x1, y0, c);
    this.line(x1, y0, x1, y1+ 1, c);
    this.line(x1, y1, x0, y1, c);
    this.line(x0, y1, x0, y0, c);
    if(bMarkers) {
      this.marker(x0, y0, c)//, x1, y0, c);
      this.marker(x1, y0, c)//, x1, y1, c);
      this.marker(x1, y1, c)//, x1, y0, c);
      this.marker(x0, y1, c)//, x0, y0, c);
    }
  }//~rect()
  function marker(x, y, c, bSnapToGrid) {
    if(bSnapToGrid) {
      x= floor(x)* 3+ 1;
      y= floor(y)* 3+ 1;
    }else {
      x-= 1;
      y-= 1;
    }
    this.bar(x, y, 3, 3, c);
  }
  function bar(x, y, w, h, c) {
     var i, j;
     for(i= 0; i< h; i++) {
       j= y+ i;
       this.line(x, j, x+ w, j, c);
     }
  }
  function get_all_palette() {
     return this.palette;
  }
  function set_all_palette(pal) {
     this.palette= pal;
  }
  function set_palette(c, r, g, b) {
     this.palette[c][0]= r;
     this.palette[c][1]= g;
     this.palette[c][2]= b;
  }
  function get_palette(c) {
    var r, g, b;
    r= this.palette[c][0];
    g= this.palette[c][1];
    b= this.palette[c][2];
    return [r, g, b];
  }

  if(!+width) width= 640;
  if(!+height) height= 480;
  width= floor(width);
  height= floor(height);
  var dc= new Array(width* height);
  dc.width= width;
  dc.height= height;
  dc.palette= new Matrix(256, 3);
  dc.putpixel= putpixel;
  dc.getpixel= getpixel;
  dc.clear= clear;
  dc.cls= cls;
  dc.line= line;
  dc.circle= circle;
  dc.ellipse= ellipse;
  dc.square= square;
  dc.rhomb= rhomb;
  dc.rectangle= rectangle;
  dc.rect= rect;
  dc.marker= marker;
  dc.bar= bar;
  dc.get_all_palette= get_all_palette;
  dc.set_all_palette= set_all_palette;
  dc.set_palette= set_palette;
  dc.get_palette= get_palette;
  if(bClear) dc.clear(0);
  return dc;
}//~VGA()

window.VGA= VGA;
/*
vga= new VGA(20, 40, true);
vga.set_palette(13, 123, 13, 32);
echo(vga.get_palette(13));
//vga.set_all_palette([1, 2, 3]);
echo(vga.get_all_palette());
vga.putpixel(100, 100, 13);
echo(vga.getpixel(100, 100));
echo(vga.getpixel(100, 101));
vga.cls(0);
echo(vga.getpixel(13, 13));
vga.circle(10, 10, 5, 255);
vga.circle(0, 0, 10, 255);

vga.line(0, 0, 19, 39, 111);
echo(vga);
*/
</SCRIPT>
<SCRIPT>
function point_in_circle(x, y, cx, cy, r) {//point in disk: Test if the disk with center C(cx, cy) and radius r contains the point P(x, y).
  var d1, d2;
  d2= r* r;
  d1= (cx- x)* (cx- x)+ (cy- y)* (cy- y);
  if(d1<= d2) {
    return true;
  }else {
    return false;
  }
}//~point_in_circle()

function point_in_bcircle(x, y, vBcircle) {
  var cx, cy, r;
  cx= vBcircle[0];
  cy= vBcircle[1];
  r=  vBcircle[2];
  return point_in_circle(x, y, cx, cy, r);
}//~point_in_bcircle()

function triangle_get_bcircle(x1, y1, x2, y2, x3, y3) {// triangle get bounding circle
  var cx, cy, r, vBcircle;
  cx= (x1+ x2+ x3)/ 3;
  cy= (y1+ y2+ y3)/ 3;
  r= max(
    line_length(x1, y1, cx, cy),
    line_length(x2, y2, cx, cy),
    line_length(x3, y3, cx, cy)
  );
  vBcircle= [cx, cy, r];
  return vBcircle;
}//~triangle_get_bcircle()

function triangle_get_bcircle(x1, y1, x2, y2, x3, y3) {//triangle get bounding circle (optimized: only one square root)
  var cx, cy, r, min_x, min_y, max_x, max_y, vBbox2D, vBcircle;
  vBbox2D= triangle_get_bbox2D(x1, y1, x2, y2, x3, y3);
  min_x= vBbox2D[0];
  min_y= vBbox2D[1];
  max_x= vBbox2D[2];
  max_y= vBbox2D[3];
  //rect(min_x, min_y, max_x, max_y, 'cyan');//dbg
  cx= (min_x+ max_x)/ 2;
  cy= (min_y+ max_y)/ 2;
  r= line_length(min_x, min_y, cx, cy);
  vBcircle= [cx, cy, r];
  return vBcircle;
}//~triangle_get_bcircle()

function point_in_bbox2D(x, y, vBbox2D) {// Test if the bounding rectangle vBbox2D contains the point P(x, y).
  var min_x, min_y, max_x, max_y;
  min_x= vBbox2D[0];
  min_y= vBbox2D[1];
  max_x= vBbox2D[2];
  max_y= vBbox2D[3];
  if((min_x<= x) && (x<= max_x) && (min_y<= y) && (y<= max_y) ) return true;
  return false;
}//~point_in_bbox2D()

function triangle_get_bbox2D(x1, y1, x2, y2, x3, y3) {// Get the bounding rectangle that contains the triangle vertices.
  var min_x, min_y, max_x, max_y, vBbox2D;
  min_x= min(x1, x2, x3);
  min_y= min(y1, y2, y3);
  max_x= max(x1, x2, x3);
  max_y= max(y1, y2, y3);
  vBbox2D= [min_x, min_y, max_x, max_y];
  return vBbox2D;
}//~triangle_get_bbox2D()

function line_length_squared(x0, y0, x1, y1) {
  return (sqr(x1- x0)+ sqr(y1- y0));
}//~line_length_squared()
function line_length_squared3D(x0, y0, z0, x1, y1, z1) {
  return (sqr(x1- x0)+ sqr(y1- y0)+ sqr(z1- z0));
}//~line_length_squared3D()

function line_length(x0, y0, x1, y1) {
  //return hypot(x0- x1, y0- y1);
  return sqrt(line_length_squared(x0, y0, x1, y1));
}//~line_length()

function line_length3D(x0, y0, z0, x1, y1, z1) {
  return sqrt(line_length_squared3D(x0, y0, z0, x1, y1, z1));
}//~line_length3D()

function triangle_area(x1, y1, x2, y2, x3, y3) {//Given three vertices, find the area enclosed by the triangle that they define.
  return fabs(0.5* ((x1- x2)* (y1- y3)- (y1- y2)* (x1- x3))); //this is the fastest: only 3 (three) multiplications (and no square roots)
  //return fabs(0.5* (x1* (y2- y3)+ x2* (y3- y1)+ x3* (y1- y2)));//slower: 4 (four) multiplications (square roots free)
  //"What follows is heavily unoptimized, but valid also.Not used anymore. For Your Consideration"
  var a, b, c, p, _p, S;
  a= line_length(x1, y1, x2, y2);
  b= line_length(x2, y2, x3, y3);
  c= line_length(x3, y3, x1, y1);
  p= 0.5* (a+ b+ c);
  _p= p* (p- a)* (p- b)* (p- c);
  if((_p< 0.0)|| (fabs(_p)<= Math.DELTA)) {// triunghi degenerat (linie sau punct)
    S= 0.0;
  }else {
    S= sqrt(_p); // aria
  }
  return S;
}//~triangle_area()

function triangle_area3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {//TODO: Find a faster algorithm (and square-root-free). (URGENCY: TOP PRIORITY)
  var A, A1, A2, A3;

  {//performance: 10 (ten) multiplications, plus 1 (one) square root evaluation
    A1= ((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3)); // is proportional to the area of the projection on the XY plane
    A2= ((y1-y2)*(z1-z3)-(z1-z2)*(y1-y3)); // on the YZ plane
    A3= ((z1-z2)*(x1-x3)-(x1-x2)*(z1-z3)); // ZX plane.
    A= 0.5* sqrt(sqr(A1)+ sqr(A2)+ sqr(A3));//TODO: Get rid of the square root.
    return A;
  }

  //NOTE: Aria este de fapt o integrală. Şi se pare că proiecţiile 2D (cele trei proiecţii) ale suprafeţei 3D sunt un fel de derivate...
  //NOTE: Astfel, practic, calculăm aria folosind algoritmii pentru calculul lungimii unui segment de dreaptă 3D.
  //NOTE: Am găsit algoritmul destul de intuitiv. Dar mă interesează de fapt unul fără radicali. Iar dacă nu se poate fără radicali vreau să aflu de ce nu, şi teoria din spatele problemei.
  //NOTE: Triunghiul în planul 3D este de fapt o figură 2D, dar rotită în mod arbitrar funcţie de trei unghiuri alfa, beta şi gama în jurul celor trei axe OX, OY şi OZ. Şi mai este şi translatată pe undeva în spaţiu.
  //NOTE: Şi dacă aş putea găsi o metodă simplă (adică fără funcţii transcedentale gen sinus, tangentă, radical, etc.) să rotesc triunghiul în aşa fel încât să fie paralel cu una din cele trei plane (XY, XZ, YZ) aş folosi funcţia fără radicali ce calculează ultrarapid aria pentru planul XY.
  //NOTE: Mă întreb dacă nu cumva pot scăpa de radical. Pentru că în cazul ariei 2D nu am radicali şi e super rapid, şi super fain.
  //{//Algoritm: Aria triunghiului 3D este calculată ca un fel de distanţă 3D funcţie de cele trei arii ale proiecţiilor suprafeţei pe cele trei plane principale (XY, XZ, YZ).
  //  A1= fabs(0.5* ((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3))); // is proportional to the area of the projection on the XY plane
  //  A2= fabs(0.5* ((y1-y2)*(z1-z3)-(z1-z2)*(y1-y3))); // on the YZ plane
  //  A3= fabs(0.5* ((z1-z2)*(x1-x3)-(x1-x2)*(z1-z3))); // ZX plane.
  //  A= sqrt(sqr(A1)+ sqr(A2)+ sqr(A3));//TODO: Get rid of the square root.
  //  return A;
  //}

  //"unoptimized: Proof Of Concept"
  //NOTE: Algoritm foarte vechi, antic, grecesc (parcă Heron AKA "Mechanikos" l-a inventat). Algorimul a fost testat şi demonstrat cândva de inventator.
  //Algoritm: Aria este calculată funcţie de perimetrul triunghiului, de lungimea celor trei laturi. Şi foloseşte din plin radicali.
  var a, b, c, p, _p, S;
  a= line_length3D(x1, y1, z1, x2, y2, z2);
  b= line_length3D(x2, y2, z2, x3, y3, z3);
  c= line_length3D(x3, y3, z3, x1, y1, z1);
  p= 0.5* (a+ b+ c);
  _p= p* (p- a)* (p- b)* (p- c);
  if((_p< 0.0)|| (fabs(_p)<= Math.DELTA)) {// triunghi degenerat (linie sau punct)
    S= 0.0;
  }else {
    S= sqrt(_p); // aria
  }
  return S;
}//~triangle_area3D()

function point_in_triangle(x, y, x1, y1, x2, y2, x3, y3) {//TODO: Find a faster algorithm.
  var A1, A2, A3, A4, delta, tolerance;
  if(!point_in_bbox2D(x, y, triangle_get_bbox2D(x1, y1, x2, y2, x3, y3))) return false;//Easy test: Try to rapidly discard points that we know for sure are not inside the triangle.

  //TODO: optimize more; or find a better algorithm

  {//optimized: 8 multiplications
    A1= fabs((x1- x2)* (y1- y3)- (y1- y2)* (x1- x3));// The true area must be scaled by .5 (yet, here we don't care).
    A2= fabs((x1- x2)* (y1-  y)- (y1- y2)* (x1-  x));// ditto
    A3= fabs(( x- x2)* ( y- y3)- ( y- y2)* ( x- x3));// ...
    A4= fabs((x1-  x)* (y1- y3)- (y1-  y)* (x1- x3));//
    delta= fabs((A1- A2)- (A3+ A4));//In theory it should be zero for a point inside the triangle and nonzero otherwise.
  }

  //{//unoptimized:  12 multiplications
  //A1= triangle_area(x1, y1, x2, y2, x3, y3);
  //A2= triangle_area(x1, y1, x2, y2, x, y);
  //A3= triangle_area(x2, y2, x3, y3, x, y);
  //A4= triangle_area(x3, y3, x1, y1, x, y);
  //delta= fabs(A1- (A2+ A3+ A4));//In theory it should be zero for a point inside the triangle and nonzero otherwise.
  //}

  tolerance= 0.0000001; //Guard against numerical errors.
  if(delta<= tolerance) {
    return true;
  }else {
    return false;
  }
}//~point_in_triangle()


function point_in_triangle3D(x, y, z, x1, y1, z1, x2, y2, z2, x3, y3, z3) {//TODO: Find a faster algorithm.
  var A1, A2, A3, A4, delta, tolerance;
  A1= triangle_area3D(x1, y1, z1, x2, y2, z2, x3, y3, z3);
  A2= triangle_area3D(x1, y1, z1, x2, y2, z2, x, y, z);
  A3= triangle_area3D(x2, y2, z2, x3, y3, z3, x, y, z);
  A4= triangle_area3D(x3, y3, z3, x1, y1, z1, x, y, z);
  delta= fabs(A1- (A2+ A3+ A4));//In theory it should be zero for a point inside the triangle and nonzero otherwise.
  tolerance= 0.0000001; //Guard against numerical errors.
  if(delta<= tolerance) {
    return true;
  }else {
    return false;
  }
}//~point_in_triangle3D()


function plane3D_from_triangle3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
  //echof("triangle2plane3D: [(%s, %s, %s), (%s, %s, %s), (%s, %s, %s)]", x1, y1, z1, x2, y2, z2, x3, y3, z3);//dbg
  var a, b, c, d, q; //found using the Maxima symbolic mathematics package
  q= 1.0/ (x1* (y3* z2- y2* z3)+ y1* (x2* z3- x3* z2)+ z1* (x3* y2- x2* y3));
  //echof("triangle2plane3D: q: %s", q);//dbg
  //echof("triangle2plane3D: %s %s %s", (x1* (y3* z2- y2* z3)), (y1* (x2* z3- x3* z2)), ((x3* y2- x2* y3)* z1));//dbg
  a= +q* (y1* (z3- z2)- y2* z3+ y3* z2+ (y2- y3)* z1);
  b= -q* (x1* (z3- z2)- x2* z3+ x3* z2+ (x2- x3)* z1);
  c= +q* (x1* (y3- y2)- x2* y3+ x3* y2+ (x2- x3)* y1);
  d= -1.0;
  return [a, b, c, d];//3D plane equation: a* x+ b* y+ c* z- 1.0= 0.0;
}//~plane3D_from_triangle3D()


function plane3D_get_x(vpc, y, z) {// Solve the 3D plane equation for x.
  var x;
  x= -(vpc[1]*y+ vpc[2]* z+ vpc[3])/ vpc[0];//compute x as to be on the 3D plane
  return x;
}//~plane3D_get_x()

function plane3D_get_y(vpc, x, z) {// Solve the 3D plane equation for y.
  var y;
  y= -(vpc[0]*x+ vpc[2]* z+ vpc[3])/ vpc[1];//compute y as to be on the 3D plane
  return y;
}//~plane3D_get_y()

function plane3D_get_z(vpc, x, y) {// Solve the 3D plane equation for z.
  var z;
  z= -(vpc[0]*x+ vpc[1]* y+ vpc[3])/ vpc[2];//compute z as to be on the 3D plane
  return z;
}//~plane3D_get_z()


function triangle_solve(x1, y1, x2, y2, x3, y3) { // "var ts= triangle_solve(100, 100, 50, 150, 150, 150);"
 function _angle(t1, t2, t3) {
   var t= t2+ t3;
   if((t1)== t) return (0.5* PI);
   else t= atan(4.0* S/ (t- t1));
   if(t< 0.0) return (t+ PI);
   return t;
 }
  var a, b, c, p, S, A, B, C;
  a= line_length(x1, y1, x2, y2);
  b= line_length(x2, y2, x3, y3);
  c= line_length(x3, y3, x1, y1);

//line(x1, y1, x2, y2, 'red'); // dbg
//line(x2, y2, x3, y3, 'green'); // dbg
//line(x3, y3, x1, y1, 'blue'); // dbg

  var a2, b2, c2;
  var ha, ma, ba;
  var hb, mb, bb;
  var hc, mc, bc;
  var _p;

  p= 0.5* (a+ b+ c);
  _p= p* (p- a)* (p- b)* (p- c);
  if((_p< 0.0)|| (fabs(_p)<= Math.DELTA)) {// triunghi degenerat (linie sau punct)
    S= 0.0;
    A= 0.0; B= 0.0; C= 0.0;
    ha= 0.0; hb= 0.0; hc= 0.0;
    ma= 0.0; mb= 0.0; mc= 0.0;
    ba= 0.0; bb= 0.0; bc= 0.0;
    p= max(max(a, b), c);
  }else {
    S= sqrt(_p); // aria
    a2= a* a;
    b2= b* b;
    c2= c* c;

    A= _angle(a2, b2, c2); // unghiul A
    B= _angle(b2, c2, a2);
    C= _angle(c2, a2, b2);

    A= rad2deg(A);
    B= rad2deg(B);
    C= rad2deg(C);

    ha= 2.0* S/ a; // inaltimea (length)
    ma= 0.5* sqrt(2.0* (b2+ c2)- a2); // mediana
    ba= 2.0* sqrt(p* b* c* (p- a))/ (b+ c); // bisectoarea

    hb= 2.0* S/ b;
    mb= 0.5* sqrt(2.0* (c2+ a2)- b2);
    bb= 2.0* sqrt(p* c* a* (p- b))/ (c+ a);

    hc= 2.0* S/ c;
    mc= 0.5* sqrt(2.0* (a2+ b2)- c2);
    bc= 2.0* sqrt(p* a* b* (p- c))/ (a+ b);

    p= a+ b+ c; // perimetrul
  }
//  return [S, p, a, b, c, A, B, C, ha, ma, ba, hb, mb, bb, hc, mc, bc];
  return [S, p, a, b, c, A, B, C, ha, hb, hc, ma, mb, mc, ba, bb, bc];
}//~triangle_solve()

function triangle_info(x1, y1, x2, y2, x3, y3) {
  var ts= triangle_solve(x1, y1, x2, y2, x3, y3);
  var info;
  info = '\nTriangle:';
  info+= '\nVertex (Axy, Bxy, Cxy):';
  info+= '\n\t('+ x1+ ', '+ y1+ ')'+ '\n\t('+ x2+ ', '+ y2+ ')'+'\n\t('+ x3+ ', '+ y3+ ')';
  info+= ('\nArea: \n\t'+ ts[0]);
  info+= ('\nPerimeter: \n\t'+ ts[1]);
  info+= ('\nSides (a, b, c): [length]\n\t'+ ts[2]+ '\n\t'+ ts[3]+ '\n\t'+ ts[4]);
  info+= ('\nAngles (A, B, C): [angle]\n\t'+ ts[5]+ '\n\t'+ ts[6]+ '\n\t'+ ts[7]);
  info+= ('\nInaltimea din (A, B, C) [length] \n\t'+ ts[8]+ '\n\t'+ ts[9]+ '\n\t'+ ts[10]);
  info+= ('\nMediana din (A, B, C) [length] \n\t'+ ts[11]+ '\n\t'+ ts[12]+ '\n\t'+ ts[13]);
  info+= ('\nBisectoarea din (A, B, C) [length] \n\t'+ ts[14]+ '\n\t'+ ts[15]+ '\n\t'+ ts[16]);
  return info;
}

function debug_triangle_solver() {
 function _rand(_rmax) {
   return mod((syscall('random')* _rmax+ 1), _rmax);
 }
  var x1, y1, x2, y2, x3, y3;
  x1= _rand(400);
  y1= _rand(400);
  x2= _rand(400);
  y2= _rand(400);
  x3= _rand(400);
  y3= _rand(400);
  echo(triangle_info(x1, y1, x2, y2, x3, y3));
}
</SCRIPT>
<SCRIPT>
function Spline2Bezier_Cubic2D(CtrlPts, SpType) {
  var x, y, i, j, cp;
  var M= [
    //Bezier
     [ // the Identity Matrix, "cp1 cp2 cp3 cp4"
       [1.0, 0.0, 0.0, 0.0],
       [0.0, 1.0, 0.0, 0.0],
       [0.0, 0.0, 1.0, 0.0],
       [0.0, 0.0, 0.0, 1.0]
     ],
    //Cardinal
     [
       [      0.0,      1.0,      0.0,       0.0],
       [-1.0/ 6.0,      1.0, 1.0/ 6.0,       0.0],
       [      0.0, 1.0/ 6.0,      1.0, -1.0/ 6.0],
       [      0.0,      0.0,      1.0,       0.0]
     ],
    //CubicBSpline
     [
       [1.0/ 6.0, 2.0/ 3.0, 1.0/ 6.0,      0.0],
       [     0.0, 2.0/ 3.0, 1.0/ 3.0,      0.0],
       [     0.0, 1.0/ 3.0, 2.0/ 3.0,      0.0],
       [     0.0, 1.0/ 6.0, 2.0/ 3.0, 1.0/ 6.0]
     ],
    //Hermite
     [ // "cp1, cp2, gv1, gv2"
       [1.0, 0.0,      0.0,       0.0],
       [1.0, 0.0, 1.0/ 3.0,       0.0],
       [0.0, 1.0,      0.0, -1.0/ 3.0],
       [0.0, 1.0,      0.0,       0.0]
     ]
  ];
  //echo(M); // dbg
  cp= new Array(4);
  for(i= 0; i< 4; i++) { // for each control point
    x= 0.0;
    y= 0.0;
    for(j= 0; j< 4; j++) { // do the conversion
      x+= M[SpType][i][j]* CtrlPts[j].x;
      y+= M[SpType][i][j]* CtrlPts[j].y;
    }
    cp[i]= new Point2D(x, y);
  }
  return cp;
}//~Spline2Bezier_Cubic2D

function Bezier2Hermite2D(BezCp) {
  var x, y, i, HSpCp;
  HSpCp= new Array(4);
  for(i= 0; i< 4; i++) HSpCp[i]= new Point2D(0, 0);
  HSpCp[0].copy(BezCp[0]); // control point 1
  HSpCp[1].copy(BezCp[4]); // control point 2
  HSpCp[2].x= 3.0* (BezCp[1].x- BezCp[0].x); // gradient 1
  HSpCp[2].y= 3.0* (BezCp[1].y- BezCp[0].y);
  HSpCp[3].x= 3.0* (BezCp[3].x- BezCp[2].x); // gradient 2
  HSpCp[3].y= 3.0* (BezCp[3].y- BezCp[2].y);
  return HSpCp;
}//~Bezier2Hermite2D

function Hermite2Bezier2D(HSpCp) {
  return Spline2Bezier_Cubic2D(HSpCp, SplineType.Hermite);
}

</SCRIPT>
<SCRIPT>
function curve(x0, y0, x1, y1, x2, y2, x3, y3, c, bMarker) {//draw a cubic bezier curve
  if(bMarker) {
    marker(x0, y0, c); marker(x1, y1, c);
    marker(x2, y2, c); marker(x3, y3, c);
  }
  function _curve(t, P) {
    var b0, b1, b2, b3;// basis functions "(t+ (1- t))^ 3"
    b0= (1- t)* (1- t)* (1- t);
    //b1= 3* (1- t)* (1- t)* t;
    b2= 3* (1- t)* t* t;
    b3= t* t* t;
    //P.x= b0* x0+ b1* x1+ b2* x2+ b3* x3;
    //P.y= b0* y0+ b1* y1+ b2* y2+ b3* y3;
    P.x= b0* (x0- x1)+ x1+ b2* (x2- x1)+ b3* (x3- x1);
    P.y= b0* (y0- y1)+ y1+ b2* (y2- y1)+ b3* (y3- y1);
  }
  var t, step, steps;
  var x, y, i, P0, P1;
  P0= new Point();
  P1= new Point();
  _curve(0, P0);
  steps= 200; // arbitrary (increase for higher resolutions)
  step= 1/ steps;
  for(t= 0, i= 0; i< steps; i++, t+= step) {
    _curve(t, P1);
    line(P0.x, P0.y, P1.x, P1.y, c);
    P0.copy(P1);
  } //"curveT3(0, 0, 100, 100, 200, 0, 300, 300, 'green');"
  P0.copy(P1);
  _curve(1, P1);
  line(P0.x, P0.y, P1.x, P1.y, c);
}//~curve()

window.curveT3= curve;

//var v=[842, 423, 1018, 224, 732, 213, 1067, 419];
//curveT3(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], 'green', true);
//curveT3(0, 0, 100, 100, 200, 0, 300, 300, 'red', true);

function curveT2(x0, y0, x1, y1, x2, y2, c, bMarkers, bSpline) {//quadratic bezier curve
  var DEFAULT_STEPS= 100; // arbitrary (increase for higher resolutions)
  if(bMarkers) {
    if(bSpline) {//BEWARE: those are the true coordinates for bsplines (so scale down the original coordinates by .5; like in bspline function)
      marker(2* x0, 2* y0, c);
      marker(2* x1, 2* y1, c);
      marker(2* x2, 2* y2, c);
    }else {
      marker(x0, y0, c);
      marker(x1, y1, c);
      marker(x2, y2, c);
    }
  }
  function _curve_bspline(t, P) {
    var b0, b1, b2;//basis functions (quadratic bspline)
    b0= (1- t)* (1- t);
    b1= 1+ 2* t* (1- t);
    b2= t* t;
    P.x= b0* x0+ b1* x1+ b2* x2;
    P.y= b0* y0+ b1* y1+ b2* y2;
    //P.x= round(0.5* P.x);// bspline
    //P.y= round(0.5* P.y);
  }
  function _curve_quadratic(t, P) {
    var b0, b1, b2;//basis functions "(t+ (1-t))^2" (quadratic bezier)
    b0= (1- t)* (1- t);
    //b1= 2* t* (1- t);//see also: the DeCasteljau algorithm
    b2= t* t;
    //the same... (because "b0+ b1+ b2== 1.0")
    P.x= b0* (x0- x1)+ x1+ b2* (x2- x1);
    P.y= b0* (y0- y1)+ y1+ b2* (y2- y1);
    //...but faster than:
    //P.x= b0* x0+ b1* x1+ b2* x2;
    //P.y= b0* y0+ b1* y1+ b2* y2;
  }
  //TODO:
  //use the conversion from "Graph space" to "Equation space" and viceversa
  //to show that the bspline and the quadratic are somehow interchangeable
  //and use the DeCasteljau method for both
  var t, step, steps, _curve;
  var x, y, i, P0, P1;
  if(bSpline) {
    //x0*= 0.5; y0*= 0.5;
    //x1*= 0.5; y1*= 0.5;
    //x2*= 0.5; y2*= 0.5;
    _curve= _curve_bspline;
  }else _curve= _curve_quadratic;
  P0= new Point();
  P1= new Point();
  _curve(0, P0);
  steps= DEFAULT_STEPS; // arbitrary
  step= 1/ steps;
  for(t= 0, i= 0; i< steps; i++, t+= step) {
    _curve(t, P1);
    line(P0.x, P0.y, P1.x, P1.y, c);
    P0.copy(P1);
  }
  P0.copy(P1);
  _curve(1, P1);
  line(P0.x, P0.y, P1.x, P1.y, c); //"curveT2(0, 0, 100, 100, 200, 0, 'red');"
  //example:
  //curveT2(291.5,248,356.5,169.5,445,232.5, 'blue', true, false);
  //curveT2(291.5,248,356.5,169.5,445,232.5, 'red', true, true);
  //curveT2(583,496,713,339,890,465, 'green', true);
}//~curveT2()

function bspline(v, c, bMarkers, mkr_clr) {
  if(bMarkers) {
    for(var i= 0; i< (v.length>> 1); i++) {
      marker(v[i* 2], v[i* 2+ 1], mkr_clr);
    }
  }
  if(v.length< 2) return;
  if((v.length== 2)|| (v.length== 3)) {
    putpixel(v[0], v[1], c);
  }else {
    if((v.length== 4)|| (v.length== 5)) {
      line(v[0], v[1], v[2], v[3], c);
    }else {
      var x0, y0, x1, y1, x2, y2, n, i;
      vector_scale(v, 0.5);
      x0= v[0]; y0= v[1];
      x1= v[2]; y1= v[3];
      x2= v[4]; y2= v[5];
      curveT2(x0, y0, x1, y1, x2, y2, c, false, true);
      n= (v.length- 6)>> 1;
      for(i= 0; i< n; i++) {
        x0= x1; y0= y1;
        x1= x2; y1= y2;
        x2= v[i* 2+ 6]; y2= v[i* 2+ 7];
        curveT2(x0, y0, x1, y1, x2, y2, c, false, true);
      }
    }
  }//"bspline([114.5,87.25,146.25,71.5,214,103.25,191,157,116.75,162,145.25,123.5,94.25,110,132,98.75,114.5,87.25,146.25,71.5], 'green', true, 'red')"
}//~bspline()

function draw_a_spline(bRandomColors, bUseSplineBasis) {
  if(bRandomColors) {
    var x0, y0, x1, y1, x2, y2;
    x0= mt_rand(255); y0= mt_rand(255);
    x1= mt_rand(255); y1= mt_rand(255);
    x2= mt_rand(255); y2= mt_rand(255);
    if(bUseSplineBasis) curveT2(0.5* x0, 0.5* y0, 0.5* x1, 0.5* y1, 0.5* x2, 0.5* y2, random_color(), false, true);//equivalent but slower;
    else curveT2(0.5* (x0+ x1), 0.5* (y0+ y1), x1, y1, 0.5* (x2+ x1), 0.5* (y2+ y1), random_color(), false, false);//fast
    var i;
    for(i= 0; i< 5; i++) {
      x0= x1; y0= y1;
      x1= x2; y1= y2;
      x2= mt_rand(255); y2= mt_rand(255);
      if(bUseSplineBasis) curveT2(0.5* x0, 0.5* y0, 0.5* x1, 0.5* y1, 0.5* x2, 0.5* y2, random_color(), false, true);
      else curveT2(0.5* (x0+ x1), 0.5* (y0+ y1), x1, y1, 0.5* (x2+ x1), 0.5* (y2+ y1), random_color(), false, false);//fast
    }
  }else {
    var v= [];
    for(var i= 0; i< 6; i++) v.push(mt_rand(255));//add 3 control points
    for(var i= 0; i< 7; i++) {//add 7 control points
      v.push(mt_rand(255));// x
      v.push(mt_rand(255));// y
    }
    window.user._a_spline= vector_copy(v);
    var bBigPixelsOld= setBigPixels(true);

    bspline(v, random_color());

    setBigPixels(bBigPixelsOld);
    return window.user._a_spline;
  }//"draw_a_spline(true)"
}//~draw_a_spline()

</SCRIPT>
<SCRIPT>
function splotch(bMarkers, bRandom, bVerbose) {//draw a blot using bsplines
  if(!arguments.length) bRandom= true;
  function markers(v) {
    for(var i= 0; i< (v.length>> 1); i++) {
      marker(v[i* 2], v[i* 2+ 1], c);//control points
    }
    var x0, y0, x1, y1, x2, y2;
    x0= v[0]; y0= v[1];
    x1= v[2]; y1= v[3];
    x2= v[4]; y2= v[5];
    var x, y;
    x= 1/ 3* (x0+ x1+ x2);
    y= 1/ 3* (y0+ y1+ y2);
    marker(x, y, 'yellow');//center of mass

    // CP (control point) on curve
    x= 0.5*(x0+ x2); y= 0.5* (y0+ y2);
    marker(x, y, 'blue');
    x= 0.5*(x0+ x1); y= 0.5* (y0+ y1);
    marker(x, y, 'blue');
    x= 0.5*(x1+ x2); y= 0.5* (y1+ y2);
    marker(x, y, 'blue');

    //point on curve @ t= 0.5; (eg. "f(x(0.5), y(0.5))" )
    x= 1/ 4* (0.5* (x0+ x1)- x1)+ x1+ 1/ 4* (0.5* (x2+ x1)- x1);
    y= 1/ 4* (0.5* (y0+ y1)- y1)+ y1+ 1/ 4* (0.5* (y2+ y1)- y1);
    marker(x, y, 'red');
    x= 1/ 4* (0.5* (x1+ x2)- x2)+ x2+ 1/ 4* (0.5* (x0+ x2)- x2);
    y= 1/ 4* (0.5* (y1+ y2)- y2)+ y2+ 1/ 4* (0.5* (y0+ y2)- y2);
    marker(x, y, 'red');
    x= 1/ 4* (0.5* (x2+ x0)- x0)+ x0+ 1/ 4* (0.5* (x1+ x0)- x0);
    y= 1/ 4* (0.5* (y2+ y0)- y0)+ y0+ 1/ 4* (0.5* (y1+ y0)- y0);
    marker(x, y, 'red');

  }//~splotch.markers()
  function closure(v) {
    var x0, y0, x1, y1, x2, y2;
    x0= v[0]; y0= v[1];
    x1= v[2]; y1= v[3];
    x2= v[4]; y2= v[5];
    v.push(x0, y0);
    v.push(x1, y1);
  }

  //create a splotch;
  var v= [25,228,51,27,176,248];
  if(bRandom) {
    v= [];
    for(var i= 0; i< 6; i++) v.push(mt_rand(255));//add 3 control points (off the curve)
  }
  window.user._splotch= vector_copy(v);
  //echo(v);//dbg
  var c= 'green';//random_color();
  if(bMarkers) markers(v, c);// draw some visual cues
  closure(v);// finish the splotch
  bspline(v, c);//draw it
  var szInfo= strdup('\n', 17);
  szInfo+= 'splotch: '+ (window.user._splotch)+ '\n';
  szInfo+= 'LEGEND: \n';
  szInfo+= 'green: control point off curve\n';
  szInfo+= 'blue:  control point on curve\n';
  szInfo+= 'red:   point on curve at t= 0.5\n';
  szInfo+= 'yellow: center of mass\n';
  szInfo+= '\nNote: \n\tgreen, red and yellow are collinear.\n';
  szInfo+= '\tgreen, blue and again green are collinear.';
  if(bVerbose) return szInfo;
  else return window.user._splotch;//"echo(splotch(true, false, true));"
}//~splotch()
</SCRIPT>
<SCRIPT>
function PolyBezier(v, c, bMarker) {
  var i, n;
  n= v.length;
  for(i= 0; i< n; i++) {
    curve(
      v[i][0], v[i][1],
      v[i][2], v[i][3],
      v[i][4], v[i][5],
      v[i][6], v[i][7],
      c, bMarker
    );
  }
}//~PolyBezier()

function BSpline2PolyBezier(v, bClosed) {//Relaxed Uniform B-spline Curve
  var p0x, p1x, p2x, p3x;
  var p0y, p1y, p2y, p3y;
  var svx, svy, bv, i, n;
  n= v.length>> 1;
  if(n<= 2) return null;
  n--;
  svx= [];
  svy= [];
  bv= [];
  var c0, c1, c2;
  c0= 1/ 6;
  c1= 2/ 3;
  c2= 1/ 3;
  if(bClosed) {
    svx[0]= c0* v[2* n]+ c1* v[0]+ c0* v[2];//[n, 0, 1]
    svy[0]= c0* v[2* n+ 1]+ c1* v[1]+ c0* v[3];
    svx[n]= c0* v[2* (n- 1)]+ c1* v[2* n]+ c0* v[0];//[n- 1, n, 0]
    svy[n]= c0* v[2* (n- 1)+ 1]+ c1* v[2* n+ 1]+ c0* v[1];
  }else {
    svx[0]= v[0];
    svy[0]= v[1];
    svx[n]= v[2* n];
    svy[n]= v[2* n+ 1];
  }
  for(i= 1; i< n; i++) {
    svx[i]= c0* v[2* (i- 1)]+ c1* v[2* i]+ c0* v[2* (i+ 1)];
    svy[i]= c0* v[2* (i- 1)+ 1]+ c1* v[2* i+ 1]+ c0* v[2* (i+ 1)+ 1];
  }
  if(bClosed) {
    p0x= svx[n];
    p0y= svy[n];
    p1x= c1* v[2* n]+ c2* v[0];//[n, 0]
    p1y= c1* v[2* n+ 1]+ c2* v[1];
    p2x= c2* v[2* n]+ c1* v[0];
    p2y= c2* v[2* n+ 1]+ c1* v[1];
    p3x= svx[0];
    p3y= svy[0];
    bv.push([p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y]);
  }
  for(i= 1; i<= n; i++) {
    p0x= svx[i- 1];
    p0y= svy[i- 1];
    p1x= c1* v[2* (i- 1)]+ c2* v[2* i];//[i- 1, i]
    p1y= c1* v[2* (i- 1)+ 1]+ c2* v[2* i+ 1];
    p2x= c2* v[2* (i- 1)]+ c1* v[2* i];
    p2y= c2* v[2* (i- 1)+ 1]+ c1* v[2* i+ 1];
    p3x= svx[i];
    p3y= svy[i];
    bv.push([p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y]);
  }
  return bv;
}//~BSpline2PolyBezier()

function blot(bRandom, bFrame, bMarkers, bPointsOnCurve, bRandomAngleForArc, bRandomRadius, dwVertices) {//draw a blot using a Relaxed Uniform B-spline Curve; see also: splotch
  if(!arguments.length) {
    bFrame= true;
    bMarkers= true;
  }
  function _RUBS_imv(n) {//super-fast shortcut to some matrix inverse (Relaxed Uniform B-Spline closed curve)
    var v3= [3,  3, 5, -1, -1];//[3,  3, -1, -1, 5];//3:
    var v4= [4,  4, 7, -2, 1, -2];//4:
    var v, k, a, b, c;
    if(n>= 3) {//A 3x3 matrix is the minimum because to draw a closed curve using a Relaxed Uniform B-Spline curve we need at least three control points.
      switch(n) {
        case 3: return(v3); break;
        case 4: return(v4); break;
      }
    }
    c= (n>> 1)& 1;
    if(n& 1) {//if(n% 2) {//odd index
      v= vector_copy(v3);//NOTE: In this case the 3x3 matrix is the root for the next MxM matrices with M odd natural number.
      c= !c;
    }else {//even index
      v= vector_copy(v4);//NOTE: In this case the 4x4 matrix is the root for the next NxN matrices where N is a multiple of 2.
    }
    k= v.first();
    a= v.first();
    b= v.first();
    while(k!= n) {
      v.push(b);
      v.first(b);
      a= round((sqrt(3.0)+ 2.0)* a);
      b= round((sqrt(3.0)+ 2.0)* b);
      b= -b;
      k+= 2;
    }
    if(c) {
      v.foreach("v[i]= -v[i];");
      b= -b;
    };
    v.first(k, a, b);
    if((1/ a)< Math.DELTA) return null;//error: Math.RESOLUTION is too small
    if(b> Math.RESOLUTION) return null;
    //echof("%d: 1.0/ %s* [%s, ... //\t\t%s", n, a, b, v);//dbg
    //echof("%s/ %s ~= %s", b, a, sqrt(3.0));//dbg
    return v;//TODO: Compute the inverse matrix for more than 55 control points.
  }//~blot._RUBS_imv()

  function debug_bezier_curve(bv) {//Insist only on the first half. We wanna see if some polybezier is concatenated correctly.
    var i, j, t, vx, vy, x, y, v, n, color;
    n= bv.length;
    for(j= 0; j< n; j++) {
      switch(j) {
        case 0: color= 'red'; break;
        case 1: color= 'green'; break;
        case 2: color= 'blue'; break;
        default: color= 'yellow';
      }
      v= vector_copy(bv[j]);
      echof(" v[0]: %s", v);
      polygon(v, "yellow", true);
      vx= cubic_coefficients(v[0], v[2], v[4], v[6], false, 0, true, false);
      vy= cubic_coefficients(v[1], v[3], v[5], v[7], false, 0, true, false);
      vector_reverse(vx);
      vector_reverse(vy);
      for(i= 0; i< 13/ 2; i++) {
        t= (i+ 1)/ 13;
        x= horner(vx, t);
        y= horner(vy, t);
        //x+= 400; y+= 400;
        //echof("(%s %s) %s", x, y, t);
        circle(x, y, 4, color);
        marker(x, y, color);//dbg
      }
    }
  }//~blot.debug_bezier_curve()
  var v= [25,228,51,27,176,248];//"three control points"
//  var v= [25,228,51,27,176,248, 80, 140];
//  var v= [25,228,51,27,176,248, 180, 140];
//  var v= [25,228,51,27,176,248, 80, 300];
  var v= [25,228,51+ 20,27,176,248, 80, 300];

  vector_translate(v, 250);
  vector_scale(v, 1.5);

   if(!bRandom && bRandomAngleForArc.length) {v= bRandomAngleForArc;}

//  if(bRandom) {
//    v= [];
//    for(var i= 0; i< 6; i++) v.push(mt_rand(255));//add 3 control points (input data for a spline)
//  }
  if(bRandom) {
    var n, x, y, p, q;
    if(arguments.length== 1) {
      bRandomAngleForArc= true;
      bRandomRadius= true;
    }
    if(arguments.length>= 7) {
      n= dwVertices;
    }else {
      n= 13* 3;//vertices
      n= 13* 5;
    }
    v= [];
    p= 0.5;//inner radius
    q= 1.0;//outer radius
    p= 0.75;
    //"add n control points (input data for a spline)"
    v= range(0, n+ 1, 1);
    vector_normalize(v);

    if(bRandomAngleForArc) {
      v.push(0);//kludge(TODO: The Right Thing(TM)!)
      v.foreach("v[i]= interpolate_linear(v[i], v[i+ 1], random())");//compute random angle for each arc
      v.pop();//remove kludge
    }

    v.pop();//last vertex is malignant (will create a cusp on the circle)

    v.foreach("v[i]= revolve(v[i], lParam)", random());//revolve vertices around C(0, 0) (actually we are only working with angles at this point time)

    if(bRandomRadius) {
  //    v.foreach("var p= circle2point(0,0, 1, v[i], interpolate_linear(lParam[0], lParam[1], random())); v[i]= [p.x, p.y];", [p, q]);//points on circle (random radius)
      v.foreach("var p= circle2point(     1, v[i], interpolate_linear(lParam[0], lParam[1], random())); v[i]= [p.x, p.y];", [p, q]);//points on circle (random radius)
    }else {
      v.foreach("var p= circle2point(v[i]); v[i]= [p.x, p.y];", [p, q]);//points on circle
    }

    v= vector2D2vector(v);
    vector_scale(v, 125+ 50);
    vector_translate(v, 250+ 50);
    vector_scale(v, 1.5);
  }

  if(bMarkers) {
    var x, y, i;
    for(i= 0, x= 0, y= 0; i< v.length>> 1; i++) {
      x+= v[2* i];
      y+= v[2* i+ 1];
    }
    x/= v.length>> 1;
    y/= v.length>> 1;
//      x= (1.0/4.0)* (v[0]+ v[2]+ v[4]+ v[6]);
//      y= (1.0/4.0)* (v[1]+ v[3]+ v[5]+ v[7]);
    marker(x, y, "yellow");//"center of mass"
  }

  if(bPointsOnCurve) {
    if(3== v.length>> 1) {//"three control points"
//v= [100, 100, 200, 100, 200, 200];//dbg
//vector_scale(v, 2);//dbg
//vector_translate(v, 150);//dbg
//polygon(v, 'green', false);//dbg
      var p0x, p0y, p1x, p1y, p2x, p2y;
      var s0x, s0y, s1x, s1y, s2x, s2y;
      p2y= v.pop(); p2x= v.pop();
      p1y= v.pop(); p1x= v.pop();
      p0y= v.pop(); p0x= v.pop();

      s0x= (-1.0/ 3.0)* (p2x- 5.0* p1x+ p0x);
      s0y= (-1.0/ 3.0)* (p2y- 5.0* p1y+ p0y);

      s1x= (-1.0/ 3.0)* (-5.0* p2x+ p1x+ p0x);
      s1y= (-1.0/ 3.0)* (-5.0* p2y+ p1y+ p0y);

      s2x= (1.0/ 3.0)* (-1.0* p2x- p1x+ 5.0* p0x);
      s2y= (1.0/ 3.0)* (-1.0* p2y- p1y+ 5.0* p0y);

      v.push(s0x, s0y, s1x, s1y, s2x, s2y);
    }else if(4== v.length>> 1) {//"four control points"
//v= [100, 100, 200, 100, 200, 200, 100, 200];//dbg
//vector_scale(v, 2);//dbg
//vector_translate(v, 150);//dbg
//polygon(v, 'green', false);//dbg
      var p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
      var s0x, s0y, s1x, s1y, s2x, s2y, s3x, s3y;
      p3y= v.pop(); p3x= v.pop();
      p2y= v.pop(); p2x= v.pop();
      p1y= v.pop(); p1x= v.pop();
      p0y= v.pop(); p0x= v.pop();

      s0x= (1.0/ 4.0)* (1.0* p3x- 2.0* p2x+ 7.0* p1x- 2.0* p0x);
      s0y= (1.0/ 4.0)* (1.0* p3y- 2.0* p2y+ 7.0* p1y- 2.0* p0y);

      s1x= (-1.0/ 4.0)* (2.0* p3x- 7.0* p2x+ 2.0* p1x- p0x);
      s1y= (-1.0/ 4.0)* (2.0* p3y- 7.0* p2y+ 2.0* p1y- p0y);

      s2x= (1.0/ 4.0)* (7.0* p3x- 2.0* p2x+ p1x- 2.0* p0x);
      s2y= (1.0/ 4.0)* (7.0* p3y- 2.0* p2y+ p1y- 2.0* p0y);

      s3x= (-1.0/ 4.0)* (2.0* p3x- p2x+ 2.0* p1x- 7.0* p0x);
      s3y= (-1.0/ 4.0)* (2.0* p3y- p2y+ 2.0* p1y- 7.0* p0y);

      v.push(s0x, s0y, s1x, s1y, s2x, s2y, s3x, s3y);
    }else if(55>= (v.length>> 1)){//"three or more control points (to a maximum of 55)"
////v= [100, 100, 150, 75, 200, 100, 200, 200, 100, 200, 75, 150];//dbg: 6
//v= [100, 100, 200, 100, 200, 200, 100, 200, 75, 150];//dbg: 5
////v= [100, 100, 200, 100, 200, 200, 100, 200];//dbg: 4 control points
////v= [100, 100, 200, 100, 200, 200];//dbg: 3 control points
//vector_scale(v, 2);//dbg
////marker(300, 300, 'blue');//dbg
////circle(300, 300, 141, 'red');//dbg
////v.foreach("v[i]= round(v[i])");//dbg
//echof("%d: %s", v.length>>1, v);//dbg
//polygon(v, 'green', false);//dbg
      var m= _RUBS_imv(v.length>> 1);
      var vv= [];
      var i, j, k, m, n;
      var a, b, c, d;
      var x, y;
      n= m.first();
      a= 1.0/ m.first();//a= 6.0/ m.first();//dbg NOTE: Must scale by 6.0 because the original spline matrix is divided by 6.0.
      for(i= 0; i< n; i++) {
        x= 0;
        y= 0;
        for(j= 0; j< n; j++) {
           //var m_idx= (n- i+ j)% n;//NOTE: We are extracting the matrix values from the only representative row we have. Here we compute the index in the vector. This is a small mapping function.
           //m_idx= (m_idx+ n- 1)% n;//FIXUP: We want to start from the first control point.
           var m_idx= (n- 1- i+ j)% n;
           x+= m[m_idx]* v[2* j+ 0];
           y+= m[m_idx]* v[2* j+ 1];
        }
        x*= a;
        y*= a;
        vv.push(x, y);
      }
      if(bMarkers) for(i= 0; i< v.length>> 1; i++) circle(v[2* i+ 0], v[2* i+ 1], 5, 'yellow');//Generator CP
      v= vv;
      delete vv;
      delete m;
////vector_scale(v, 6.0);//dbg
////v.foreach("v[i]= round(v[i]);");//dbg
//echof("~%d: %s", n, v);//dbg
//polygon(v, 'red', true);//dbg
//return;//dbg
    }else {//TODO: "more than 55 control points"
      //
    }
  }
  if(bFrame) polygon(v, 'red');
  var bv= BSpline2PolyBezier(v, true);
  window.bv= bv;
  bv.v= v;
//  bv[0]= bv[0];//dbg
//  //bv.first();// bv.length= 1;//dbg
//  debug_bezier_curve(bv);//dbg
  PolyBezier(bv, 'green', bMarkers);
  return bv;
}//~blot()

//window.user.current_blot= blot(true, true, true, true, true, true, 12);//TODO:Skip matrix inverse. REASON: Get rid of curls and cusps. HINT: Use geometry, the center of mass, new intermediate control points on lines through CoM and GCP; and split in three each line through ICPs.
//window.user.current_blot= blot(true, true, false, false, false, false, 4);
//window.user.current_blot= blot(true, true, false, false, true, true, 100);

// // splotch(true, false); //quadratic
//blot(); // cubic
//blot(false, true, true, true);

////blot(false, true, true, true);
//blot(false, false, true, true);
//blot(false, true, true, false);

//TODO: make the blot a little more irregular (DONE!)
//HINT: place the blot's vertices on a circle's rays plus-minus a random value (maybe max50% the circle's radius)
//TODO: make the blot more irregular and nicer (more like a fractal or a road on map)
//HINT: use noise octaves

</SCRIPT>
<SCRIPT>
function PolyMarker(v2D, c) {
  var i, n;
  n= v2D.length;
  for(i= 0; i< n; i++) {
    marker(v2D[i][0], v2D[i][1], c);
  }
}//~PolyMarker()

function PolyBezier2D(VPB2D, c, bMarkers) {
  var p0, p1, p2, p3, i, n;
  n= VPB2D.length;
  for(i= 0; i< n; i++){
    p0= VPB2D[i][0];
    p1= VPB2D[i][1];
    p2= VPB2D[i][2];
    p3= VPB2D[i][3];
    curve(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1], p3[0], p3[1], c, bMarkers);
  }
}//~PolyBezier2D()

function CatmullRom2PolyBezier2D(V2D) {
  var p0, p1, p2, p3, i, n, V2DPB;
  function CR2B2D(p0, p1, p2, p3) {
    var a, b, c, d, e, f, g, h;
    var x0, x1, x2, x3, y0, y1, y2, y3;
    //CatmullRom: from graph space to equation space
    a= 0.5* (-p0[0]+ 3* p1[0]- 3* p2[0]+ p3[0]);
    b= 0.5* (2* p0[0]- 5* p1[0]+ 4* p2[0]- p3[0]);
    c= 0.5* (p2[0]- p0[0]);
    d= 0.5* (2* p1[0]);
    e= 0.5* (-p0[1]+ 3* p1[1]- 3* p2[1]+ p3[1]);
    f= 0.5* (2* p0[1]- 5* p1[1]+ 4* p2[1]- p3[1]);
    g= 0.5* (p2[1]- p0[1]);
    h= 0.5* (2* p1[1]);
    //Bezier: from equation space to graph space
    x0= d;
    x1= d+ 1/ 3* c;
    x2= d+ 2/ 3* c+ 1/ 3* b;
    x3= d+ c+ b+ a;
    y0= h;
    y1= h+ 1/ 3* g;
    y2= h+ 2/ 3* g+ 1/ 3* f;
    y3= h+ g+ f+ e;
    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];
  }//CatmullRom2PolyBezier.CR2B2D()
  V2DPB= [];
  n= V2D.length;
  p0= V2D[n- 1];
  p1= V2D[0];
  p2= V2D[1];
  p3= V2D[2];
  V2DPB.push(CR2B2D(p0, p1, p2, p3));
  for(i= 1; i< n- 2; i++) {
    p0= V2D[i- 1];
    p1= V2D[i];
    p2= V2D[i+ 1];
    p3= V2D[i+ 2];
    V2DPB.push(CR2B2D(p0, p1, p2, p3));
  }
  p0= V2D[n- 3];
  p1= V2D[n- 2];
  p2= V2D[n- 1];
  p3= V2D[0];
  V2DPB.push(CR2B2D(p0, p1, p2, p3));
  p0= V2D[n- 2];
  p1= V2D[n- 1];
  p2= V2D[0];
  p3= V2D[1];
  V2DPB.push(CR2B2D(p0, p1, p2, p3));
  return V2DPB;
}//~CatmullRom2PolyBezier2D()

function test_CatmullRomSpline(bSimple) {
  if(bSimple) {
    var V2DCR= [[1, 1], [-1, 1], [-1, -1], [1, -1]];
    var V2DPB= CatmullRom2PolyBezier2D(V2DCR);
    echo('CatmullRom control points:\n'+ V2DCR);
    echo('CatmullRom as Bezier control points:\n'+ V2DPB);
    V2DPB.foreach("v[i].foreach('vector_scale(v[i], 100)')");
    V2DPB.foreach("v[i].foreach('vector_translate(v[i], 300)')");
    PolyBezier2D(V2DPB, 'green', true);
  }else {
    var v, v2D, cpb2D;
    v= [359,563,367,427,537,392,629,474,631,555,537,618,297,803]; //"mouse2vector(7); v= vector_copy(window.user.mouse);prompt('mouse2vector', v)"
    v2D= vector2vector2D(v);
    cpb2D= CatmullRom2PolyBezier2D(v2D);
    //var v2D= [[539,486],[515,331],[703,253],[606,422],[894,493],[791,663],[608,549]];
    //var cpb2D= CatmullRom2PolyBezier2D(v2D);
    PolyBezier2D(cpb2D, 'green', true);
    PolyMarker(v2D, 'red');
    polygon(v, 'blue');
  }
}//~test_CatmullRomSpline()

</SCRIPT>
<SCRIPT>
function TListBox(parent, items, index, handler, bMultiple, lParam) {
   var r= new Rect(0, 0, 200, 1);
   var hwnd= CreateWindow(parent, r.left, r.top, r.right, r.bottom, "black", "white");
   hwnd.innerHTML= "<SELECT></SELECT>";
   var TList= hwnd.children(0);
   hwnd.TList= TList;
   hwnd.user.handler= handler;
   hwnd.user.lParam= lParam;
   TList.size= min(items.length, 35);
   TList.style.width= r.right;
   for(var i=0; i< items.length; i++) {
      var opt= document.createElement("OPTION");
      opt.text= items[i]; //"Item "+ (i+ 1);
      opt.value= items[i];
      TList.add(opt);
   }
   try{
      TList.item(index).selected= true;
   }catch(e){}
   function OnClick() {
      var e;
      var handler= this.user.handler;
      var lParam= this.user.lParam;
      var index= this.TList.selectedIndex;
      var item= items[index];
      var verb= TListBoxVerb;
      try{ handler(item, index, verb.focus, lParam);} catch(e) {};
   }
   function OnDblClick() {
      var e;
      var handler= this.user.handler;
      var lParam= this.user.lParam;
      var index= this.TList.selectedIndex;
      var item= items[index];
      var verb= TListBoxVerb;
      this.ShowWindow(false);
      this.CloseWindow();
      try{ handler(item, index, verb.process, lParam);} catch(e) {};
   }
   function OnKeyUp() {
      var e;
      var handler= this.user.handler;
      var lParam= this.user.lParam;
      var index= this.TList.selectedIndex;
      var item= items[index];
      var verb= TListBoxVerb;
      switch(window.event.keyCode) {
         case VK_ESC: {
            this.CloseWindow();
            try{ handler(item, index, verb.cancel, lParam);} catch(e) {};
         } break;
         case VK_ENTER: {
            this.ShowWindow(false);
            this.CloseWindow();
            try{ handler(item, index, verb.process, lParam);} catch(e) {};
         } break;
         case VK_LEFT:
         case VK_RIGHT:
         case VK_PAGEUP:
         case VK_PAGEDOWN:
         case VK_HOME:
         case VK_END:
         case VK_UP:
         case VK_DOWN: {
            try{ handler(item, index, verb.focus, lParam);} catch(e) {};
         }break;
         case VK_INSERT: {
            try{ handler(item, index, verb.insert, lParam);} catch(e) {};
         }break;
         case VK_DELETE:{
            try{ handler(item, index, verb.remove, lParam);} catch(e) {};
         }break;
         default: Tooltip(hex(window.event.keyCode));
      }
   }
   hwnd.onclick= OnClick;
   hwnd.ondblclick= OnDblClick;
   hwnd.onkeyup= OnKeyUp;

   var e;
   var handler= hwnd.user.handler;
   var lParam= hwnd.user.lParam;
   var index= hwnd.TList.selectedIndex;
   var item= items[index];
   var verb= TListBoxVerb;
   try{ handler(item, index, verb.init, lParam);} catch(e) {};

   hwnd.ShowWindow(true);
   hwnd.TList.focus();
   return hwnd;
}//~TListBox()

window.TListBox= TListBox;

function TSelectFile(folder_name) { //TSelectFile("a:\\");
   function process_file(item, index, verb, lParam) {
      var file_name= item;
      var str= "[verb:"+ verb+ "]("+ index+ ") file: "+ file_name;
      str+= '\n'+ lParam[index];
      switch(verb){
        case TListBoxVerb.process: {
           alert(item);
        }break;
        case TListBoxVerb.init:// alert("init");
        case TListBoxVerb.focus:
        case TListBoxVerb.insert:
        case TListBoxVerb.remove:
        case TListBoxVerb.cancel:
        default: {
          Tooltip(str);
        }
      }
   }
  var files= list_files(folder_name);
  files= files.file;
  for(var i= 0; i< files.length; i++) {
    files[i]= files[i].Path;
  }
  var wnd_parent= null;
  if(isObject(window.user.usermenu.hwnd))
    wnd_parent= window.user.usermenu.hwnd;
  var w= TListBox(wnd_parent, files, 1, process_file, false, files);
  w.focus();
}//~TSelectFile()

</SCRIPT>
<SCRIPT>
function Dictionary() {
   this._keys= new Array();
   this._values= new Array();
   this._items= new Array();
   function count() {
      return this._items.length;
   }
   function setItem(index, key_index, value_index) {
      this._items[index]= new Array(2);
      this._items[index][0]= key_index;
      this._items[index][1]= value_index;
   }
   function items() {
      var n= this._items.length;
      var v= new Array(n);
      var j= 0;
      for(var i= 0; i< n; i++) {
         v[j]= this.item(i);
         if(v[j]!= undefined) j++;
      };
      v.length= j;
      return v;
   }
   function keys() {
      var v= new Array(this._keys.length);
      for(var i= 0; i< this._keys.length; i++) {
         v[i]= this._keys[i];
      }
      return v;
   }
   function values() {
      var v= new Array(this._values.length);
      for(var i= 0; i< this._values.length; i++) {
         v[i]= this._values[i];
      }
      return v;
   }
   function add(key, value) {
      var key_ID= this._keys.length;
      var value_ID= this._values.length;
      var item_ID= this._items.length;
      this._keys[key_ID]= key;
      this._values[value_ID]= value;
      this._items[item_ID]= new Array(2);
      this._items[item_ID][0]= key_ID;
      this._items[item_ID][1]= value_ID;
      return item_ID;
   }
   function del(key) {
      var n= this._keys.length;
      for(var i= 0; i< n; i++) {
         if(this._keys[i]== key) break;
      }
      if(i< n) {
         var key_ID= i;
         n= this._items.length;
         for(i= 0; i< n; i++) {
            if(this._items[i][0]== key_ID) break;
         }
         if(i< n) {
            var item_ID= i;
            var value_ID= this._items[item_ID][1];
            for(i= key_ID; i< this._keys.length; i++) {
               this._keys[i]= this._keys[i+ 1];
            }
            this._keys.length--;
            for(i= value_ID; i< this._values.length; i++) {
               this._values[i]= this._values[i+ 1];
            }
            this._values.length--;
            for(i= item_ID; i< this._items.length; i++) {
               this._items[i]= this._items[i+ 1];
            }
            this._items.length--;
            for(i= 0; i< this._items.length; i++) {
               if(this._items[i][0]> key_ID) this._items[i][0]--;
               if(this._items[i][1]> value_ID) this._items[i][1]--;
            }
            return true;
         }
      }
      return false;
   }
   function get(key) {
   }
   function set(key, value) {
      return this.add(key, value);
   }
   function key(index) {
      if(this._items[index]!= undefined) {
         return this._keys[this._items[index][0]];
      }else return undefined;
   }
   function value(index) {
      if(this._items[index]!= undefined) {
         return this._values[this._items[index][1]];
      }else return undefined;
   }
   function item(index) {
      if(this._items[index]!= undefined) {
         return [this._keys[this._items[index][0]], this._values[this._items[index][1]]];
      }else return undefined;
   }
   function valueOf() {
      return this.items();
   }
   function toString() {
      var n= this._items.length;
      var p= 0;
      var str= '';
      for(var i= 0; i< n; i++) {
         var t= this.item(i);
         if(t!= undefined) {
            str+= "<ITEM ID='"+ (i- p)+ "'>";
            str+= "<KEY>"+ escape(t[0].toString())+"</KEY>";
            str+= "<VALUE>"+ escape(t[1].toString())+"</VALUE>";
            str+= "</ITEM>\n";
         } else p++;
      }
      str="<DICTIONARY ID='"+ parseInt(this.ID)+ "' COUNT='"+ (n- p)+ "'>\n"+ str+ "</DICTIONARY>";
      return str;
   }
   function reverse() {
      this._items.reverse();
   }
   this.setItem= setItem;
   this.add= add;
   this.del= del;
   this.get= get;
   this.set= set;
   this.count= count;
   this.key= key;
   this.value= value;
   this.item= item;
   this.keys= keys;
   this.values= values;
   this.items= items;
   this.valueOf= valueOf;
   this.toString= toString;
   this.reverse= reverse;
   this.ID= window.Dictionaries.length;
   window.Dictionaries[this.ID]= this;
}
window.Dictionary= Dictionary;
window.Dictionaries= new Array();

/*
function TestDictionary() {
   d= new Dictionary();
   d.add("a", "abyss");
   d.add("b", "baboo");
   d.add("foo", "bar");
   d.add("John", "Doe");
   d.add("Jane", "Doe");
   d.add("c", "crap");
   echo("ITEMS:", d.items());
//   d.reverse();
   d.del("foo");
   d.del("Jane");
   d.reverse();
   d.add("bronze", "metal");
   d.add("meadow", 'grassland');
   echo("ITEMS:", d.items(), '\n');
   var n= d.count();
   for(var i= 0; i< n; i++) {
      echo(i, ':', d.key(i), ':', d.value(i), ':',  d.item(i));
   }
   echo('\nkeys:', d.keys());
   echo('values:', d.values());
   echo('items:', d.items());
}
TestDictionary();
*/
</SCRIPT>
<SCRIPT>
function AppProfile(filename) {
   function LoadProfile(filename) {
      this.filename= filename;
      this.profile= file_get_contents(this.filename);
   }
   function SaveProfile() {
      file_put_contents(this.filename, this.profile.toString());
   }
   function EvalProfile() {
      function isEmpty(line) {
         if(line.length== 0) return true;
         return false;
      }
      function isComment(line) {
         if(line.substr(0, 1)== '#') return true;
         return false;
      }
      function isSection(line) {
         if(line.substr(0, 1)== '[' && line.substr(line.length- 1, 1)== ']') {
            //todo: test if is a valid section_name
            return true;
         }
         return false;
      }
      function isKey(line) {
         var i;
         for(i= 0; i< line.length; i++) {
            if(line.substr(i, 1)== '=') break;
         }
         if(i!= (line.length- 1)) return true;
         return false;
      }
      function getSectionName(line) {
         return line.substr(1, line.length- 2);
      }
      function getKeyTuple(line) {
         var tuple= new Array(2);
         var i;
         for(i= 0; i< line.length; i++) {
            if(line.substr(i, 1)== '=') break;
         }
         tuple[0]= line.substr(0, i);
         tuple[1]= trim(line.substr(i+ 1, line.length- i));
         return tuple;
      }
      var profile= new Object();
      var lines= this.profile.split("\n");
      var j= 0;
      var section;
      for(var i= 0; i< lines.length; i++) {
         lines[j]= trim(lines[i]);
         if(isEmpty(lines[j])) continue;
         if(isComment(lines[j])) continue;
         if(isSection(lines[j])) {
            //
            section= getSectionName(lines[j]);
            j++
         }else {
            if(isKey(lines[j])) {
               //
               var tuple= getKeyTuple(lines[j]);
               var key= tuple[0];
               var value= tuple[1];
               echo('<', section, ':', key, ':', value, '>');
               j++
            }
         }
      }
      lines.length= j;
      profile.section= lines;
      echo(profile.section);
//      this.profile= profile;
   }
   function GetSection(section) {
      return this.profile.section[section];
   }
   function SetSection(section, data) {
      this.profile.section[section]= data;
   }
   function GetVal(section, entry, defValue) {
      return this.profile.section[section][entry];
   }
   function SetVal(section, entry, value) {
      this.profile.section[section][entry]= value;
   }

   this.LoadProfile= LoadProfile;
   this.SaveProfile= SaveProfile;
   this.EvalProfile= EvalProfile;
   this.GetSection= GetSection;
   this.SetSection= SetSection;
   this.GetVal= GetVal;
   this.SetVal= SetVal;

   if(arguments.length== 1) {
      this.LoadProfile(filename);
      this.EvalProfile();
   }
}//~AppProfile()
window.AppProfile= AppProfile;
//window.AppProfile.ini_file= new AppProfile("main.ini");
</SCRIPT>
<SCRIPT>
function Popup(position, data) {
   var r= new Rect(position);
   var hwnd= CreateWindow(null, r.left, r.top, r.right, r.bottom, "black", "white");

   function get_data() {return this.hwnd.innerHTML;}
   function set_data(data){
      this.hwnd.user.data= data;
      this.hwnd.innerHTML= data;
   }
   function reposition(x, y, width, height) {return this.hwnd.MoveWindow(x, y, width, height);}
   function show() {this.hwnd.Show(true);}
   function hide() {
      var e; try{
         this.hwnd.Show(false);
      }catch(e) {
         try { this.Show(false);} catch(e) {};
      }
   }
   function destroy() {this.hwnd.CloseWindow();}
   function visible() {return (this.hwnd.style.display== 'block')? true: false;}
   function toggle() {if(this.visible()) {this.hide();}else {this.show();}}
   function configure() {
      if(!this.gestalt) {
         this.gestalt= true;
         //
         alert("popup configuration panel");
      }else {
         alert("popup configured!");
         //
         this.gestalt= false;
      }
   }
   function bind_keyboard(vkey) {
      function OnPopup_key(bKeyDown) {
         var msg= window.event;
         msg.cancelBubble = true;
         msg.returnValue= false;
         if(bKeyDown) return;
         if(msg.ctrlKey) {
            window.user.usermenu.configure();
         }else {
            window.user.usermenu.toggle();
         }
      }
      return setKeyFunc(vkey, OnPopup_key);
   }
   this.get_data= get_data;
   this.set_data= set_data;
   this.reposition= reposition;
   this.show= show;
   this.hide= hide;
   this.destroy= destroy;
   this.visible= visible;
   this.toggle= toggle;
   this.configure= configure;
   this.bind_keyboard= bind_keyboard;
   this.hwnd= hwnd;
   this.hwnd.ondblclick= this.hide;
   this.set_data(data);
}

function UserMenu() {
   if(typeof(window.user.usermenu)== 'object') {
      var e; try {
         window.user.usermenu.destroy();
      } catch(e) {};
   }
   var p= new Popup(null, "popup test [window.user.usermenu]");
   p.bind_keyboard(VK_F2);
   p.hwnd.FontSize(13);
   window.user.usermenu= p;
//   window.user.usermenu.show();
   return p;
}
</SCRIPT>
<SCRIPT>
function Registry(szRoot) {
 function root(path) {
   if(isString(path)) {this._root= path;}
   return this._root;
 }
 function remove(key) {
   var e;
   if(isString(key)) {
      key= this._root+ key;
   } else {
      key= this._root;
   }
   try {
      this._server.remove(key);
      return true;
   }catch(e) {
      return false;
   }
 }
 function get(key) {
    var e;
    if(isString(key)) {
       key= this._root+ key;
    } else {
       key= this._root;
    }
    try {
         return this._server.get(key);
    } catch(e) {
         return null;
    }
 }
 function set(key, data, type) {
    if(arguments.length== 1) {
       data= key;
       key= null;
       type= "REG_SZ";
    }
    if(isString(key)) {
       key= this._root+ key;
    } else {
       key= this._root;
    }
    if(!isString(type)) {
       type= "REG_SZ";
    }
    try {
       this._server.set(key, data, type);
       return true;
    } catch(e) {
       return false;
    }
 }
 function toString() {
    return "["+this._root+"]\n@='"+ this.get()+ "'";
 }
 this._server= syscall('shell').Registry;
 if(isNull(this._server)|| (this._server== undefined)) return (new Null());
 this._root= this._server.root;
 if(isString(szRoot)) this._root+= szRoot+ "\\";
 this.toString= toString;
 this.root= root;
 this.remove= remove;
 this.get= get;
 this.set= set;
 return this;
}//~Registry()

function Ramdrive() {//UNDER DEVELOPMENT
  function save(file_name, data) {
    var key;
    if(file_name.charAt(0)== ':') {//":TaskManager"
	  key= substr(file_name, 1);
    }else {
      key= 'ScriptX_ramdrive_'+ string2hex(file_name);
    }
    return this._obj.set(key, escape(data));
  }
  function load(file_name) {
    var key, data;
    if(file_name.charAt(0)== ':') {//":TaskManager"
	  key= substr(file_name, 1);
    }else {
      key= 'ScriptX_ramdrive_'+ string2hex(file_name);
    }
    data= this._obj.get(key);
    if(isNull(data)) return false;
    return unescape(data);
  }
  function list() {
    var key= 'ScriptX_ramdrive_files';
    var files= this._obj.get(key);
    if(isNull(files)) return null;
    files= files.split('\n');
    files.foreach('v[i]= unescape(v[i]);');
    return files;
  }
  function zap() {
    return false;
  }
  var r= new Registry();
  if(isNull(r)) return new Null;
  r.root('HKEY_CURRENT_USER\\Volatile Environment\\');//ramdrive
  this._obj= r;
  this.save= save;
  this.load= load;
  this.list= list;
  this.zap= zap;
  return this;
}//~Ramdrive()

function ramdrive_list() {
  var r= new Ramdrive;
  if(!isNull(r)) return r.list();
  return null;
}

function ramdrive_zap() {
  var r= new Ramdrive;
  if(!isNull(r)) return r.zap();
  return false;
}

function ramdrive_get_contents(file_name) {
  var r= new Ramdrive;
  if(!isNull(r)) return r.load(file_name);
  return false;
}

function ramdrive_put_contents(file_name, data) {
  var r= new Ramdrive;
  if(!isNull(r)) return r.save(file_name, data);
  return false;
}

function clipboard(data) {
  if(arguments.length) {
    return ramdrive_put_contents('$clipboard', data);
  }else {
    return ramdrive_get_contents('$clipboard');
  }
}
</SCRIPT>
<SCRIPT>

function Shell() {
  function _Registry() {
    function get(key) {
          return syscall('shell').Shell.RegRead(key);
    }
    function set(key, data, type) {
          return syscall('shell').Shell.RegWrite(key, data, type);
    }
    function remove(key) {
          return syscall('shell').Shell.RegDelete(key);
        }
    var r= new Object();
    r.get= get;
    r.set= set;
    r.remove= remove;
    r.root= "HKEY_CURRENT_USER\\Software\\ScriptX013\\";
    return r;
  }
  function WinExec(szCmd, bWait, mode) {
    var e;
    try {
      if(!mode) mode= TaskMode.Normal;
      if(bWait) return this.Shell.Run(szCmd, mode, bWait);
      var task= this.Shell.Exec(szCmd);
      if(task.Status== TaskState.failed) {
         return null;
      }else {
         return task;
      }
    }catch(e) {
      SetLastError(['Error: Shell: WinExec: '+ e.description,
          e.number& 0xFFFF, get_call_stack(arguments.callee)]);
      return null;
    }
    /* hProcess= WinExec("notepad.exe");
       if(confirm("Close notepad?")) hProcess.Terminate();
    */
  }
  function WaitTask(szCmd, mode) { // syscall('shell').WaitTask(WinExec('notepad.exe'))
    if(!mode) mode= TaskMode.Normal;
    WinExec(szCmd, true, mode);
  }
  function MessageBox(msg, title, type) {
    if(!isString(title))
         title= document.title+ " "+ this.FileSystem.GetAbsolutePathName("");
    if(isNull(type))   type= PopupType.OK;
    return this.Shell.Popup(""+ msg, undefined, title, type);
  }
  function Exec(szCmd) {
    return this.Shell.Exec(szCmd);
  }
  function Run(szCmd, mode, bWait) {
    return this.Shell.Run(szCmd, mode, bWait);
  }
  function shutdown(seconds) { // System Shutdown (Abort: "shutdown(false)")
   var bAbort= (seconds== false);
   var cmd;
   if(bAbort) {
      cmd= 'shutdown.exe -a';
   }else {
      seconds= parseInt(seconds);
      if(isNaN(seconds)) seconds= 13;
      cmd= 'shutdown.exe -s -f -t '+ seconds;
   }
   return this.WinExec(cmd);
  }
  function mkdir(folder_name) {
    return this.FileSystem.CreateFolder(folder_name);
  }
  function rmdir(folder_name, bForce) {
    return this.FileSystem.DeleteFolder(folder_name, bForce);
  }
  function mvdir(src, dest) {
    return this.FileSystem.MoveFolder(src, dest);
  }
  function pwd() {
    var pwd= this.Shell.CurrentDirectory;
    if(pwd.charAt(pwd.length- 1)!= '\\') pwd+= '\\';
    return pwd;
  }
  function cd(folder_name) {
    this.Shell.CurrentDirectory= folder_name;
    return this.pwd();
  }
  function dir(folder_name) {
    if(!arguments.length) folder_name= this.pwd();
    return this.folders(folder_name).concat(this.files(folder_name));
  }
  function file_exists(file_name) {
     return this.FileSystem.FileExists(file_name);
  }
  function drives() {
    return list_drives(true);
  }
  function folders(folder_name) {
    if(!arguments.length) folder_name= this.pwd();
    return list_folders(folder_name).folder;
  }
  function files(folder_name) {
    if(!arguments.length) folder_name= this.pwd();
    return list_files(folder_name).file;
  }
  function split_path(path, bFull){
    var t= new Object();
    function toString() {
      var s= "[\n";
      s+= "path:\t'"+ this.path+ "'\n";
      s+= "drive:\t'"+ this.drive+ "'\n";
      s+= "name:\t'"+ this.name+ "'\n";
      s+= "extension:\t'"+ this.extension+ "'\n";
      s+= "folder:\t'"+ this.folder+ "'\n";
      s+= "drive_alive:\t'"+ this.drive_alive+ "'\n";
      s+= "folder_alive:\t'"+ this.folder_alive+ "'\n";
      s+= "file_alive:\t'"+ this.file_alive+ "'\n";
      s+= "]";
      return s;
    }
    t.toString= toString;
    var f= this.FileSystem;
    t.path= f.GetAbsolutePathName(path);
    t.drive= f.GetDriveName(t.path);
    t.name= f.GetBaseName(t.path);
    t.extension= f.GetExtensionName(t.path);
    t.folder= t.path.slice(0, t.path.lastIndexOf(t.name+ '.'+ t.extension));
    t.drive_alive= f.DriveExists(t.drive);
    t.folder_alive= f.FolderExists(t.folder);
    t.file_alive= f.FileExists(t.path);
    if(bFull) {
       t.TOS= f;
       if(t.drive_alive) {
          t.TDrive= f.GetDrive(t.drive);
       }else {
          t.TDrive= null;
       }
       if(t.file_alive) {
          t.TFile=  f.GetFile(t.path);
       }else{
          t.TFile= null;
       }
    }
    return t;
  /*
    s= syscall('shell').split_path(window.location.pathname);
    MessageBox(s);
  */
  }//~split_path()
  function isRamdisk(path, bHint) {
    var d, s;
    s= syscall('shell');
    if(isNull(s)) return null;
    var d= s.split_path(path);
    d= s.FileSystem.getDrive(d.drive);
    if(d.IsReady) {
      if(d.DriveType== DriveTypes.RAMDisk) {
        return true;
      }else {
        if(bHint) {
          if(!strcmp(d.VolumeName.toLowerCase(), 'ramdisk')) return true;
        }
        return false;
      }
    }
    return false;
  }//~isRamdisk()

  if((this== syscall('window'))|| (typeof(this.constructor)== 'undefined')) { // [FF2] [IE6] BUGFIX
    SetLastError(['Shell: Use of the "new" operator required!',
        Errors.InvalidTarget, get_call_stack(arguments.callee)]);
    return null;
  }
  this.Shell= new TObject("WScript.Shell");
  if(isNull(this.Shell)) return (new Null());
  this.FileSystem= new TObject("Scripting.FileSystemObject");
  if(isNull(this.FileSystem)) return (new Null());
  this.Exec= Exec;
  this.Run= Run;
  this.shutdown= shutdown;
  this.WaitTask= WaitTask;
  this.WinExec= WinExec;
  this.MessageBox= MessageBox;
  this.Registry= _Registry();
  this.pwd= pwd;
  this.cd= cd;
  this.dir= dir;
  this.mkdir= mkdir;
  this.rmdir= rmdir;
  this.mvdir= mvdir;
  this.file_exists= file_exists;
  this.drives= drives;
  this.folders= folders;
  this.files= files;
  this.split_path= split_path;
  this.isRamdisk= isRamdisk; //syscall('shell').isRamdisk(window.location.pathname, true)
  return this;
}//~Shell()

</SCRIPT>
<SCRIPT>
function file_IO_data(data, bEncode) {
  var szUnicode, szAscii, i, n;
  szUnicode= hex2unicode("20AC201A0192201E20262020202102C62030016020390152017D20182019201C201D20222013201402DC21220161203A0153017E0178");
  szAscii= hex2string("8082838485868788898A8B8C8E9192939495969798999A9B9C9E9F");
  n= szAscii.length;
  for(i= 0; i< n; i++) {
    var cu, ca;
    cu= szUnicode.charAt(i);
    ca= szAscii.charAt(i);
    if(bEncode) {
      data= data.split(ca).join(cu);
    }else {
      data= data.split(cu).join(ca);
    }
  }
  return data;
}//~file_IO_data()
function file_exists(file_name) {
  var s;
  s= syscall('shell');
  if(!isNull(s)) return s.file_exists(file_name);
  else return null;
}//~file_exists()
function file_create(file_name) {
  var e;
  try {
    var fso= TObject("Scripting.FileSystemObject");
    var f= fso.OpenTextFile(file_name, IOmode.ForWriting, true);
    f.Close();
    f= fso.GetFile(file_name);
    return f.Path;
  }catch(e) {
    return false;
  }
}//~file_rename()
function file_rename(file_name, new_name) {
   var e;
   try {
      var fso= TObject("Scripting.FileSystemObject");
      if(fso.FileExists(file_name)) {
         var f= fso.GetFile(file_name);
         f.Name= new_name;
         return f.Path;
      }
   }catch(e) {
      return false;
   }
}//~file_rename()
function file_delete(file_name, bForce) {
  try {
    var f= syscall('shell').FileSystem;
    if(f.FileExists(file_name)) {
      f= f.GetFile(file_name);
      f.Delete(bForce);
      return true;
    }
  }catch(undefined) {}
  return false;
}//~file_delete()
function file_size(file_name) {
   var e;
   try {
      var fso= TObject("Scripting.FileSystemObject");
      if(fso.FileExists(file_name)) {
         var f= fso.GetFile(file_name);
         return f.size;
      }
   }catch(e) {
      return false;
   }
}//~file_size()
function file_read(file_name, bUnicode) {
  var e;
  try {
    var fso= TObject("Scripting.FileSystemObject");
    if(fso.FileExists(file_name)) {
    var f= fso.GetFile(file_name);
    var ts = f.OpenAsTextStream(IOmode.ForReading, (bUnicode)? IOformat.Unicode: IOformat.Ascii);
    var data= ts.ReadAll();
    if(!bUnicode) {
      data= file_IO_data(data, false);
    }
    ts.Close();
    return data;
   }else return undefined;
  }catch(e) {
    SetLastError(['Error: file_read: '+ e.description, e.number& 0xFFFF, get_call_stack(arguments.callee), [file_name, bUnicode]]);
    return null;
  }
}//~file_read()
function file_write(file_name, ustring, bUnicode) {//[UNDER CONSTRUCTION]
  var e;
  try {
    if(!bUnicode) {
      ustring= file_IO_data(ustring, true);
    }
    var fso, ts, f;
    fso= TObject("Scripting.FileSystemObject");
    if(!fso.FileExists(file_name))
      fso.CreateTextFile(file_name).Close();
    f= fso.GetFile(file_name);
    ts = f.OpenAsTextStream(IOmode.ForWriting, ((bUnicode)? IOformat.Unicode: IOformat.Ascii));
    ts.Write(ustring);
    ts.Close();
    return f.size;
  }catch(e) {
    SetLastError(['Error: file_write: '+ e.description, e.number& 0xFFFF, get_call_stack(arguments.callee), [file_name, ustring, bUnicode]]);
    return false;
  }
}//~file_write()
function file_append(file_name, ustring, bUnicode) {
  var e;
  try {
    if(!bUnicode) {
      ustring= file_IO_data(ustring, true);
    }
    var fso, ts, f;
    fso= TObject("Scripting.FileSystemObject");
    if(!fso.FileExists(file_name)) {
      fso.CreateTextFile(file_name).Close();
    }
    f= fso.GetFile(file_name);
    ts= f.OpenAsTextStream(IOmode.ForAppending, (bUnicode)? IOformat.Unicode: IOformat.Ascii);
    ts.Write(ustring);
    ts.Close();
    return f.size;
  }catch(e) {
    SetLastError(['Error: file_append: '+ e.description, e.number& 0xFFFF, get_call_stack(arguments.callee), [file_name, ustring, bUnicode]]);
    return false;
  }
}//~file_append()
function file_block_read(file_name, start, stop) {
  var fso, f, data, data_size, fsize, bCreate, e;
  if(!file_exists(file_name)) return null;
  if(!start) start= 0;
  if((start>= stop)&& (stop)) return null;
  if(start< 0) return null;
  fso = new TObject('Scripting.FileSystemObject');
  fsize= 0;
  fsize= file_size(file_name);
  if(!fsize) return null;
  if(!stop) stop= fsize;
  if(stop> fsize) stop= fsize;
  if(start> fsize) return null;
  if(stop< 0) {
    data_size= -stop;
  }else {
    data_size= stop- start;
  }
  bCreate= false;
  try {
    f = fso.OpenTextFile(file_name, IOmode.ForReading, bCreate, IOformat.Ascii);
    f.Skip(start);
    //if(f.AtEndOfStream) {echo("Error: FileIOError: File at end of stream!");};//dbg
    data= f.Read(data_size);
    f.Close();
  }catch(e) {
    try{ f.Close()} catch(e) {};
    //echo('Error: FileIOError: ');//dbg
    //for(var i in e) echo(i+ ': '+ eval("e."+ i));//dbg
    f= TObject('Scripting.FileSystemObject').GetFile(file_name).OpenAsTextStream(IOmode.ForReading, IOformat.Ascii);
    f.Skip(start);
    data= f.Read(data_size);
    f.Close();
  }
  data= file_IO_data(data, false);
  return (data);
}//~file_block_read()
function file_copy(file_name, new_file) {
  var e;
  try {
    var fso= TObject("Scripting.FileSystemObject");
    if(fso.FileExists(file_name)) {
      f= fso.GetFile(file_name);
      f.Copy(new_file);
      return true;
    }
  }catch(e) {}
  return false;
}//~file_copy()
function file_move(file_name, new_file) {
  var e;
  try {
    var fso= TObject("Scripting.FileSystemObject");
    if(fso.FileExists(file_name)) {
      f= fso.GetFile(file_name);
      f.Move(new_file);
      return true;
    }
  }catch(e) {}
  return false;
}//~file_move()

//function file_rename(file_name, new_file) { return file_move(file_name, new_file);}

/*
function test_file_funcs() {
   var s= "";
   for(i= 0; i<= 0xFFFF; i++) {
      s+= chr(i);
   }
   var file_name= "a:\\test.txt";
   var new_file_name= "test.xtx";
   var bUnicode= true;
   alert("file_exists: "+ file_exists("a:\\text.xtx"));
   prompt("file_create \nRESULT:", file_create("a:\\test.txt"));
   file_write(file_name, "MZ", false);
   file_append(file_name, s, bUnicode);
   s= file_read("a:\\test.txt", bUnicode);
   echo(file_size("a:\\test.txt"));
   prompt("file_delete \nRESULT:", file_delete("a:\\text.xtx"));
   prompt("file_rename \nRESULT:", file_rename("a:\\test.txt", "text.xtx"));
}
test_file_funcs();
*/
</SCRIPT>
<SCRIPT>
function mkdir(szDir) {//make folder
  var sh, e;
  sh= new Shell();
  try{
    sh.mkdir(szDir);
    return true;
  } catch(e) {
    return false;
  }
}//~mkdir()

function rmdir(szDir) {//delete/remove/erase/zap folder (ACHTUNG: Beware! The erased folder can contain important data that might be forever lost. )
  var sh, e;
  sh= new Shell();
  try{
    sh.rmdir(szDir);
    return true;
  } catch(e) {
    return false;
  }
}//~rmdir()

function mvdir(src, dst) {//move folder
  var sh, e;
  sh= new Shell();
  try{
    sh.mvdir(src, dst);
    return true;
  } catch(e) {
    return false;
  }
}//~mvdir()

function chdir(szDir) {//change directory
  var sh, e;
  sh= new Shell();
  if(!arguments.length) return sh.pwd();
  try{
    sh.cd(szDir);
    return true;
  } catch(e) {
    return false;
  }
}//~chdir()

function pwd() {
  var sh= new Shell();
  return sh.pwd();
}
</SCRIPT>
<SCRIPT>
function isThread(t) {
   if(t!= null)
      return ((typeof(t)== 'object')&& (t.constructor== Thread))? true: false;
   return false;
}

function Thread(thread_events, lParam) {
  if((this== syscall('window'))|| (typeof(this.constructor)== 'undefined')) { // [FF2] [IE6] BUGFIX
    SetLastError(['Thread: Use the "new" operator!',
        Errors.InvalidTarget, get_call_stack(arguments.callee)]);
    return null;
  }
  function initialize() {
    syscall('atoms')[this.guid]= this;
    if(typeof(this.thread.initialize)== 'function')
      return this.thread.initialize(this, this.thread.lParam);
  }
  function destroy() {
    if(this.refer) {
      unschedule(this.refer);
      this.refer= null;
    }
    if(this.bPolling) this.poll(0);
    delete syscall('atoms')[this.guid];
    if(typeof(this.thread.destroy)== 'function')
      return this.thread.destroy(this, this.thread.lParam);
  }
  function run(lParam) {
    this.bRunning= true;
    if(typeof(this.thread.run)== 'function') {
      if((arguments.length== 0)&& this.bJobsPending) {
        var _jobs= this.jobs(true);
        return this.thread.run(this, _jobs);
      }else {
        if(arguments.length)
          return this.thread.run(this, lParam);
        else return this.thread.run(this);
      }
    }else if(this.bJobsPending) return this._jobs.length;
  }
  function stop(bForce, bPolling) {
    this.bRunning= false;
    if(bForce&& (this.bSleeping|| this.bPolling|| this.refer)) {
      if(this.bPolling) this.poll(0);
      return this.wake(true);
    }
    if(bPolling) return this.poll(0);
    if(typeof(this.thread.stop)== 'function')
      return this.thread.stop(this, this.thread.lParam);
  }
  function job(lParam, bReschedule, ms, bAll) {
    this.timestamp_job= syscall('timestamp');
    this._jobs.append(lParam);
    this.bJobsPending= true;
    if(bReschedule) {
      if(!bAll) return this.sleep(ms, bAll);
      return this.sleep(ms);
    }
    if(this.bSleeping&& this.bWakeOnJob)
       return this.wake();
    else if(!this.refer) return this.run();
         return this._jobs.length;
  }
  function jobs(bDischarge) {
    var t= this._jobs;
    if(bDischarge) {
      this._jobs= [];
      this.bJobsPending= false;
    }
    return t;
  }
  function wake(bStop) {
    this.timestamp_wake= syscall('timestamp');
    this.isSleeping= false;
    if(this.refer) {
      unschedule(this.refer);
      this.refer= null;
    }
    if(bStop) {
      if(this.jobs().length) this.run();
      this.bRunning= false;
      if(typeof(this.thread.stop)== 'function')
        return this.thread.stop(this, this.thread.lParam);
    }
    return this.run();
  }
  function sleep(ms, bWakeOnJobs) {
    this.timestamp_sleep= syscall('timestamp');
    this.bSleeping= true;
    if(arguments.length== 2) this.bWakeOnJob= bWakeOnJobs;
    if(arguments.length) {
      var cmd= 'var _= syscall("atoms")["'+ this.guid+ '"]; _.refer= null; _.wake()';
      if(this.refer) {
              unschedule(this.refer);
              this.refer= null;
          }
      this.refer= schedule(cmd, ms);
    }
  }
  function reschedule(ms, bAll, lParam) {
    return this.job(lParam, true, ms, bAll);
  }
  function poll(ms, time_frame, commence, OnStart, OnStop) {
     if(ms) {
       this.timestamp_poll= syscall('timestamp');
       var cmd= 'var _= syscall("atoms")["'+ this.guid+ '"]; _.run()';
       if(arguments.length< 3) commence= true;
       this.bPolling= true;
       if(this.poller) this.poller.stop();
       this.poller= new Timer(cmd, ms, time_frame, commence, OnStart, OnStop);
       this.poller.start(ms);
     }else {
       this.bPolling= false;
       this.poller.stop();
       this.poller= null;
     }
  }
  this.thread= new Object();
  var i, e;
  try {
    var te= thread_events;
    var TE= ThreadEvents;
    this.thread.initialize= te[TE.OnInitialize];
    this.thread.destroy= te[TE.OnDestroy];
    this.thread.run= te[TE.OnRun];
    this.thread.stop= te[TE.OnStop];
    for(i= 0; i< 4; i++) if(typeof(te[i])!= 'function') throw i; // [BUG] (enum?)
  }catch(e) {
    SetLastError(['Thread: Invalid argument! ('+ i+ ')',
        Errors.InvalidArgument, get_call_stack(arguments.callee)]);
  }
  this.id= syscall('ID');
  this.guid= syscall('GUID');
  this.poller= null;
  this.bRunning= false;
  this.bJobsPending= false;
  this.bWakeOnJob= false;
  this.bSleeping= false;
  this.bPolling= false;
  this.thread.lParam= lParam;
  this._jobs= [];
  this.refer= null;
  this.initialize= initialize;
  this.destroy= destroy;
  this.run= run;
  this.stop= stop;
  this.job= job;
  this.jobs= jobs;
  this.wake= wake;
  this.sleep= sleep;
  this.reschedule= reschedule;
  this.poll= poll;
  this.user= new Object();
  this.timestamp= syscall('timestamp');
  return this;
}//~Thread()

function thread_new(t_name, _thread, lParam) { // NETERMINAT
  var t= syscall('threads');
  if(!t) return null;
  else {
    var mangle= syscall('name mangler');
    if(typeof(mangle)!= 'function') return null;
    t_name= mangle(t_name);
  }
  var _t= t[t_name];
  if(isThread(_t)) {
    if(_t.bRunning) _t.stop();
    _t.destroy();
  }
  if(!isThread(_thread)) _t= new Thread(_thread, lParam);
  t[t_name]= _t;
  _t.initialize(); // [BUG] (delay?)
  return t[t_name];
}//~thread_new()

function thread_delete(t_name) {
  var t= syscall('threads');
  if(!t) return null;
  else {
    var mangle= syscall('name mangler');
    if(typeof(mangle)!= 'function') return null;
    t_name= mangle(t_name);
  }
  var _t= t[t_name];
  if(isThread(_t)) {
    if(_t.bRunning) _t.stop(true);
    _t.destroy();
  }
  delete t[t_name];
}//~thread_delete()

function thread(t_name) {
  var t= syscall('threads');
  if(!t) return null;
  else {
    var mangle= syscall('name mangler');
    if(typeof(mangle)!= 'function') return null;
    t_name= mangle(t_name);
  }
  if(!isThread(t[t_name])) return null;
  return t[t_name];
}//~thread()
</SCRIPT>
<SCRIPT>
function set_attribute(obj, attribute, lValue, bSilent) {
  var e;
  try {
    return eval('obj.'+ attribute+ '= lValue');
  }catch(e) {
    if(!bSilent) SetLastError([(e.number & 0xffff), e.description, get_call_stack(arguments.callee)]);
      return null;
  }
}

function get_attribute(obj, attribute, bSilent) {
  var e;
  try {
    return eval('obj.'+ attribute);
  }catch(e) {
    if(!bSilent) SetLastError([(e.number & 0xffff), e.description, get_call_stack(arguments.callee)]);
      return null;
  }
}

function system_bootstrap() { // UNDER CONSTRUCTION
 function sys_name_mangler(s) {
   s= s.replace(' ', '_');
   return ('__sys_'+ s+ '__');
 }
  if(!isEmpty(eval("window."+ sys_name_mangler('system')))) return;
  var _syscalls= ['ID', 'handle', 'mouse', 'drag', 'click', 'keyboard', 'system', 'threads',
         'timers', 'windows', 'history', 'errors', 'random', 'ram', 'ramdrive', 'temp', 'buffers', 'stack',
         'terminal', 'shell', 'registry', 'dictionary', 'graphics', 'menu', 'buttons', 'editor',
         'calculator', 'atoms', 'widgets'];
  _syscalls.foreach('eval("window."+ lParam(v[i])+ "= new Handle()")', sys_name_mangler);
  _syscalls.foreach('eval("window."+ lParam(v[i])+ ".readonly= false")', sys_name_mangler);
  var _id= syscall('ID', new Number(0));
  _id.get= new Function('this.set("this.entity.valueOf()+ 1"); return this.entity.valueOf()');
  var sys= syscall('system', new Handle());
  sys.set(new Array());
  syscall('errors', new Handle()).readonly= true;
  var _rand= syscall('random');
  _rand.get= new Function('this.set("floor(random()* Math.RESOLUTION)"); return this.entity.valueOf()');
  syscall('stack', new Array());
  syscall('random', new Number(0));
  syscall('history', new Array());
  syscall('threads', new Handle()).set(new Array());
  syscall('atoms', new Array());
  var t= syscall('timers', new Array());
  t.get().toString= new Function("   var i;\n   var s= '';\n   for(i in this) { if(parseInt(i)) s+= this[i]+ ' ';}\n   return '['+ s+ ']';"); //hmm...
  syscall('shell', new Shell()).readonly= true;
  syscall('registry', new Registry());
  //
  var _readonly_syscalls= ['ID', 'random', 'timers', 'ram', 'temp', 'history', 'system', 'threads', 'windows',
        'stack', 'errors', 'atoms', 'shell', 'registry'];
  _readonly_syscalls.foreach('eval("window."+ lParam(v[i])+ ".readonly= true")', sys_name_mangler);
}//~system_bootstrap()

function syscall(io, lValue, bErase) {// UNDER CONSTRUCTION
  function name_mangler(s) {
        if(isEmpty(s)) s= 'undefined';
    s= trim(s).replace(' ', '_');
    return ('__ID_'+ s+ '__');
  }
  function sys_name_mangler(s) {
    s= s.replace(' ', '_');
    return ('__sys_'+ s+ '__');
  }
  function _hex(x) {return x.toString(16).toUpperCase();}
  function fix_hex(h, n) {
    var len= strlen(h);
    while(n> len++) h= '0'+ h;
    return h;
  }
  if(isEmpty(io)) return;
  if(typeof(io)== 'string') {
    io= trim(io);
    switch(io) {
      case 'ID':
      case 'handle':
      case 'mouse':
      case 'drag':
      case 'click':
      case 'keyboard':
      case 'system':
      case 'threads':
      case 'timers':
      case 'windows':
      case 'errors':
      case 'random':
      case 'ram':
      case 'ramdrive':
      case 'temp':
      case 'buffers':
      case 'terminal':
      case 'shell':
      case 'registry':
      case 'dictionary':
      case 'graphics':
      case 'menu':
      case 'buttons':
      case 'editor':
      case 'widgets':
      case 'atoms':
      case 'calculator': {
         io= sys_name_mangler(io);
         var bReadonly= eval('window.'+ io+ '.readonly');
         var bSet= (arguments.length== 2)? true: false;
         if(bSet) {
           if(!bReadonly) {
             eval('window.'+ io+ '.set(lValue)');
           }
         }
           if(!bReadonly) return eval('window.'+ io);
           else return eval('window.'+ io+ '.get()');
      break;}
      case 'date': return (new Date());
      case 'clock':
      case 'time': {
        var d, h, m, s, ms;
        d= new Date();
        h= d.getHours(); if(h< 9) h= '0'+ h;
        m= d.getMinutes(); if(m< 9) m= '0'+ m;
        s= d.getSeconds(); if(s< 9) s= '0'+ s;
        ms= d.getMilliseconds();
        return (h+ ':'+ m+ ':'+ s+ '.'+ ms);
      }
      case 'timestamp': return (new Date().getTime());
      case 'GUID': {
         var _guid, t, r, i, l;
         t= _hex(syscall('timestamp'));
         i= _hex(syscall('ID'));
         r= _hex(syscall('random'));
         //t= fix_hex(t, 16); i= fix_hex(i, 16); r= fix_hex(r, 16);
         _guid= '{'+t+ '-'+ i+ '-'+ r+ '}';
         return _guid;
      }
      case 'stack': // var s, id; id= syscall('ID'); s= syscall('stack', id);
      case 'history': {
         io= sys_name_mangler(io);
         var bReadonly= eval('window.'+ io+ '.readonly');
         if(!bReadonly) {
           var bSet= (arguments.length== 2)? true: false;
           var _history= eval('window.'+ io);
           if(bSet)_history.set(lValue);
           return _history;
         }
         var id= arguments[1];
         var bErase= arguments[2];
         if(!isEmpty(id)) {
           var _history= eval('window.'+ io+ '.get()')[id];
           if(isEmpty(_history)) {
             _history= new Stack();
             eval('window.'+ io+ '.get()')[id]= _history;
           }else if(bErase) {
              delete eval('window.'+ io+ '.get()')[id];
           }
           return _history;
         } else return null;
      }
      case 'bootstrap': return system_bootstrap();
      case 'window': return window;
      case 'document': return window.document;
      case 'name mangler': return name_mangler;
      case 'reload': { // BUG BUG (mangler: new_window)
         if(window.showModalDialog) {
             return window.new_window= window.showModalDialog(unescape(window.document.URL),
                szReloaded_argument, szReloaded_features.substring(0, szReloaded_features.length));
         }else {
           if(window.showModelessDialog) // [IE6]
             return window.new_window= window.showModelessDialog(document.URLUnencoded,
                szReloaded_argument, szReloaded_features.substring(0, szReloaded_features.length));
          else {// [FF2] (hmm.. close)
             document.location= document.location;
           }
         }
             break;
          }
      default: {
         SetLastError(['syscall: Invalid argument ('+ io+ ')',
             Errors.SysInvalidArgument, get_call_stack(arguments.callee)]);
         return null;
      }
    }
  }
}//~syscall()
</SCRIPT>
<SCRIPT>
function Base64Encode(str) {
    var sb= ""
    var charset= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    charset= charset.split('');
    var tmp, mask;

    for(var i= 0; i< str.length- 2;){
      tmp= 0;
      tmp+= (str.charCodeAt(i++))<< 16;
      tmp+= (str.charCodeAt(i++))<< 8;
      tmp+= (str.charCodeAt(i++));

      mask= 63<< 18;
      sb+= charset[(tmp& mask)>> 18];
      mask= 63<< 12;
      sb+= charset[(tmp & mask) >> 12];
      mask= 63<< 6;
      sb+= charset[(tmp & mask) >> 6];
      sb+= charset[tmp & 63];
    }

    tmp= 0;
    if((str.length% 3)== 2){
      tmp += str.charCodeAt(str.length- 2)<< 16;
      tmp += str.charCodeAt(str.length- 1)<< 8;

      mask= 63<< 18;
      sb+= charset[(tmp& mask)>> 18];
      mask= 63<< 12;
      sb+= charset[(tmp & mask) >> 12];
      mask= 63<< 6;
      sb+= charset[(tmp & mask) >> 6];

      sb+= '=';
    } else if((str.length% 3)== 1) {
      tmp += str.charCodeAt(str.length- 1)<< 16;

      mask= 63<< 18;
      sb+= charset[(tmp& mask) >> 18];
      mask= 63<< 12;
      sb+= charset[(tmp& mask)>> 12];
      sb+= "==";
    }

    return sb;
}//~Base64Encode()

function Base64() {
  this.b64= new Array(
  'A','B','C','D','E','F','G','H',
  'I','J','K','L','M','N','O','P',
  'Q','R','S','T','U','V','W','X',
  'Y','Z','a','b','c','d','e','f',
  'g','h','i','j','k','l','m','n',
  'o','p','q','r','s','t','u','v',
  'w','x','y','z','0','1','2','3',
  '4','5','6','7','8','9','+','/'
  );
  function encode(n) {
    n= string2stream(n);
    o= new Array();
    j= 0;
    for (var i= 0; i< n.length; i+= 3) {
      t= Math.min(3, n.length- i);
      if (t== 1) {
         x= n[i]& 0x000000FF;
         o[j++]= this.b64[(x>> 2)];
         o[j++]= this.b64[(x<< 4)& 0x00000030];
         o[j++]= '=';
         o[j++]= '=';
      } else if (t== 2) {
         x= n[i]& 0x000000FF;
         y= n[i+ 1]& 0x000000FF;
         o[j++]= this.b64[(x>> 2)];
         o[j++]= this.b64[((x<< 4)& 0x00000030)+ (y>> 4)];
         o[j++]= this.b64[((y<< 2)& 0x0000003C)];
         o[j++]= '=';
      } else {
         x= n[i]& 0x000000FF;
         y= n[i+ 1]& 0x000000FF;
         z= n[i+ 2]& 0x000000FF;
         o[j++]= this.b64[(x>> 2)];
         o[j++]= this.b64[((x<< 4)& 0x00000030)+ (y>> 4)];
         o[j++]= this.b64[((y<< 2)& 0x0000003C)+ (z>> 6)];
         o[j++]= this.b64[(z& 0x0000003F)];
      }
    }
    return o.join('');
  }//~Base64.encode()
  function decode(n) {
    function d2b64(d) {
      r= -1;
      for (var i= 0; i< b64.length; i++) {
        if (d== b64[i]) {
          r= i;
          break;
        }
      }
      return r;
    }
    var b64= this.b64;
    if ((n.length% 4)!= 0) return null;
    o= new Array();
    j= 0;
    for (var i= 0; i< n.length; i+= 4) {
      x1= d2b64(n.charAt(i));
      x2= d2b64(n.charAt(i+ 1));
      x3= d2b64(n.charAt(i+ 2));
      x4= d2b64(n.charAt(i+ 3));
      ol= 4;
      if (x4== -1) { ol--; x4= 0;}
      if (x3== -1) { ol--; x3= 0;}
      if (ol== 4) {
        o[j++]= (x1<< 2)| (x2>> 4);
        o[j++]= ((x2& 0x000000F)<< 4)| (x3>> 2);
        o[j++]= ((x3& 0x0000003)<< 6)| x4;
      } else if (ol== 3) {
        o[j++]= (x1<< 2)| (x2>> 4);
        o[j++]= ((x2& 0x000000F)<< 4)| (x3>> 2);

      } else if (ol== 2) {
        o[j++]= (x1<< 2)| (x2>> 4);
      }
    }
    return o;
  }//~Base64.decode()
  this.encode= encode;
  this.decode= decode;
  return this;
}//~Base64()

/*
function test_Base64codec() {
  var _b64= new Base64();
  var s= 'Base64 encoding is usually smaller than a hexadecimal representation';
  echo('hex:\n'+ string2hex(s));
  echo('Base64:\n'+ Base64Encode(s));
  var s64= _b64.encode(s);
  echo(s64);
  var n_new= stream2string(_b64.decode(s64));
  echo(n_new);
}
test_Base64codec();
*/
function base642stream(b64) {//"base642stream(stream2base64([1, 2, 3, 4]))== [1,2,3,4]"
  return (new Base64).decode(b64.replace_all("\n", ""));
}
function stream2base64(s) {
  var b64= new Base64();
  return b64.encode(stream2string(s));
}
function string2base64(s) {return Base64Encode(s);}
function base642string(b64) {return stream2string(base642stream(b64));}

/* // test: create a binary file (as a base64 encoded archive)
var s= '';
for(var i= 0; i<= 0xFF; i++) {
  s+= chr(i);
}
file_put_contents('a:\\256.bin', s, true);
var sb64= string2base64(s);
echo(sb64)
*/
</SCRIPT>
<SCRIPT>
function _crc32(data) {// ANSI CRC-32
  function unsigned_int(ui32) {return eval(hex(ui32));}
  function get_crctable() {
    var crc_mask= base642stream(
      "AEGCwwRFhscISYrLDE2OzxBRktMUVZbXGFma2xxdnt8gYaLjJGWm5yhpqussba7vMHGy8zR1tvc4ebr7"+
      "PH2+/0ABwoNEBcaHSAnKi0wNzo9QEdKTVBXWl1gZ2ptcHd6fYCHio2Ql5qdoKeqrbC3ur3Ax8rN0Nfa3"+
      "eDn6u3w9/r+AwQJDhMUGR4jJCkuMzQ5PkNESU5TVFleY2RpbnN0eX6DhImOk5SZnqOkqa6ztLm+w8TJz"+
      "tPU2d7j5Onu8/T5/wIFCA8SFRgfIiUoLzI1OD9CRUhPUlVYX2JlaG9ydXh/goWIj5KVmJ+ipaivsrW4v"+
      "8LFyM/S1djf4uXo7/L1+Pw==");
    var crctab= [];
    var c;
    var mask= 0x6DB88320;
    for (var i= 0; i< 256; i++) {
      c= i;
      for (var j= 0; j< 8; j++)
        c= (c& 1)? (mask^ (c>> 1)): (c>> 1);
      crctab[i]= unsigned_int(c^ (crc_mask[i]<< 24));
    }
    return crctab;
  }//~get_crctable();

  data= string2stream(data);
  var n= data.length;

  var table= get_crctable();
  var crc= 0xFFFFFFFF;

  for(var i= 0; i< n; i++) {
    var k= (crc^ data[i])& 0xFF;
    crc= ((crc>> 8)& 0x00FFFFFF)^ table[k];
  }

  return unsigned_int(~crc); // "hex(crc32('acronym: CRC= Cyclic Redundancy Check'))==  0x7A9F3F6D"
}//~_crc32()

function crc32(data) {// ANSI CRC-32
  var unsigned_int= DWORD;  //function unsigned_int(ui32) {return eval(hex(ui32));}
  function get_crctable() {
    var crctab= [];
    var c;
    var mask= 0xEDB88320;
    for (var i= 0; i< 256; i++) {
      c= i;
      for (var j= 0; j< 8; j++)
        c= (c& 1)? (mask^ (c>>> 1)): (c>>> 1);
      crctab[i]= unsigned_int(c);
    }
    return crctab;
  }//~get_crctable();

  data= string2stream(data);
  var n= data.length;

  var table= get_crctable();
  var crc= 0xFFFFFFFF;

  for(var i= 0; i< n; i++) {
    var k= (crc^ data[i])& 0xFF;
    crc= (crc>>> 8)^ table[k];
  }

  return unsigned_int(~crc); // "hex(crc32('acronym: CRC= Cyclic Redundancy Check'))==  0x7A9F3F6D"
}//~crc32()

function streamCRC32(s) {
  return crc32(stream2string(s)); //"hex(streamCRC32([1, 2, 3, 4]))== 0xB63CFBCD"
}
</SCRIPT><SCRIPT>
//"RSA Data Security, Inc. MD5 Message-Digest Algorithm"
function md5(x, bRaw) {// Calculate the MD5 (RFC 1321) of a string (ASCII)
  var bUnicode= false;
  var i, j, k, len, f, u, v, w, s, t;
  //These functions implement the four basic operations the algorithm uses.
  f= '(d^ (b& (c^ d)))#(c^ (d& (b^ c)))#(b^ c^ d)#(c^ (b| ~d))'.split('#').foreach(
    'v[i]= new Function(lParam.split(""), "return add32(rol32(add32(a'+
    'dd32(a, #), add32(x, t)), s), b);".replace_all("#", v[i]))', 'abcdxst');
  v= [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
  u= [0, 3, 2, 1];
  w= '0123301223011230'.split('').foreach('v[i]= parseInt(v[i])');
  s= base642stream(
    'BwwRFgcMERYHDBEWBwwRFgUJDhQFCQ4UBQkOFAUJDhQECxAXBAsQFwQLEBcECxAX'+
    'BgoPFQYKDxUGCg8VBgoPFQABAgMEBQYHCAkKCwwNDg8BBgsABQoPBAkOAwgNAgcM'+
    'BQgLDgEEBwoNAAMGCQwPAgAHDgUMAwoBCA8GDQQLAgk='
   );
  t= range(64).foreach('v[i]= 0x100000000* abs(sin(i+ 1))');
  len= x.length* ((bUnicode)? 16: 8);
  x= string2dwstream(x);
  x[len>> 5]|= 0x80<< ((len)% 32); x[(((len+ 64)>>> 9)<< 4)+ 14]= len;//append padding
  for(i= 0; i < x.length; i += 16) {
    for(k= 0; k< 4; k++) v[k+ 4]= v[k];
    k= 16;
    for(j= 0; j!= 64;) {
      v[u[j% 4]]= f[(j& 48)>> 4](v[w[k++% 16]], v[w[k++% 16]],
      v[w[k++% 16]], v[w[k++% 16]], x[s[j+ 64]], s[j], t[j++]);
    }
    for(k= 0; k< 4; k++) v[k]= add32(v[k], v[k+ 4]);
  }
  var md5sum= dwstream2hex([v[0], v[1], v[2], v[3]]);
  if(bRaw) md5sum= hex2stream(md5sum);
  return md5sum;
}//~md5()
//echo('\n\n\n\n     '+ md5('keep up the good work')); echo('md5: fc43be4358d081623dec3219d6ef6408');//sould be equal
</SCRIPT><SCRIPT>
function double2hex(f) {//BUG: [UNDER CONSTRUCTION]
  var h, sign, mantissa, exponent, aux;
  f= parseFloat(f);
  if(f< 0) {
    sign= 1;
  }else {
    sign= 0;
  }
  aux= f.toString().split('e');
  if(aux.length== 2) {
    exponent= parseInt(aux[1]);
  }else {
    exponent= 0;
  }
  mantissa= fabs(parseFloat(aux[0])).toString().split('.');
  if(mantissa.length== 2) {
    aux= mantissa[1].length;
    exponent-= aux;
    mantissa= mantissa.join('');
  }else {}
  exponent= (WORD(exponent)& 2047);
  mantissa= parseFloat(mantissa);

  sign= sign.toString(16);
  exponent= exponent.toString(16);
  mantissa= mantissa.toString(16);
  while(exponent.length< 3) {exponent= '0'+ exponent;}
  while(mantissa.length< 13) {mantissa= '0'+ mantissa;}

  aux= (parseInt(exponent, 16)+ (parseInt(sign)<< 11)).toString(16);
  while(aux.length< 3) {aux= '0'+ aux;};
  aux= '0x'+ aux+ mantissa;
  h= [sign, exponent, mantissa, aux];//((-1)^sign)* ((1.mantissa)^(exponent- 1023))
  h= aux;
  return h;
}//~double2hex()
function string2number(data, dwSize, dwStart) {
  if(!dwSize) dwSize= 4;
  if(!dwStart) dwStart= 0;
  return parseInt(string2hex(stream2string(string2stream(data.slice(dwStart, dwStart+ dwSize)).reverse())), 16);
}//~string2number()
function number2string(number, dwSize) {
  if(dwSize> 4) {
    SetLastError(['Error: number2string: Argument "dwSize" greater than 4 not yet implemented! ('+ dwSize+ ')',
                  Errors.NotImplemented, get_call_stack(arguments.callee)]);
    return strdup('\0', dwSize- 1);
  }
  return (hex(number).slice(10- 2* dwSize).explode(2).foreach("v[i]= chr(parseInt(v[i], 16));").reverse().join(''));
}//~number2string()
function string2DWORD(data, dwStart) {return string2number(data, 4, dwStart);}
function string2WORD(data, dwStart) {return string2number(data, 2, dwStart);}
function string2BYTE(data, dwStart) {return string2number(data, 1, dwStart);}
function DWORD2string(dwValue) {return number2string(dwValue, 4);}
function WORD2string(uValue) {return number2string(uValue, 2);}
function BYTE2string(nValue) {return number2string(nValue, 1);}

function _string2BYTE(dwStart) {return string2number(this, 1, dwStart);}
function _string2WORD(dwStart) {return string2number(this, 2, dwStart);}
function _string2DWORD(dwStart) {return string2number(this, 4, dwStart);}
function _String2Hex(dwSize, bFill, bRevert) {
  var s= this.valueOf();
  if(dwSize) {
    s= s.slice(0, dwSize);
    if(bFill) while(s.length< dwSize) s+= '\0';
  }
  s= string2hex(s);
  if(bRevert) {s= s.explode(2).reverse().join('');}
  return s;
}//~_String2Hex()
function _Number2String(nSizeOf) {//53bit unsigned integer
  var s, n, mask;
  n= parseInt(this);
  s= '';
  mask= 0x1FFFFFFFFFFFFF;
  if(fabs(n)> mask) {
    n= sign(n)* mask;
  }
  if(n< 0) {n= (mask- (-n))+ 1;}
  while(n) {
    var d= n& 0xFF;
    s+= chr(d);
    n= floor(n/ 0x100);
  }
  while(s.length< nSizeOf) s= '\0'+ s;
  if(nSizeOf) s= s.slice(0, nSizeOf);
  return s;
}//~_Number2String()

String.prototype.bPack= new Handle();
String.prototype.byte= _string2BYTE;
String.prototype.word= _string2WORD;
String.prototype.dword= _string2DWORD;
String.prototype.hex= _String2Hex;
Number.prototype.string= _Number2String;

//echo("1234".dword(1).string(2));//"23"

function vsprintf(mask, args) {//BUG: [UNDER CONSTRUCTION!]
  var Token, FlagToken, PrefixToken, TypeToken, DigitToken, PreviousTokens, bBogusToken, bProcessFlags, bProcessWidth;
  var bProcessPrecision, bProcessSize, bLeftAlign, bZeroPrefix, bPoint, bSign, bBlank, dwSize, dwPrecision;
  Token= " #*+-.0123456789CEGILSXbcdefghilnopsux";
  FlagToken= " #+-0";
  PrefixToken= 'ILhl'.split('');//'I'= 'I64'
  TypeToken= 'CEGSXbcdefginopsux';
  DigitToken= '1234567890';
  function getToken(s) {
    var idx, token, c;
    c= s[0].charAt(0);
    PreviousTokens+= c;
    if(!c) return '';
    idx= Token.indexOf(c);
    if(idx== -1) return '';
    s[0]= s[0].slice(1);
    token= Token.charAt(idx);
    return token;
  }
  function peekToken(s) {return s[0].charAt(0);}
  function isOfTokenType( token, TokenType) {
    var idx;
    if(!token) return false;
    idx= TokenType.indexOf(token);
    if(idx== -1) return false;
    return true;
  }
  function isToken(token) {return isOfTokenType(token, Token);}
  function isTypeToken(token) {return isOfTokenType(token, TypeToken);}
  function isFlagToken(token) {return isOfTokenType(token, FlagToken);}
  function isPrefixToken(token) {return isOfTokenType(token, PrefixToken);}
  function isDigitToken(token) {return isOfTokenType(token, DigitToken);}
  function processToken(token, data) {
    function _round(str) {
      var i, c, bSign;
      str= trim(str).split('');
      if(str[0]== '-') {
        bSign= true;
        str.first();
      }
      i= str.length- 1;
      if(str[i]== '9') c= 1;
      while(i&& str[i]== '9') {
        if(c) {
          str[i]= '0';
          if(str[i- 1]!= '.') {
            str[i- 1]= (parseInt(str[i- 1])+ c).toString();
          }else {
            str[--i- 1]= (parseInt(str[i- 1])+ c).toString();
          }
          if(str[i- 1].length> 1) {
            str[i- 1]= '9';
          }else {c= 0;}
        }
        i--;
      }
      if(!i) {
        if((c)&& (str[i]== '9')) str[i]= '10';
      }
      if(bSign) str.first('-');
      return str.join('');
    }//~_round()
    function processSize(bNumber) {
      if(dwSize) {
        dwSize= dwSize- data.length;
        if(dwSize< 0) dwSize= 0;
      }else return;
      var Sgn, Prefix;
      Prefix= ((bZeroPrefix)?'0':' ');
      if(bNumber&& (Prefix== '0')) {
        Sgn= data.charAt(0);
        if((Sgn== '-')|| (Sgn== '+')) {
          data= data.slice(1);
        }else Sgn= '';
      }
      while(dwSize--) {data= Prefix+ data;}
      if(Sgn&& Sgn.length) data= Sgn+ data;
    }//~processSize()
    function processSign(bNegative) {
      if(bSign) {
        if(data.charAt(0)!= '-') data= ((bNegative)?'-': '+')+ data;
      }
    }
    switch(token) {
      case 'b': {//binary
        var bNegative, nMask;
        bNegative= false;
        data= parseInt(data);//treat data as a 53bit integer
        if(data< 0) bNegative= true;
        nMask= 0x1FFFFFFFFFFFFF;
        if(fabs(data)> nMask) {
          SetLastError(['sprintf: Invalid argument '+ data+ '!', Errors.InvalidArgument, get_call_stack()]);
          //data= ((data>0)? '+': '-')+ 'Inf'; break;
          data= sign(data)* nMask;
        }
        if(data< 0) {data= (nMask- (-data))+ 1;}
        data= data.toString(2);
        processSign(bNegative);
        processSize();
      break;}
      case 'C': {}
      case 'c': {
        if(typeof(data)== 'undefined') data= '';
        if(data.constructor== (NaN).constructor) {
          data= chr(parseInt(data));
        }else {
          if(data.constructor== ("").constructor) {
            data= data.charAt(0);
          }else {
            data= '';//??
          }
        }
      break;}
      case 'E': {
      break;}
      case 'e': {
      break;}
      case 'G': {
      break;}
      case 'g': {
      break;}
      case 'S': {}
      case 's': {
        if(typeof(data)== 'undefined') data= typeof(data);
        if(typeof(data.toString)== 'function') {
          data= (''+ data).split('\0')[0];
        }
        processSize();
      break;}
      case 'X': {
        var bNegative= false;
        if(parseInt(data)< 0) bNegative= true;
        data= hex(data).slice(2);
        if(dwSize) {
          data= data.slice(data.length- dwSize);
        }
        if(bPoint) data= '0x'+ data;
        data= data.toUpperCase();
        processSign(bNegative);
      break;}
      case 'x': {
        var bNegative= false;
        if(parseInt(data)< 0) bNegative= true;
        data= hex(data).slice(2);
        if(dwSize) {
          data= data.slice(data.length- dwSize);
        }
        if(bPoint) data= '0x'+ data;
        data= data.toLowerCase();
        processSign(bNegative);
      break;}
      case 'i': {}
      case 'd': {
        data= parseInt(data).toString();
        processSign();
        processSize(true);
      break;}
      case 'f': {//bug: Under Construction!
        data= parseFloat(data).toString();
        if(dwPrecision) {
          if(data.indexOf('e')!= -1) {
            var p= parseInt(data.split('e')[1]);
            data= data.split('e')[0];
            if(p< 0) {
              p= fabs(p);
              data= '0.'+ strdup('0', p- 2)+ data.replace('.', '');
            }else {
              if(data.indexOf('.')!= -1) {
                p-= data.split('.')[1].length;
              }
              data= data.replace('.', '')+ strdup('0', p- 1);
            }
          }
        }
        if((data.indexOf('.')!= -1)&& dwPrecision) {
          data= data.split('.');
          data[1]= data[1].split('');
          data[1].length= dwPrecision;//+ 1;
          data[1]= data[1].join('');
          data= _round(data.join('.'));
        }
        processSign();
        processSize(true);
      break;}
      case 'n': {
      break;}
      case 'o': {//DWORD octal
        data= parseInt(data).toString(8);
        processSign();
        processSize(true);
      break;}
      case 'p': {
      break;}
      case 'u': {
      break;}
    }
    //echo(token+ ': "'+ data+ '"');//dbg
    //echo('dwSize:      '+ dwSize);echo('dwPrecision: '+ dwPrecision);//dbg
    return data;
  }//~processToken()
  function _vsprintf(mask, args) {
    function _data(mask, args) {
      var s;
      s= [];
      mask= mask.split('%').reverse();
      if(mask[mask.length- 1].length) {s.push(mask.pop());}
      while(mask.length) {
        var token, _mask;
        _mask= [mask.pop()];
        PreviousTokens= '';
        bBogusToken= false;
        bProcessFlags= true;
        bProcessWidth= true;
        bProcessSize= true;
        bProcessPrecision= true;
        bLeftAlign= false;
        bZeroPrefix= false;
        bPoint= false;
        bSign= false;
        bBlank= false;
        dwSize= 0;
        dwPrecision= 0;
        do {
          if(!isToken(peekToken(_mask))) {
            //s.push(_mask[0]);
            s.push(PreviousTokens);
            break;
          }else {}
          token= getToken(_mask);
          //processToken//dbg
          if(isTypeToken(token)) {
            //processArgument//dbg
            var data= processToken(token, args.pop());
            s.push(data);//s.push('['+ args.pop()+ ']');//dbg
            //token= '';
            break;
          }else {
            if(bProcessFlags) {
              if(isFlagToken(token)) {
                do{
                  switch(token) {
                    case ' ': {bBlank= true; break;}
                    case '#': {bPoint= true; break;}
                    case '+': {bSign= true; bBlank= false; break;}
                    case '-': {bLeftAlign= true; break;}
                    case '0': {bZeroPrefix= true; break;}
                  }
                  if(!isFlagToken(peekToken(_mask))) {
                    bProcessFlags= false;
                    break;
                  }
                  token= getToken(_mask);
                }while(1);
                if(bProcessWidth) {
                  if(isDigitToken(peekToken(_mask))) {
                    token= getToken(_mask);
                  }
                }
              }else {
                bProcessFlags= false;
              }
            }
            if(bProcessWidth) {
              while(isDigitToken(token)) {
                dwSize+= token;
                var d= peekToken(_mask);
                if(isDigitToken(d)) {
                  token= getToken(_mask);
                }else {
                  if(bProcessPrecision) {
                    if(peekToken(_mask)== '.') {
                      token= getToken(_mask);
                    }else {
                      bProcessToken= false;
                    }
                  }
                  break;
                }
              }
              dwSize= parseInt(dwSize, 10);
              bProcessWidth= false;
            }
            if(bProcessPrecision) {
              if(token== '.') {
                while(isDigitToken(peekToken(_mask))) {
                  token= getToken(_mask);
                  dwPrecision+= token;
                }
              }else {}
              dwPrecision= parseInt(dwPrecision);
              bProcessPrecision= false;
            }
            if(bProcessSize) {
              //bug: UNDER CONSTRUCTION
            }
            if(!_mask[0]) {
              s.push(PreviousTokens);
              token= '';
            }else {}
          }
        } while(token.length!= 0);
        s.push(_mask[0]);
      }
      return s.join('');
    }//~_vsprintf._data();
    var s= [];
    mask= mask.split("%%").reverse();
    while(mask.length) {s.push(_data(mask.pop(), args));}
    s= s.join('%');
    return s;
  }//~vsprintf._vsprintf()
  //SetLastError(['vsprintf: Not yet fully implemented! "'+ mask+ '"', Errors.NotImplemented, get_call_stack()]);
  return _vsprintf(mask, args.reverse()); // ultimately, will emulate the "vsprintf()" function from the C++ library
}//~vsprintf()

function sprintf(mask/*, ...*/) { // sprintf(mask, ...)
  var v= vector_copy();
  return vsprintf(v.splice(0, 1)[0], v);
}//~sprintf()

function echof(mask/*, ...*/) {
  var str= vsprintf(mask, vector_copy().slice(1))+ '\n';
  print(str);
}
</SCRIPT>
<SCRIPT>
function Palette(pal, type) {
  this.palette= [];
  this.length= 0;
  this.type= '';
  function string2rgb(s) {
    var re= /^\s*(\S+)\s*(\S+)\s*(\S+)\s*$/;
    var m= s.match(re);
    var c= [];
    c[2]= parseInt(m.pop());
    c[1]= parseInt(m.pop());
    c[0]= parseInt(m.pop());
    return c;
  }
  function toString() {
    return this.palette.toString();
  }
  function valueOf() {
    return this.palette.valueOf();
  }
  function setColor(i, r, g, b, a) {
    this.palette[i]= [r, g, b, a];
  }
  function getColor(i) {
    return this.palette[i];
  }
  function getHTMLColor(i) {
    var c= this.palette[i];
    if(c== undefined) {
      return '';
    }else {
      if(c.length< 3) return '';
      return sprintf("#%02X%02X%02X", c[0], c[1], c[2]);
    }
  }
  function setHTMLColor(i, c, alpha) {
    c= trim(c).replace_all('#', '').explode(2);
    return this.palette[i]= [parseInt(c[0], 16), parseInt(c[1], 16), parseInt(c[2], 16), alpha];
  }
  function count() {
    return this.palette.length;
  }
  function Import(pal, type) { //UNDER CONSTRUCTION
    var p= new Palette();
    switch(type) {
       default: {} // try to import an HTML type of palette by default
       case 'HTML': {
         SetLastError(['Palette.Import: "HTML" UNDER CONSTRUCTION!']);
         pal= pal.split('\n');
         var n= pal.length;
         for(var i= 0; i< n; i++) p.setHTMLColor(i, pal[i]);
       } break;
       case 'JASC-PAL': {
         pal= pal.split('\n');
         pal.foreach("v[i]= v[i].replace_all(chr(0x0D), '')"); //get rid of what's left from a CRLF marker
         if(pal[0]!= "JASC-PAL") { // error: header
           echo("header not found "+ string2hex(pal[0])); //dbg
         } else { // error header not found
           if(pal[1]!= "0100") { // error: version
            echo("error: version mismatch (0100)\n");//dbg
           }else {
             var n= parseInt(pal[2]); // number of colors
             for(var i= 0; i< n; i++) {
               var rgb= p.string2rgb(pal[i+ 3]);
               p.setColor(i, rgb[0], rgb[1], rgb[2]);
               //echo(i+ ': '+ p.getHTMLColor(i));//dbg
             }
           }
         }
         //echo(p);//dbg
       } break;
       case 'RGB-STREAM':{
         var n= floor(pal.length/ 3);
         for(var i= 0; i< n; i++) {
           p.setColor(i, pal[i* 3], pal[i* 3+ 1], pal[i* 3+ 2]);
         }
       } break;
    }
    return (this.palette= p.palette); //var s= buffer_get(1); var pal001= new Palette(); pal001.Import(s, "JASC-PAL");
  }//~Palette.Import()
  function Export(type) { //UNDER CONSTRUCTION
    var pal= '';
    switch(type) {
      default: {} // default to HTML
      case 'HTML': {
        var n= this.count();
        for(var i= 0; i< n; i++) {
          pal+= this.getHTMLColor(i)+ '\n';
        }
      } break;
      case 'JASC-PAL': {
        //SetLastError(['Palette.Export: "JASC-PAL" not yet implemented!']);
        var n= this.count();
        pal+= 'JASC-PAL\n0100\n'+ n+ '\n';
        for(var i= 0; i< n; i++) {
          var c= this.palette[i];
          pal+= c[0]+ ' '+ c[1]+ ' '+ c[2]+ '\n';
        }
      } break;
      case 'RGB-STREAM': {
        pal= [];
        var n= this.count();
        for(var i= 0; i< n; i++) {
          var c= this.palette[i];
          pal.push(c[0]);
          pal.push(c[1]);
          pal.push(c[2]);
        }
      } break;
    }
    return pal;
  }//Palette.Export()
  this.string2rgb= string2rgb;
  this.toString= toString;
  this.valueOf= valueOf;
  this.setColor= setColor;
  this.getColor= getColor;
  this.getHTMLColor= getHTMLColor;
  this.setHTMLColor= setHTMLColor;
  this.Import= Import;
  this.Export= Export;
  this.count= count;
  if(arguments.length)  this.palette= this.Import(pal, type);
  return this;
}//~Palette()
/* //TEST
//var html_pal= buffer_get(4);
var html_pal= "#AaBbCc\n#CCFFEE\n#001123";
var p= new Palette(html_pal, 'HTML');
p.setColor(p.count(), 13, 14, 15);
echo(p.Export('HTML'));
*/
</SCRIPT>
<SCRIPT>
function random_color() {
  var r, g, b;
  r= mt_rand(256);
  g= mt_rand(256);
  b= mt_rand(256);
  return sprintf("#%02X%02X%02X", r, g, b);
}

function rgb(r, g, b) {
  r= abs(r% 256);
  g= abs(g% 256);
  b= abs(b% 256);
  return ("rgb("+ r+ ", "+ g+ ", "+ b+ ")");
}//~rgb()

function rgb2hex(r, g, b) {//color [triplet 8bit] -> html format (#RRGGBB)
  return sprintf("#%02X%02X%02X", r, g, b);
}

function hex2rgb(hex) {
  return  [hexdec(substr(hex, 1, 2)), hexdec(substr(hex, 3, 2)), hexdec(substr(hex, 5, 2))];
}

function rgb2cmyk(R, G, B, bInteger) {
  var cyan, magenta, yellow, black;
  cyan   = 255- R;
  magenta= 255- G;
  yellow = 255- B;
  black  = min(cyan, magenta, yellow);
  if(black!= 255) {
    cyan   = ((cyan   - black)/ (255- black))* 255;
    magenta= ((magenta- black)/ (255- black))* 255;
    yellow = ((yellow - black)/ (255- black))* 255;
  }else {
    cyan= magenta= yellow= 0;
  }
  if(bInteger)   return [round(cyan), round(magenta), round(yellow), round(black)];
  else return [cyan/ 255, magenta/ 255, yellow/ 255, black/ 255];
}

function hsi2rgb(H, S, I) {//BUG: under construction
  var T;
  var Rv, Gv, Bv;
  var rgb= [];
  H= revolve(1.0- H, (1.0/ 16.0)* 9.0);
  T= 2* Math.PI* H;
  Rv= 1+ S* sin(T- 2* Math.PI/ 3);
  Gv= 1+ S* sin(T);
  Bv= 1+ S* sin(T+ 2* Math.PI/ 3);
  T= 127.999* I;
  rgb[0]= trunc(T* Rv);
  rgb[1]= trunc(T* Gv);
  rgb[2]= trunc(T* Bv);
  return rgb;
}//hsi2rgb()

function getDefaultPaletteHSI256(bOnlyHues, bInvert, bShuffle) {//BUG: under construction
  var H, S, I;
  var X, Y, Z;
  var P= new Palette();
  var Xx, Yy;
  var Jj;
  var K;
  var aa,bb,cc;
  //  FUN! (aa* bb* cc== 256)
  if(bOnlyHues) {
    aa= 1;
    bb= 1;
    cc= 256;
  }else {
      aa= 8;  // intensities
      bb= 2;  // saturations
      cc= 16; // hues
  }

  var i= 0;
  //create HSI spectrum
  for (X= 0; X< aa; X++)      // eight different intensities
    for (Y= 0; Y< bb; Y++)    // two different saturations
      for (Z= 0; Z< cc; Z++) { // sixteen different hues
        //determine H,S,I between 0 and 1
        H= Z/ cc;
        S= (Y+ 1)/ bb;
        I= (X+ 1)/ aa;
        //calculate and store R,G,B values
        var rgb= hsi2rgb(H, S, I);
        if(bInvert) rgb.foreach('v[i]= ~v[i]& 0xFF');
        //P.setColor(Z+ cc* Y+ cc* bb* X, rgb[0], rgb[1], rgb[2]);
        P.setColor(i++ , rgb[0], rgb[1], rgb[2]);
      }

  if(bShuffle) vector_shuffle(P.palette);
  return P; //DrawPalette(getDefaultPaletteHSI256(true, false));
}//~getDefaultPaletteHSI256()

//DrawPalette(getDefaultPaletteHSI256(false, true));
//DrawPalette(getDefaultPaletteHSI256(true, false));
//DrawPalette(getDefaultPaletteHSI256());

function getDefaultPaletteVGA256() {
  var p= new Palette(
    base642stream(
    "AAAAAACqAKoAAKqqqgAAqgCqqlUAqqqqVVVVVVX/Vf9VVf///1VV/1X///9V////AAAAFBQUICAgLS0t"+
    "OTk5RUVFUVFRYWFhcXFxgoKCkpKSoqKitra2ysrK4+Pj////AAD/QQD/fQD/vgD//wD//wC+/wB9/wBB"+
    "/wAA/0EA/30A/74A//8Avv8Aff8AQf8AAP8AAP9BAP99AP++AP//AL7/AH3/AEH/fX3/nn3/vn3/333/"+
    "/33//33f/32+/32e/319/559/759/999//993/99vv99nv99ff99ff+eff++ff/fff//fd//fb7/fZ7/"+
    "trb/xrb/27b/67b//7b//7br/7bb/7bG/7a2/8a2/9u2/+u2//+26/+22/+2xv+2tv+2tv/Gtv/btv/r"+
    "tv//tuv/ttv/tsb/AABxHABxOQBxVQBxcQBxcQBVcQA5cQAccQAAcRwAcTkAcVUAcXEAVXEAOXEAHHEA"+
    "AHEAAHEcAHE5AHFVAHFxAFVxADlxABxxOTlxRTlxVTlxYTlxcTlxcTlhcTlVcTlFcTk5cUU5cVU5cWE5"+
    "cXE5YXE5VXE5RXE5OXE5OXFFOXFVOXFhOXFxOWFxOVVxOUVxUVFxWVFxYVFxaVFxcVFxcVFpcVFhcVFZ"+
    "cVFRcVlRcWFRcWlRcXFRaXFRYXFRWXFRUXFRUXFZUXFhUXFpUXFxUWlxUWFxUVlxAABBEABBIABBMQBB"+
    "QQBBQQAxQQAgQQAQQQAAQRAAQSAAQTEAQUEAMUEAIEEAEEEAAEEAAEEQAEEgAEExAEFBADFBACBBABBB"+
    "ICBBKCBBMSBBOSBBQSBBQSA5QSAxQSAoQSAgQSggQTEgQTkgQUEgOUEgMUEgKEEgIEEgIEEoIEExIEE5"+
    "IEFBIDlBIDFBIChBLS1BMS1BNS1BPS1BQS1BQS09QS01QS0xQS0tQTEtQTUtQT0tQUEtPUEtNUEtMUEt"+
    "LUEtLUExLUE1LUE9LUFBLT1BLTVBLTFBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"),
    'RGB-STREAM');
  return p;
}//~getDefaultPaletteVGA256()

function palettemap2jascpal(p, max_slots) { //convert an rgb-triplet text list to JASC-PAL type of palette format
  var CRLF= chr(13)+ chr(10);
  var PALETTE_HEADER_JASC= 'JASC-PAL\n0100\n';
  var DM= 'DUMMY_MARKER\n';
  p= DM+ p;
  p= p.replace_all(CRLF, '\n');
  p= p.replace_all(chr(13), '\n');
  while(p.search('  ')!= -1)  p= p.replace_all('  ', ' ');
  p= p.replace_all('  ', ' ');
  p= p.replace_all('\n ', '\n');
  p= p.replace_all(' \n', '\n');
  p= p.replace(DM, '');
  var n;
  var tp= p.split('\n');
  n= tp.length;
  for(var i= 0; i< n; i++) { // purge empty lines from list
    if(!strlen(trim(tp[i]))) {
      tp= tp.remove(i);
      i--;
      n--;
    }
  }
  tp.foreach('var rgb= v[i].split(" "); rgb.length= 3; v[i]= rgb.join(" ");');
  if(max_slots== undefined) max_slots= 256; // default palette entries: 256
  else if(max_slots== -1) max_slots= n; //no limit
  if(max_slots&& (n> max_slots)) {//limit palette entries to a maximum (eg. 16)
    tp.length= max_slots;
    n= tp.length;
  }
  p= PALETTE_HEADER_JASC+ n+ '\n'+ tp.join('\n')+ '\n';
  p= p.replace_all('\n', CRLF);
  return p;
}//~palettemap2jascpal()

/*
var x= file_get_contents('altern.map');
//var p= palettemap2jascpal(x, 256);
var max_c= -1;//fetch all colors in the original palette map
var p= palettemap2jascpal(x, max_c);
//file_put_contents('PVPGS.pal', p);
echo(p);
*/
</SCRIPT>
<SCRIPT>
function shell_open_with(file) {
  var hInstance= WinExec('rundll32.exe shell32.dll,OpenAs_RunDLLA '+ file);
  return hInstance; // var hp= shell_open_with('help.htm');
}
function shell_folder_options() {
  return WinExec('rundll32.exe shell32.dll,Options_RunDLL');
}
</SCRIPT>
<SCRIPT>
function ImprovedNoise() { // a JavaScript version of: "JAVA REFERENCE IMPLEMENTATION OF IMPROVED NOISE - COPYRIGHT 2002 KEN PERLIN."
  function noise(x, y, z) {
    var X= parseInt(Math.floor(x))& 255;  // FIND UNIT CUBE THAT
    var Y= parseInt(Math.floor(y))& 255;  // CONTAINS POINT.
    var Z= parseInt(Math.floor(z))& 255;
    x-= Math.floor(x);                    // FIND RELATIVE X,Y,Z
    y-= Math.floor(y);                    // OF POINT IN CUBE.
    z-= Math.floor(z);
    var u= fade(x);                       // COMPUTE FADE CURVES
    var v= fade(y);                       // FOR EACH OF X,Y,Z.
    var w= fade(z);
    var A= this.p[X  ]+ Y; var AA= this.p[A]+ Z; var AB= this.p[A+1]+ Z; // HASH COORDINATES OF
    var B= this.p[X+1]+ Y; var BA= this.p[B]+ Z; var BB= this.p[B+1]+ Z; // THE 8 CUBE CORNERS,
    return this.lerp(
      w,
      this.lerp(
        v,
        this.lerp(
          u,
          this.grad(this.p[AA], x, y, z),          // AND ADD
          this.grad(this.p[BA], x- 1, y, z)
        ),                                         // BLENDED
        this.lerp(
          u,
          this.grad(this.p[AB], x, y- 1, z),       // RESULTS
          this.grad(this.p[BB], x- 1, y- 1, z)
        )
      ),                                           // FROM  8
      this.lerp(
        v,
        this.lerp(
          u,
          this.grad(this.p[AA+ 1], x, y, z- 1),    // CORNERS
          this.grad(this.p[BA+ 1], x- 1, y, z- 1 )
        ),                                         // OF CUBE
        this.lerp(
          u,
          this.grad(this.p[AB+ 1], x, y- 1, z- 1),
          this.grad(this.p[BB+ 1], x- 1, y- 1, z- 1)
        )
      )
    );
   }//~ImprovedNoise.noise()
   function fade(t) {return t* t* t* (t* (t* 6.0- 15.0)+ 10.0);}
   function lerp(t, a, b) {return a+ t* (b- a);}
   function grad(hash, x, y, z) {
      var h= parseInt(hash) & 15;            // CONVERT LO 4 BITS OF HASH CODE
      var u= ((h< 8)? x: y);                 // INTO 12 GRADIENT DIRECTIONS.
      var v= ((h< 4)? y: ((h== 12|| h== 14)? x: z));
      return ((h& 1 )== 0 ? u: -u)+ ((h& 2)== 0? v: -v);
   }
   var p= new Array(512);
   var permutation= base642stream(
      "l6CJW1oPgw3JX2A1wukH4YwkZx5FjghjJfAVChe+BpT3eOpLABrFPl7828t1IwsgObEhWO2VOFeu"+
      "FH2Iq6hEr0qlR4aLMBumTZKe51Nv5Xo804Xm3GlcKTcu9Sj0Zo82QRk/oQHYUEnRTIS70FkSqcjE"+
      "h4J0vJ9WpGRtxq26A0A02eL6fHsFyiaTdn7/UlXUz8474y8QOhG2vRwq37eq1Xf4mAIsmqNG3Zll"+
      "m6crrAmBFif9E2Jsbk9x4OiyuXBo2vZh5Psi8sHu0pAMv7Oi8VEzkev5Du9rMcDWH7XHap24VMyw"+
      "c3kyLX8Elv6K7M1d3nJDHRhI842Aw05C1z2ctA==");
   for (var i= 0; i< 256 ; i++) {
     p[256+ i]= permutation[i];
     p[i]= permutation[i];
   }
  this.p= p;
  this.fade= fade;
  this.lerp= lerp;
  this.grad= grad;
  this.noise= noise;
}//~ImprovedNoise()

function PerlinNoise() {return new ImprovedNoise();}

function noise_get3D(x, y, z) {
  x= int32(parseInt(x));
  y= int32(parseInt(y));
  z= int32(parseInt(z));
  if(x) x= 1/ x;
  if(y) y= 1/ y;
  if(z) z= 1/ z;
  if(typeof(arguments.callee.PerlinNoise)!= 'object') arguments.callee.PerlinNoise= new PerlinNoise();
  return arguments.callee.PerlinNoise.noise(x, y, z);
}//~noise_get3D()

</SCRIPT>
<SCRIPT>
function BuildGammaTable(g) {// palette is sent through this [src: from QUAKE1 sources]
  var i, inf;
  var gammatable= new Array(256);
  if (g== 1.0) {//no gamma
    for (i= 0; i< 256; i++)
      gammatable[i]= i;
    return gammatable;
  }
  for (i= 0; i< 256; i++) {
    inf= parseInt(255.0* pow((i+ 0.5)/ 255.5, g)+ 0.5);
    gammatable[i]= clip(inf, 0, 255);
  }
  return gammatable;
}//~BuildGammaTable()

/*
var gamma= 0.9;
var gammatable= BuildGammaTable(gamma);
echo('gamma: '+ gamma+ '\ngammatable:\n'+ gammatable);
echo();
gamma= 2.0;
gammatable= BuildGammaTable(gamma);
echo('gamma: '+ gamma+ '\ngammatable:\n'+ gammatable);
*/
</SCRIPT>
<SCRIPT>
var ColorShifts= [ //rgba PALETTE FLASHES (src: QUAKE1)
  [215, 186,  69,  50], //BONUS "Bonus Flash"

  [  0,   0, 255,  30], //QUAD "Quad Damage"

  [  0, 255,   0,  20], //SUIT "Environmental Suit"
  [100, 100, 100, 100], //INVISIBILITY "Invisibility"
  [255, 255,   0,  30], //INVULNERABILITY "Invulnerability"

  [130,  80,  50,   0], //EMPTY, SOLID "none"
  [130,  80,  50, 128], //WATER "Undervater"
  [255,  80,   0, 150], //LAVA
  [  0,  25,   5, 150], //SLIME

  [200, 100, 100, 150], //DAMAGE "armor > blood"
  [220,  50,  50, 150], //DAMAGE "armor"
  [255,   0,   0, 150]  //DAMAGE "blood"
];

function ShiftColor(rgba, cs_rgba, gamma) {
  var a= cs_rgba[3]/ 255.0;
  if(!isEmpty(gamma)&& gamma!= 1.0) {
    for(var i= 0; i< 3; i++) {
      var s= parseInt(interpolate_linear(rgba[i], cs_rgba[i], a)); // shift
      var g= parseInt(255.0* pow((s+ 0.5)/ 255.5, gamma)+ 0.5);    // gamma correction
      rgba[i]= clip(g, 0, 255);
    }
  }else {
    for(var i= 0; i< 3; i++)
      rgba[i]= parseInt(interpolate_linear(rgba[i], cs_rgba[i], a));
  }
}//~ShiftColor()

/*
echo('color shifts: '+ ColorShifts.length);
echo('0: BONUS: '+ ColorShifts[0]);
echo('11: BLOOD: '+ ColorShifts[11]);

var c= [100, 100, 100, 255];//red green bule alpha
var sc= c.clone();
var gamma= random();
ShiftColor(sc, ColorShifts[11], gamma);

echo('\ncolor: '+ c);
echo('shifted: '+ sc);
echo('gamma: '+ gamma);
*/
</SCRIPT>
<SCRIPT>
function ScriptX_getVersion() {
 var nav=navigator;
 var s= '\n[Powered by: "';
 s+= nav.appCodeName;
 s+= ' '+ nav.appVersion;
 s+= '"]\n\n\n';
 return ("JavaScript - 000 - #baseline\n\nLicense: Unlicense\n\n\n[since Apr 2002 ]\n\n"+s);
}
function help() {alert(ScriptX_getVersion());}
</SCRIPT>
<SCRIPT>
function px2twip(px) {//pixels to twips conversion BUG: "I'm not sure"
  return Math.round(px* 26.457);
}
</SCRIPT>
<SCRIPT>
function text2unicode(s, encoding) {//BUG: "incomplete; for now only Central Europe charsets are there"
  encoding= encoding.toLowerCase();
  var encoding_table;
  switch(encoding) {
    case 'iso-8859-1':
    case 'iso8859-1': {
       //encoding_table= range(256);
       return s;//is already stored as a unicode string (no mapping required)
    }break;
    case 'iso-8859-2':
    case 'iso8859-2': {//ISO 8859-2 (Latin-2); The Latin 2 character set (Central Europe)
      var map= "0000000100020003000400050006000700080009000A000B000C000D000E000F"+
      "0010001100120013001400150016001700180019001A001B001C001D001E001F"+
      "0020002100220023002400250026002700280029002A002B002C002D002E002F"+
      "0030003100320033003400350036003700380039003A003B003C003D003E003F"+
      "0040004100420043004400450046004700480049004A004B004C004D004E004F"+
      "0050005100520053005400550056005700580059005A005B005C005D005E005F"+
      "0060006100620063006400650066006700680069006A006B006C006D006E006F"+
      "0070007100720073007400750076007700780079007A007B007C007D007E007F"+
      "0080008100820083008400850086008700880089008A008B008C008D008E008F"+
      "0090009100920093009400950096009700980099009A009B009C009D009E009F"+
      "00A0010402D8014100A4013D015A00A700A80160015E0164017900AD017D017B"+
      "00B0010502DB014200B4013E015B02C700B80161015F0165017A02DD017E017C"+
      "015400C100C2010200C40139010600C7010C00C9011800CB011A00CD00CE010E"+
      "01100143014700D300D4015000D600D70158016E00DA017000DC00DD016200DF"+
      "015500E100E2010300E4013A010700E7010D00E9011900EB011B00ED00EE010F"+
      "01110144014800F300F4015100F600F70159016F00FA017100FC00FD016302D9";
       map= map.explode(4);
       map.foreach('v[i]= parseInt(v[i], 16)');
       encoding_table= map;
    }break;
    case 'cp1250': {//Windows code page 1250 (Central Europe)
      var map= "0000000100020003000400050006000700080009000A000B000C000D000E000F"+
      "0010001100120013001400150016001700180019001A001B001C001D001E001F"+
      "0020002100220023002400250026002700280029002A002B002C002D002E002F"+
      "0030003100320033003400350036003700380039003A003B003C003D003E003F"+
      "0040004100420043004400450046004700480049004A004B004C004D004E004F"+
      "0050005100520053005400550056005700580059005A005B005C005D005E005F"+
      "0060006100620063006400650066006700680069006A006B006C006D006E006F"+
      "0070007100720073007400750076007700780079007A007B007C007D007E007F"+
      "20AC0081201A0083201E2026202020210088203001602039015A0164017D0179"+
      "009020182019201C201D202220132014009821220161203A015B0165017E017A"+
      "00A002C702D8014100A4010400A600A700A800A9015E00AB00AC00AD00AE017B"+
      "00B000B102DB014200B400B500B600B700B80105015F00BB013D02DD013E017C"+
      "015400C100C2010200C40139010600C7010C00C9011800CB011A00CD00CE010E"+
      "01100143014700D300D4015000D600D70158016E00DA017000DC00DD016200DF"+
      "015500E100E2010300E4013A010700E7010D00E9011900EB011B00ED00EE010F"+
      "01110144014800F300F4015100F600F70159016F00FA017100FC00FD016302D9";
       map= map.explode(4);
       map.foreach('v[i]= parseInt(v[i], 16)');
       encoding_table= map;
    }break;
    default: {
      SetLastError(['text2unicode: "'+ encoding+ '" encoding not implemented!',
                Errors.NotImplemented, get_call_stack(arguments.callee)]);
      return null;
    }
  }
  s= string2stream(s);
  var n= s.length;
  for(var i= 0; i< n; i++) s[i]= encoding_table[s[i]];
  s= stream2string(s);
  return s;
}//~text2unicode()

window.text2unicode= text2unicode;

/*
var str= range(256);

var ustr= text2unicode(stream2string(str), 'cp1250');
var ustream= string2stream(ustr).foreach('v[i]= sprintf("%04X", v[i])');
echo('cp1250');
echo(ustream.join(''));
//file_put_contents('cp1250', ustream.join(''));

ustr= text2unicode(stream2string(str), 'iso8859-2');
ustream= string2stream(ustr).foreach('v[i]= sprintf("%04X", v[i])');
echo('iso8859-2');
echo(ustream.join(''));
//file_put_contents('iso8859-2', ustream.join(''));

//echo(string2stream(ustr));
*/
</SCRIPT>
<SCRIPT>
function PseudoRandom(registru, register_size) { //(BUG!) Secventa PseudoAleatoare (SPA) cu registru pe 'register_size' biti
  register_size= clip(register_size, 1, 32);
  registru= clip(registru, 0, uint32_ones(register_size));
  if(!registru) registru= 1; // nonzero or it will not work (ever)
  var lsb= bitget(registru, 0);
  var msb= bitget(registru, register_size- 1);
  registru= (shl(registru, 1)& uint32_ones(register_size));
  registru= bitset(registru, xor(lsb, msb), 0);
  return registru;
}//~PseudoRandom()

function SPAX(REGISTER_SIZE, DEFAULT_SEED, new_seed, caller) {//BUG! (FAILURE: 5bit & 8bit registers, and probably more)
  var seed;
  if(new_seed&& clip(new_seed, 0, uint32_ones(REGISTER_SIZE))) {
    new_seed= clip(new_seed, 0, uint32_ones(REGISTER_SIZE));
    caller.SPAX_seed= undefined;
    DEFAULT_SEED= new_seed;
  }
  if(isEmpty(caller.SPAX_seed)) {
    seed= DEFAULT_SEED;
    caller.SPAX_seed= seed;
    return seed;
  } else {
    seed= caller.SPAX_seed;
    if(!seed) {
      seed= DEFAULT_SEED;
      caller.SPAX_seed= seed;
      return seed;
    }
  }
  seed= PseudoRandom(seed, REGISTER_SIZE);
  caller.SPAX_seed= seed;
  return seed;
}//~SPAX()

function SPA5(new_seed) { //Secventa PseudoAleatoare cu registru pe 5 biti
  var code_table= [7, [0, 2, 1, 3, 4]];//[20, [2, 3, 0, 4, 1]];//[13, [2, 4, 1, 3, 0]];//[7, [0, 2, 1, 3, 4]];//[19, [4, 3, 2, 1, 0]];
  var seed;
  var REGISTER_SIZE= 5;
  var DEFAULT_SEED= ((REGISTER_SIZE<< 1)+ (REGISTER_SIZE- 2));

  function scramble_register(r5) {
    var XOR_mask= code_table[0];
    var WIRE_mask= code_table[1];
    var REGISTER_SIZE= WIRE_mask.length;
    var bits= BITS(r5, REGISTER_SIZE);
    while(bits.length) {
      var i= REGISTER_SIZE- bits.length;
      r5= bitset(r5, bits.pop(), WIRE_mask[i]);
    }
    r5^= XOR_mask;
    return r5;
  }//SPA5.scramble_register()

  if(arguments.length) {
    new_seed= clip(new_seed, 0, uint32_ones(REGISTER_SIZE));
    arguments.callee.SPAX_seed= undefined;
    DEFAULT_SEED= new_seed;
  }

  if(isEmpty(arguments.callee.SPAX_seed)) {
    seed= DEFAULT_SEED;
    arguments.callee.SPAX_seed= seed;
  } else {
    seed= arguments.callee.SPAX_seed;
  }

  var r5_mask= uint32_ones(REGISTER_SIZE);
//print(seed+ ' '+ dump_register(seed, REGISTER_SIZE));//dbg
  seed= (seed+ 1)& r5_mask;
  var r5= seed;
  r5= scramble_register(r5);
//echo(' '+ r5+ ' '+ dump_register(r5, REGISTER_SIZE));//dbg
  arguments.callee.SPAX_seed= seed;
  return r5;
}//~SPA5() //FEATURE: "it shows a pattern and probably you don't want that.."

function SPA8(new_seed) { //Secventa PseudoAleatoare cu registru pe 8 biti
  SetLastError(["SPA8: under construction!", Errors.UnderConstruction, get_call_stack(arguments.callee)]);
  var code_table= [
        [102, [1, 5, 3, 4, 7, 2, 0, 6]],//[38, [1, 5, 3, 4, 7, 2, 0, 6]];//[120, [0, 5, 1, 3, 4, 7, 6, 2]];//[7, [0, 2, 1, 3, 5, 7, 6, 4]];
        //[120, [0, 5, 1, 3, 4, 7, 6, 2]]
        [uint32_ones(6), [1, 5, 3, 4, 7, 2, 0, 6]]
      ];
  var seed;
  var REGISTER_SIZE= 8;
  var DEFAULT_SEED= ((REGISTER_SIZE<< 1)+ (REGISTER_SIZE- 2));

  function scramble_register(r8, code_table) {
    var XOR_mask= code_table[0];
    var WIRE_mask= code_table[1];
    var REGISTER_SIZE= WIRE_mask.length;
    var bits= BITS(r8, REGISTER_SIZE);
    while(bits.length) {
      var i= REGISTER_SIZE- bits.length;
      r8= bitset(r8, bits.pop(), WIRE_mask[i]);
    }
    r8^= XOR_mask;
    return r8;
  }//SPA8.scramble_register()

  if(arguments.length) {
    new_seed= clip(new_seed, 0, uint32_ones(REGISTER_SIZE));
    arguments.callee.SPAX_seed= undefined;
    DEFAULT_SEED= new_seed;
  }

  if(isEmpty(arguments.callee.SPAX_seed)) {
    seed= DEFAULT_SEED;
    arguments.callee.SPAX_seed= seed;
  } else {
    seed= arguments.callee.SPAX_seed;
  }

  var r8_mask= uint32_ones(REGISTER_SIZE);
//print(seed+ ' '+ dump_register(seed, REGISTER_SIZE));//dbg
  seed= (seed+ 1)& r8_mask;
  var r8= seed;
  r8= scramble_register(r8, code_table[0]);
  r8= scramble_register(r8, code_table[1]);
//echo(' '+ r8+ ' '+ dump_register(r8, REGISTER_SIZE));//dbg
  arguments.callee.SPAX_seed= seed;
  return r8;
}//~SPA8() //FEATURE: "the palette shows a nice pattern"

function SPA2(new_seed) { //Secventa PseudoAleatoare cu registru pe 2 biti
  return SPAX(2, 1, new_seed, arguments.callee);
}
function SPA3(new_seed) { //Secventa PseudoAleatoare cu registru pe 3 biti
  return SPAX(3, 1, new_seed, arguments.callee);
}
function SPA4(new_seed) { //Secventa PseudoAleatoare cu registru pe 4 biti
  return SPAX(4, 1, new_seed, arguments.callee);
}
function SPA6(new_seed) { //PseudoRandom Sequence (6bit register)
  return SPAX(6, 1, new_seed, arguments.callee);
}
function SPA7(new_seed) { //PseudoRandom Sequence (7bit register)
  return SPAX(7, 1, new_seed, arguments.callee);
}
//function SPA8(new_seed) { //PseudoRandom Sequence (8bit register)
//  return SPAX(8, 1, new_seed, arguments.callee);//BUG!
//}
function SPA16(new_seed) { //PseudoRandom Sequence (16bit register)
  return SPAX(16, 1, new_seed, arguments.callee);//BUG!
}
function SPA32(new_seed) { //PseudoRandom Sequence (32bit register)
  return SPAX(32, 1, new_seed, arguments.callee);//BUG!
}

function crypto_SPA8(x) {//PseudoRandom Sequence (8bit register) (a permutation that's more noise like, visually) Use: "Permute vector v if v.length== 256 using only one 8bit register."
  var a, b, c, y;
  x&= 0xFF;
  x= SPA8(SPA8(SPA8(x)));
//  a= 2; b= 11; c= 23;//BUG: FAIL permutation! (probably because a== 2)
  a= 13; b= 17; c= 37;//TODO: Test if a, b, c need to be primes or just odd.
  y= (((x* a+ x* b+ x* c)& 0xFF)^ 13);
  a= 3; b= 5; c= 17;
  y= (((y* a+ y* b+ y* c)& 0xFF)^ 43);
  y= SPA8(SPA8(SPA8(y)));
  return y;
  //"IF trivial(x, y), transcendent(x, z0), contingent(z0, z1) THEN z0= crypto_SPA8(x^ (0& 0xFF)); z1= crypto_SPA8(x^ (y& 0xFF))."
}//~crypto_SPA8()

window.PseudoRandom= PseudoRandom;
window.SPAX= SPAX;

window.SPA2= SPA2;//OK
window.SPA3= SPA3;//OK
window.SPA4= SPA4;//OK
window.SPA5= SPA5;//NEW ALGORITHM (a permutation)
window.SPA6= SPA6;//OK
window.SPA7= SPA7;//OK

window.SPA8= SPA8;//BUG: "test: FAILED"
window.SPA16= SPA16; //BUG: "test failed"
window.SPA32= SPA32; //BUG: TO TEST :)
window.crypto_SPA8= crypto_SPA8;//OK (a permutation) (BUG: heavy use of beta SPA8 code. TODO: merge beta SPA8 code into crypto_SPA8.)

/*
function showGrayscalePalette(v) {
  var pal= vector2palette_grayscale(v);
  DrawPalette(pal);
}

function test_SPA() {
 function dump_register(register, register_size) {
    var str= '';
    for(var tmp= reg_size- 1; tmp>= 0; tmp--) str+= bitget(x, tmp);
    return str;
 }
 var bTestLength= false;
 var reg_size= 8;//8;// 2, 3, 4, 5
 var foo= eval('SPA'+ reg_size); //(eg. SPA3)
 echo('PseudoRandom Sequence: ('+ reg_size+ 'bit register)');
 var n= uint32_ones(reg_size);
 if(!bTestLength) n= 1;
 for(var j=1; j<= n; j++) {
  var v= [];
  foo(j);
  var m= uint32_ones(reg_size)+ 1;
  for(var i= 0; i< m; i++) {
    var x= foo();
    if(v[0]== x) {
       echo(j+ ': length: '+ v.length+ ' '+ ((v.length== (m- 1))? 'OK': 'FAILURE'));
       break;
    }
    v.push(x);
//    if(!bTestLength) echo(dump_register(x, reg_size)+ ' '+ x);
  }
  if(!bTestLength) {
    echo('\n'+ v.join(' '));
    v.foreach("marker(i+ 500, v[i]+ 500, 'green');");//shell_sort(v) would draw oblique lines
    
    if(reg_size== 7) v.foreach('v[i]*= 2'); //7bit
    if(reg_size== 6)  v.foreach('v[i]*= 4'); //6bit
    if(reg_size== 5) v.foreach('v[i]*= 8'); //5bit

    showGrayscalePalette(v);//the 5bit and 8bit registers show a pattern (no good)
    //shell_sort(v);
    //echo('\n'+ v.join(' '));
    //echo('length: '+ v.length);
  }
 }
}//~test_SPA()

test_SPA()
*/
</SCRIPT>
<SCRIPT>
function DrawPalette(pal) {
  var n= pal.count();
  var cell= [20, 20];
  var j= 0;
  var c;
  var x= 0;
  var y= 0;
  for(var i= 0; i< n; i++) {
    if(!(i% 16)) {j++; x= 0;}
    x+= cell[0];
    y= cell[1]* j;
    c= pal.getHTMLColor(i);
    bar(x, y, cell[0], cell[1], c);
  }
}//~DrawPalette()

function vector2palette_grayscale(v) {
  var pal= new Palette();
  var n= v.length;
  for(var i= 0; i< n; i++) pal.setColor(i, v[i], v[i], v[i]);
  return pal;
}
//DrawPalette(palette);

/*
function RandomPalette() {
  var ord= vector_shuffle(range(3));
  echo(ord);//dbg
  ord= [2, 0, 1];
  var vrgb= [range(256), range(256), range(256)];
  for(var i= 0; i< 256; i++) {
    vrgb[ord[0]][i]= SPA8(vrgb[ord[0]][i]);
    vrgb[ord[1]][i]= SPA8(255- vrgb[ord[1]][i]);
  }
  //vector_shuffle(vrgb[ord[2]]);
  var pal= new Palette();
  for(var i= 0; i< 256; i++) pal.setColor(i, vrgb[0][i], vrgb[1][i], vrgb[2][i]);
  return pal;//"DrawPalette(RandomPalette());"
}
*/

function RandomPalette() {
    var pal = new Palette;
    for (var i = 0; i < 256; i++) {
        pal.setColor(i, crypto_SPA8(i^ 13), crypto_SPA8(i^ 12), crypto_SPA8(i^ 11));
        //pal.setColor(i, SPA8(i^ 13), SPA8(i^ 12), SPA8(i^ 11));//BUG! (pattern found)
    }
    return pal;//"DrawPalette(RandomPalette());"
}
</SCRIPT>
<SCRIPT>
function image_grayscale2bw(img, bBinary) {//convert a grayscale image to black&white
  var threshold= [//8x8 Bayer ordered dithering pattern
    [  0, 128,  32, 160,   8, 136,  40, 168],
    [192,  64, 224,  96, 200,  72, 232, 104],
    [ 48, 176,  16, 144,  56, 184,  24, 152],
    [240, 112, 208,  80, 248, 120, 216,  88],
    [ 12, 140,  44, 172,   4, 132,  36, 164],
    [204,  76, 236, 108, 196,  68, 228, 100],
    [ 60, 188,  28, 156,  52, 180,  20, 148],
    [252, 124, 220,  92, 244, 116, 212,  84]
  ];
  var PATTERN_WIDTH= 8;
  var PATTERN_HEIGHT= 8;
  var white, black;
  if(bBinary) {
    black= 0;
    white= 1;
  }else {
    black= 0;
    white= 255;
  }
  var i, j, width, height;
  width= img.length;
  height= img[0].length;
  for(var i= 0; i< width; i++) {
    for(var j= 0; j< height; j++) {
      if(img[i][j]> threshold[i% PATTERN_WIDTH][j% PATTERN_HEIGHT])
        img[i][j]= white;
      else
        img[i][j]= black;
    }
  }
  return img;
}//~image_grayscale2bw()
</SCRIPT>
<SCRIPT>

function rgba2grayscale(bf_color, bf_gray) { // bf_color [in], bf_gray [out]
  var n= bf_gray.length;
  for(var i= 0; i< bf_gray.length; i++) {
    var j= (i<< 2);
    bf_gray[i]=  0.299* bf_color[j+ 0]+ 0.587* bf_color[j+ 1]+ 0.114* bf_color[j+ 2];//ITU-T
    //bf_gray[i]=  0.2126* bf_color[j+ 0]+ 0.7152* bf_color[j+ 1]+ 0.0722* bf_color[j+ 2]; //dbg
  }
}//~rgba2grayscale()
	
function grayscale2rgba(bf_gray, bf_color) { // bf_gray [in], bf_color [out]
  var n= (bf_color.length>> 2);
  for(var i= 0; i< n; i++) {
    var j= (i<< 2);
    bf_color[j+ 0]= bf_gray[i]; //r
    bf_color[j+ 1]= bf_gray[i]; //g
    bf_color[j+ 2]= bf_gray[i]; //b
    bf_color[j+ 3]= 255; //alpha channel
  }
}//~grayscale2rgba()

function dither_Random8(buff8, w, h, bBinary) {//convert a grayscale image to black&white (algorithm with LOW performance) DEPRECATED
  var white, black;
  if(bBinary) {
    black= 0;
    white= 1;
  }else {
    black= 0;
    white= 255;
  }
  var SUB_PIXELS= 1;
  for(var i= 0; i< (w* h* SUB_PIXELS); i++) {
     var x, y, threshold;
     x= (((i% (w* SUB_PIXELS))/ 1)/ SUB_PIXELS)>>> 0;
     y= (((i- (x* SUB_PIXELS))/ h)/ SUB_PIXELS)>>> 0;
     threshold= (((random()* 256)% 256)>>> 0);
     buff8[i]= ((buff8[i]> threshold)? white: black);
  }
/* // or...
  var i, j, width, height, threshold, ci;
  width= w;
  height= h;
  for(i= 0; i< height; i++) {
    for(j= 0; j< width; j++) {
      ci= i* width+ j;// pixel index
      threshold= (((random()* 256)% 256)>>> 0);
      buff8[ci]= ((buff8[ci]> threshold)? white: black);
    }
  }
  return buff8;
*/
}//~dither_Random8()

function dither_Random32(buff32, w, h, bBinary, bColorNoise) {//convert a grayscale image to black&white (algorithm with LOW performance) DEPRECATED
  var white, black;
  if(bBinary) {
    black= 0;
    white= 1;
  }else {
    black= 0;
    white= 255;
  }
  var SUB_PIXELS= 4;
  if(bColorNoise) {//(color noise) NICE! I see subpixel rendering! And I have in mind path tracing and Monte Carlo subpixel sampling.
    for(var i= 0; i< (w* h* SUB_PIXELS); i++) {
      var x, y;
      if((i% 4)== 3) continue;//skip alpha channel
      x= (((i% (w* SUB_PIXELS))/ 1)/ SUB_PIXELS)>>> 0;
      y= (((i- (x* SUB_PIXELS))/ h)/ SUB_PIXELS)>>> 0;
      var threshold= (((random()* 256)% 256)>>> 0); // NOTE: Here we compute a different threshold for each and every subpixel
      buff32[i]= ((buff32[i]> threshold)? white: black);
    }
  }else { // (black-and-white noise) ..or ALMOST same thing reformulated (NOTE: there is a small but significant variation)
    var i, j, width, height, ci, threshold;
    width= w;
    height= h;
    for(i= 0; i< height; i++) {
      for(j= 0; j< width; j++) {
        threshold= (((random()* 256)% 256)>>> 0); // NOTE: Here the threshold is the same for the 3 subpixels of the same pixel
        ci= (i* width+ j)* SUB_PIXELS;// pixel index
        buff32[ci+ 0]= ((buff32[ci+ 0]> threshold)? white: black); //red
        buff32[ci+ 1]= ((buff32[ci+ 1]> threshold)? white: black); //green
        buff32[ci+ 2]= ((buff32[ci+ 2]> threshold)? white: black); //blue
        //buff32[ci+ 3]; //skip alpha channel
      }
    }
  }
  return buff32;
}//~dither_Random32()

function dither_Bayer8(buff8, w, h, bBinary) {//convert a grayscale image to black&white
  var threshold= [//8x8 Bayer ordered dithering pattern
    [  0, 128,  32, 160,   8, 136,  40, 168],
    [192,  64, 224,  96, 200,  72, 232, 104],
    [ 48, 176,  16, 144,  56, 184,  24, 152],
    [240, 112, 208,  80, 248, 120, 216,  88],
    [ 12, 140,  44, 172,   4, 132,  36, 164],
    [204,  76, 236, 108, 196,  68, 228, 100],
    [ 60, 188,  28, 156,  52, 180,  20, 148],
    [252, 124, 220,  92, 244, 116, 212,  84]
  ];
  var PATTERN_WIDTH= 8;
  var PATTERN_HEIGHT= 8;
  var white, black;
  if(bBinary) {
    black= 0;
    white= 1;
  }else {
    black= 0;
    white= 255;
  }

  var SUB_PIXELS= 1;
  for(var i= 0; i< (w* h* SUB_PIXELS); i++) {
     var x, y;
     x= (((i% (w* SUB_PIXELS))/ 1)/ SUB_PIXELS)>>> 0;
     y= (((i- (x* SUB_PIXELS))/ h)/ SUB_PIXELS)>>> 0;
     buff8[i]= ((buff8[i]> threshold[x% PATTERN_WIDTH][y% PATTERN_HEIGHT])? white: black);
  }

/* ..or the same thing reformulated
  var i, j, width, height, ci;
  width= w;
  height= h;
  for(i= 0; i< height; i++) {
    for(j= 0; j< width; j++) {
      ci= i* width+ j;// pixel index
      buff8[ci]= ((buff8[ci]> threshold[i% PATTERN_WIDTH][j% PATTERN_HEIGHT])? white: black);
    }
  }
  return buff8;
*/
}//~dither_Bayer8()


function dither_Bayer32(buff32, w, h, bBinary) {//convert a grayscale image to black&white
  var threshold= [//8x8 Bayer ordered dithering pattern
    [  0, 128,  32, 160,   8, 136,  40, 168],
    [192,  64, 224,  96, 200,  72, 232, 104],
    [ 48, 176,  16, 144,  56, 184,  24, 152],
    [240, 112, 208,  80, 248, 120, 216,  88],
    [ 12, 140,  44, 172,   4, 132,  36, 164],
    [204,  76, 236, 108, 196,  68, 228, 100],
    [ 60, 188,  28, 156,  52, 180,  20, 148],
    [252, 124, 220,  92, 244, 116, 212,  84]
  ];
  var PATTERN_WIDTH= 8;
  var PATTERN_HEIGHT= 8;
  var white, black;
  if(bBinary) {
    black= 0;
    white= 1;
  }else {
    black= 0;
    white= 255;
  }
  var SUB_PIXELS= 4;
  for(var i= 0; i< (w* h* SUB_PIXELS); i++) {
     var x, y;
     if((i% 4)== 3) continue;//skip alpha channel
     x= (((i% (w* SUB_PIXELS))/ 1)/ SUB_PIXELS)>>> 0;
     y= (((i- (x* SUB_PIXELS))/ h)/ SUB_PIXELS)>>> 0;
     buff32[i]= ((buff32[i]> threshold[x% PATTERN_WIDTH][y% PATTERN_HEIGHT])? white: black);
  }

/* // ..or same thing but reformulated
  var i, j, width, height, ci;
  width= w;
  height= h;
  for(i= 0; i< height; i++) {
    for(j= 0; j< width; j++) {
      ci= (i* width+ j)* SUB_PIXELS;// pixel index
      buff32[ci+ 0]= ((buff32[ci+ 0]> threshold[i% PATTERN_WIDTH][j% PATTERN_HEIGHT])? white: black); //red
      buff32[ci+ 1]= ((buff32[ci+ 1]> threshold[i% PATTERN_WIDTH][j% PATTERN_HEIGHT])? white: black); //green
      buff32[ci+ 2]= ((buff32[ci+ 2]> threshold[i% PATTERN_WIDTH][j% PATTERN_HEIGHT])? white: black); //blue
      //buff32[ci+ 3]; //skip alpha channel
    }
  }
  return buff32;
*/
}//~dither_Bayer32()

function dither_FloydSteinberg8(bf_gray, w, h) { // reduce a grayscale image to a black-and-white image
  for(var i= 0; i< h; i++)
    for(var j= 0; j< w; j++) {
      var ci, cc, rc, err;
      ci= i* w+ j;     // color index
      cc= bf_gray[ci]; // color component (light intensity)
      rc= (cc< 127? 0: 255); // color's new computed value (best approximation) 
      err= cc- rc;           // approximation error
      bf_gray[ci]= rc; // set new color
      if(j+ 1< w) bf_gray[ci+    1] += (err* 7)>> 4; // error redistribute smart between neighbor pixels
      if(i+ 1== h) continue;//next line is valid
      if(j   > 0) bf_gray[ci+ w- 1] += (err* 3)>> 4; // ditto
                  bf_gray[ci+ w   ] += (err* 5)>> 4; //
      if(j+ 1< w) bf_gray[ci+ w+ 1] += (err* 1)>> 4; //
    }
}//~dither_FloydSteinberg8()

function dither_FloydSteinberg32(bf_color, w, h) { // reduce a true color image to an 8-colors palette image
  for(var i= 0; i< h; i++)
    for(var j= 0; j< w; j++) {
      var ci= 4* (i* w+ j); // color index
      for(var k= 0; k< 3; k++, ci++) { // for each color sub-component (but skip the last plane: the alpha plane)
        var cc, rc, err;
        cc= bf_color[ci]; // color sub-component (intensity)
        rc= (cc< 128? 0: 255); // color's new computed value (best approximation)
        err= cc- rc;           // approximation error
        bf_color[ci]= rc; // set new sub-component value
        if(j+ 1< w) bf_color[ci+        4] += (err* 7)>> 4; // error redistribute smart between neighbor pixels
        if(i+ 1== h) continue;//next line is valid
        if(j  >  0) bf_color[ci+ 4* w-  4] += (err* 3)>> 4; // ditto
                    bf_color[ci+ 4* w    ] += (err* 5)>> 4; //
        if(j+ 1< w) bf_color[ci+ 4* w+  4] += (err* 1)>> 4; //
      }
    }
}//~dither_FloydSteinberg32()
</SCRIPT>
<SCRIPT>
function mouse2vector(n, bPrompt) {//convert 'n' mouse clicks to a vector width 'n' (x, y) coordinates
  window.user.mouse= [];
  var m= window.user.mouse;
  m.n= n;
  m.x= window.drag.start.x;
  m.y= window.drag.start.y;
  m.bPrompt= bPrompt
  function mouse_thread() {
    var m, x, y;
    m= window.user.mouse;
    if(!m.n) {
      setTimeout("var m= window.user.mouse; clearInterval(m.thread);if(m.bPrompt) prompt('mouse2vector:', window.user.mouse)", 0);
      return;
    }
    x= window.drag.start.x;
    y= window.drag.start.y;
    if(!m.length) {
      if((m.x!= x)|| (m.y!= y)) {
        var P= new Point(x, y);
        m.push(P);
        m.n--;
      }
    }else {
      if((m[m.length- 1].x!= x)|| (m[m.length- 1].y!= y)) {
        var P= new Point(x, y);
        m.push(P);
        m.n--;
      }
    }
  }
  m.thread= setInterval("("+ mouse_thread.toString()+")()", 33);
  return m;
}//~mouse2vector()

function mouse2point() {
  var P= new Point(window.drag.start.x, window.drag.start.y);//mousedown
  P.copy(window.mouse);//mousemove
  return P;
}

//"echo(mouse2point());"
//"var v= mouse2vector(3, true);"
</SCRIPT>
<SCRIPT>
function LayerMaximize(obj) {
	var r= GetClientRect();
	obj.style['width']= r.right+ 'px';
	obj.style['height']= r.bottom+ 'px';
}//~LayerMaximize()
function MaximizeBackgroundLayer() {
	  LayerMaximize(document.getElementById("layer_background"));
}
</SCRIPT>
<SCRIPT>
function download(file_name, bLocalFile) {//BUG: UNDER CONSTRUCTION
  function get(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send();
      return xhr.responseXML.getElementsByTagName("file")[0].getAttribute("data");//return xhr.responseText;
    } catch (e) {
      return ''; // turn all errors into empty results
    }
  }
  if(arguments.length<= 1) bLocalFile= true;
  if(bLocalFile) {
    return base642string(get("GET.FILE(HEX.ASCII."+ string2hex(file_name)+ ").BASE64"));
  }else {
    return base642string(get("GET.URL(HEX.ASCII."+ string2hex(file_name)+ ").BASE64"));
  }
}//~download()

function upload(file_name, user_data, bLocalFile) {//BUG: UNDER CONSTRUCTION
  function get(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('PUT', url, false);
      xhr.send(string2base64(user_data));
      return xhr.responseText;
    } catch (e) {
      return ''; // turn all errors into empty results
    }
  }
  if(arguments.length<= 2) bLocalFile= true;
  if(bLocalFile) {
    return base642string(get("PUT.FILE(HEX.ASCII."+ string2hex(file_name)+ ").BASE64"));
  }else {
    return base642string(get("PUT.URL(HEX.ASCII."+ string2hex(file_name)+ ").BASE64"));
  }
}//~upload()

function zap_localStorage() {
  var i;
  for(i in localStorage) localStorage.removeItem(i);
}//~zap_localStorage()

window.download= download;
window.upload= upload;
window.zap_localStorage= zap_localStorage;

</SCRIPT>
<SCRIPT>
function bugfix0001() {//BUGFIX:[IE6]
  MaximizeBackgroundLayer();
  var height= document.getElementById('BT1').parentNode.offsetTop+ 'px';
  document.getElementById("textarea").style.height= height;
  document.getElementById("CON1").style.height= height;
}//~bugfix0001()
function bugfix0002() {//BUGFIX:[IE6]
  document.getElementById("CON1").style.color="rgb(200, 200, 200)";
}//~bugfix0002()
function bugfix0003() {//BUGFIX:[IE6]
  function foo(msg, url, line) {
    window.onerror= arguments.callee.bar;
    window.bBugfixErrorhandler= false;
    return true;
  }//~foo()
  function bar(msg, url, line) {
    window.onerror= arguments.callee.pwoe;
    window.bBugfixErrorhandler= true;
    return true;
  }//~bar()
  foo.bar= bar;
  bar.pwoe= window.onerror;
  window.onerror= foo;
  eval("0+");//NOTE: "__asm call foo;"
  return true;//NOTE: Won't get here.
}//~bugfix0003()
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
   //throw("bp0001");//dbg
   //new Array('ă');//BUG:[IE6]:'Unterminated string constant'
   //var ZileDinSaptamana=new Array('Duminică','Luni','Marţi','Miercuri','Joi','Vineri','Sâmbătă');//BUGFIX:[IE6]
   //var LuniDinAn=new Array('Ianuarie','Februarie','Martie','Aprilie','Mai','Iunie','Iulie','August','Septembrie','Octombrie','Noiembrie','Decembrie');
   var ZileDinSaptamana='Duminică.Luni.Marţi.Miercuri.Joi.Vineri.Sâmbătă'.split('.');
   var LuniDinAn= 'Ianuarie.Februarie.Martie.Aprilie.Mai.Iunie.Iulie.August.Septembrie.Octombrie.Noiembrie.Decembrie'.split('.');
   var wnd=window;
   var doc=wnd.document;
   var KeyState=new Matrix(2, 256);
   var _URL=new String("");
   var _name="";
   var _features= "width=640,height=480,status=yes,toolbar=no,scrollbars=yes,resizable=yes,menubar=yes,location=yes,top=10,left=50";
   var szReloaded_argument= "window.name='RELOADED';";
   var szReloaded_features= "dialogTop:10px;dialogLeft:50px;dialogWidth:640px;dialogHeight:480px;status:no;resizable:yes;help:no";
   var language=new String("JavaScript");
   var arStatus= new Array("keep up the good work ","... ","to the best of our knowledge ","Ready ","Error! ");
   var new_window= 0;
   var Bool1=new Boolean();
   var palette= getDefaultPaletteVGA256();

function main() {
  syscall('bootstrap');
  var i;
  var textarea= document.getElementById('textarea');
  var CON1= document.getElementById('CON1');
  document.title='             '+document.title+'             ';
  //wnd.screen.updateInterval=33;
  window.isDialog= isDialog;
  window.GetClientRect= GetClientRect;
  window.GetWindowRect= GetWindowRect;
  window.MoveWindow= MoveWindow;
  window.fullscreen= fullscreen;
  wnd.MoveWindow(0, 0, wnd.screen.width, wnd.screen.height);
  window.onerror= errortrap;
  window.onunload= OnClose;
  window.child= new Array(); // CreateWindow

if(document.location.protocol== "file:"){
   window.__file__= this_get_filename()
   window.this_filename= this_get_filename();
} else {
	/*//BUG:under construction
   window.buffer_load= undefined;
   window.buffer_save= undefined;
   window.buffer_saveas= undefined;
   window.buffer_get_filename= undefined;
   window.buffer_set_filename= undefined;
   window.buffer_loadhex= undefined;
   window.buffer_savehex= undefined;
   window.buffer_saveashex= undefined;
   */
};

//   if(typeof(window.user)== 'undefined')
   window.user= new Object;
  Bool1=(1<0);
  window.Timer1= new Timer(fooTimer1, 33, null, true);
  buffer_buffers(10, textarea);
  terminal('initialize', [10, CON1]);
  InitGRAPHICS();
  InitKEYBOARD();
  InitCON1();
  InitCALC1();
  InitButtons();
  InitKeyboardShortcuts();
  if(doc.location.protocol!="file:"){
     document.getElementById("but5").style.visibility="hidden";
     document.getElementById("but6").style.visibility="hidden";
  }
  CON1.style.fontWeight='bold';
  {
  var s= textarea.style;
  s.color= 'black';
  s.fontWeight= 'normal';
  s.fontSize= '10pt';//'x-small' 'small';
  s.fontSize= '13px';  
  //s.fontFamily= 'Courier New';//font-family: "Menlo", "Monaco", "Courier New", monospace;
  //consolas, courier, monospace
  s.fontFamily= '"Courier New", consolas, courier, monospace, "Menlo", "Monaco"';
  s.visibility= 'visible';
  s.background= "white";
  delete s;
  }
  textarea.focus();
  InitButtonOptions();
  clear(); //Ctrl+~
  if(document.location.protocol== "file:"){
    buffer_load(0, window.this_filename);
  };
/*   try {
      window.__python__= null;
      execScript('window.eval("window.__python__= true;")', "Python")
   }catch(e){};*/

  if(typeof(dialogArguments) != 'undefined') {
        main_job= new Function(dialogArguments);
        schedule(main_job);
  };
  if(doc.location.protocol!="file:") {
         buffer_set(0, document.getElementsByTagName("html")[0].outerHTML);
  }
  schedule('buffer_reload(undefined, true, true)', 2);// [BUGFIX] (interference with 'main.js')
  toggle();
  OnMouseInit();
  schedule('KeyboardBind(VK_O, VK_O_OnEvent);');
  schedule('KeyboardBind(VK_T, VK_T_OnEvent);');
  schedule('KeyboardBind(VK_S, VK_S_OnEvent);');
  if(isFirefox()) {
    schedule('KeyboardBind(VK_X, VK_S_OnEvent);');
  }
  schedule('KeyboardBind(VK_H, VK_H_OnEvent);');
  schedule('KeyboardBind(VK_C, VK_C_OnEvent);');
  for(var i= 0; i<= 9; i++) {
    KeyboardBind(eval('VK_'+ i), DigitKey_OnEvent);
  }
  KeyboardBind(VK_F1, VK_F1_OnEvent);
  schedule("MaximizeBackgroundLayer()");
  schedule("bugfix0001()");
  schedule("bugfix0002()");
  //schedule("bugfix0003()");//NOTE:Done. Must be done in "OnLoad()".
}//~main()

</SCRIPT>
<SCRIPT>
/*

//TODO: Use window.onresize, schedule() and GetClientRect() for accurate layout positioning.


window.onresize= null;
window.onresize= window.onresize= new Function('echo(+(new Date())+ ":onresize");//timestamp');

onclick="JavaScript:TOGGLE(event);"

var coll = document.all.tags("P");
if (coll.length>=5) {
    coll(4).style.textDecoration = "underline";
    coll(4).scrollIntoView(true);
}

   event.preventDefault();
   event.stopPropagation();

*/
</SCRIPT>
</HTML>
